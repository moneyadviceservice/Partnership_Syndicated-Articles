/* Minification failed. Returning unminified contents.
(20491,9-10): run-time error JS1010: Expected identifier: .
(20491,9-10): run-time error JS1195: Expected expression: .
(32506,42-43): run-time error JS1010: Expected identifier: .
(32506,42-43): run-time error JS1195: Expected expression: .
(32554,15-16): run-time error JS1010: Expected identifier: .
(32554,15-16): run-time error JS1195: Expected expression: .
 */
window.console = window.console || { log: function(log) { return; } };

window.getTorusInspector = window.getTorusInspector || function () { return null; };

// extend string object to include a format method like in c#
String.format = function() {
    var s = arguments[0];
    for (var i = 0; i < arguments.length - 1; i++) {
        var reg = new RegExp("\\{" + i + "\\}", "gm");
        s = s.replace(reg, arguments[i + 1]);
    }
    return s;
};

String.prototype.replaceAll = function (find, replace) {
    var str = this;
    return str.replace(new RegExp(find.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'), replace);
};

if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (search, this_len) {
        if (this_len === undefined || this_len > this.length) {
            this_len = this.length;
        }
        return this.substring(this_len - search.length, this_len) === search;
    };
}

if (String.prototype.repeat === undefined) {
    String.prototype.repeat = function (count) {
        var accumulator = '';

        while (count-- > 0) {
            accumulator += this;
        }

        return accumulator;
    };
}

if (String.prototype.startsWith === undefined) {
    String.prototype.startsWith = function (value) {
        return this.indexOf(value) === 0;
    };
}

if (Array.prototype.find === undefined) {
    Array.prototype.find = function (predicate) {
        if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return value;
            }
        }
        return undefined;
    };
}

function readCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) === ' ') {
            c = c.substring(1, c.length);
        }
        if (c.indexOf(nameEQ) === 0) {
             return c.substring(nameEQ.length, c.length);
        }
    }
    return null;
}

function numberOrdinal(num) {

    var j = num % 10,
        k = num % 100;

    if (j === 1 && k !== 11) {
        return num + "st";
    }
    if (j === 2 && k !== 12) {
        return num + "nd";
    }
    if (j === 3 && k !== 13) {
        return num + "rd";
    }
    return num + "th";
}

function getParameterByName(name, useHash) {
    console.log(location.search);

    name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
        results = regex.exec(useHash ? location.hash : location.search);
    return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
}

function redirectOnReturnUrl(usehash) {

	var returnUrl = getParameterByName('ReturnUrl', usehash) || '';
	if (returnUrl !== '') {
        location.href = returnUrl;
        return true;
    }
    return false;
}

function isNullOrUndefined(obj) {
    return (obj === null || obj === undefined);
}

function iNoU(obj) {
	return isNullOrUndefined(obj);
}

function iEs(s) {
	return s === "";
}

function arrayIndexFind(arr, val, bParseInt) { // alias: getArrayBy...
    if (!isNullOrUndefined(arr)) {
        for (var i = 0; i < arr.length; i++) {
            if (bParseInt) { if (parseInt(arr[i]) === parseInt(val)) { return i; }
            } else { if (arr[i] === val) { return i; } }
        }
    }
    return -1;
}

function arrayIndexByIdOrVal(arr, val, idOrVal) { // alias: getArrayBy...
    if (!isNullOrUndefined(arr)) {
        for (var i = 0; i < arr.length; i++) {
            if (idOrVal && arr[i].id === val) { return i; }
            if (!idOrVal) {
                if (arr[i].value === val) { return i; }
                if (parseInt(arr[i].value) === parseInt(val)) { return i; }
            }
        }
    }
    return -1;
}

function arrayIndexByUaId(arr, val) { // alias: getArrayBy...
    if (!iNoU(arr)) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i].userAccountId === val) { return i; }
        }
    }
    return -1;
}

function arrayIndexByNameOrText(arr, val, nameOrTxt) { // alias: getArrayBy...
    if (!iNoU(arr)) {
        for (var i = 0; i < arr.length; i++) {
            if (nameOrTxt && arr[i].name === val) { return i; }
            if (!nameOrTxt) {
                if (arr[i].text === val) { return i; }
                if (parseInt(arr[i].text) === parseInt(val)) { return i; }
            }
        }
    }
    return -1;
}

function arrayIndexByPropertyName(arr, val, propId) { // was arrayIndexByTypeOrGuid, propId = 0,1,2,3 = type, guid, typeId, underlyingValue
    if (!isNullOrUndefined(arr)) {
        for (var i = 0; i < arr.length; i++) {
            if (propId === 0 && arr[i].type === val) { return i; }
            if (propId === 1 && arr[i].guid === val) { return i; }
            if (propId === 2 && arr[i].typeId === val) { return i; }
            if (propId === 3 && arr[i].underlyingValue === val) { return i; }
        }
    }
    return -1;
}

function getIndexesOf(string, regex) {
	var match,
		indexes = {};
	regex = new RegExp(regex);
	while (match = regex.exec(string)) {
		if (!indexes[match[0]]) { indexes[match[0]] = []; }
		indexes[match[0]].push(match.index);
	}
	return indexes;
}

function momentCal(dt) {
    var m = moment(dt);
    return m.isValid() ? m.calendar() : dt;
};

function momentDateTimeLocale(dt) {
    if (!isNullOrUndefined(dt) && dt !== '') {
        dt = moment(dt, 'LLL').format();
    }
    return dt;
}
function toISO8601(dt, parseFormat) {
    if (!parseFormat)
        parseFormat = 'L';

    if (!isNullOrUndefined(dt) && dt !== '') {
        dt = moment(dt, parseFormat).format();
        dt = dt.substring(0, dt.length - 6);
    }
    return dt;
}
function torusMathRound(number, decimals) { return +(Math.round(number + "e+" + decimals) + "e-" + decimals); }

function scrollTinyMceToTop() {
    if (tinymce != null && tinymce.activeEditor != null) {
        $(tinymce.activeEditor.getBody()).animate({ scrollTop: 0 }, { duration: 'medium', easing: 'swing' });
    }
};

function generateUUID() {
    var d = new Date().getTime();
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
    return uuid;
};

function torusCpyElContentToCb(eId, san) {
	var aux = document.createElement("input");
	var s = document.getElementById(eId).innerHTML;
	aux.setAttribute("value", (san ? torusUnescapeHtml(s) : s));
    document.body.appendChild(aux);
    aux.select();
    document.execCommand("copy");
    document.body.removeChild(aux);
}
function torusCpyElValueToCb(eId, san) {
	var aux = document.createElement("input");
	var s = document.getElementById(eId).value;
	aux.setAttribute("value", (san ? torusUnescapeHtml(s) : s));
	document.body.appendChild(aux);
	aux.select();
	document.execCommand("copy");
	document.body.removeChild(aux);
}

function torusUnescapeHtml(str) {
	return decodeURIComponent(str);
}

function torusEscapeHtml(str) {
	return str
		.replace(/&/g, "&amp;")
		.replace(/</g, "&lt;")
		.replace(/>/g, "&gt;")
		.replace(/"/g, "&quot;")
		.replace(/'/g, "&#039;");
}

function decodeHtml(str) {
    return (isNullOrUndefined(str) || str === '') ? '' : $('<textarea />').html(str).text();
}

function trimAndDecodeHtml(str) {
    return decodeHtml((str || '').trim());
}

function obfuscateValue(value) {
    value = String(value);

    if (value.length > 0) {
        return "•".repeat(value.length);
    } else {
        return value;
    }
}

// Makes an input 'obfuscated'
// This overrides input's value field upon change to '•'.
// To retrieve the actual value, use the obfuscatedValue property.
function makeObfuscated(element, blurOnInput) {
    element.obfuscatedValue = element.value;
    element.value = obfuscateValue(element.obfuscatedValue);

    var $el = $(element);

    $el.on('change', function (ev) {
        this.obfuscatedValue = this.value;
        this.value = obfuscateValue(this.obfuscatedValue);
    });
    
    // When obfuscated, the input loses focus after a short moment 
    // (causes change event to happen, and the actual obfuscation)
    // 
   $el.on('input', function () {
        if (this._blurTimeout) {
            clearInterval(this._blurTimeout);
            this._blurTimeout = null;
        }

        this._blurTimeout =
            setTimeout(function (el) {
                el._blurTimeout = null;
        
                var $el = $(el);

                if ($el.is(':focus')) {
                    $(el).blur();

                    // Focus immediately after one tick (otherwise Angular validation will fail)
                    setTimeout(function (el) {
                        $(el).focus();
                    }, 1, el);
                }
           }, 400, this);

       return false;
    });
}

// Initialise expression editor handler...
// 
(function () {
    var codeflasks = {};
    var nextFlaskId = 0;

    window.getExpressionEditorCodeflask = function(editorId) {
        var $editor = $('.torus-expressioneditor[data-expressioneditor="' + editorId + '"]');

        return codeflasks[$editor.attr('data-flaskId')];
    };

    window.insertParameterIntoExpressionEditor = function (editorId, value) {
        var $editor = $('.torus-expressioneditor[data-expressioneditor="' + editorId + '"]');

        if ($editor.length === 0)
            return;

        var caret = $editor.find('.codeflask__textarea').prop('selectionStart');

        var flask = getExpressionEditorCodeflask(editorId);
        var code = flask.getCode();
        code = code.slice(0, caret) + value + code.slice(caret);
        flask.updateCode(code);
        flask.runUpdate(code);
    };

    function setupExpressionEditor(el) {
        var $el = $(el);

        if ($el.hasClass('flasked'))
            return;

        $el.addClass('flasked');

        var flask = new CodeFlask($el[0], {
            language: $el.attr('data-language') || 'ncalc',
            autoCloseBrackets: false,
            defaultTheme: false
        });

        var $textarea = $el.next();

        flask.$textarea = $textarea;

        flask.$$lineAlignment = function () {
            var $ta = flask.$textarea.prev().find('.codeflask__textarea');

            var lineHeight = parseFloat(getComputedStyle($ta[0], null).lineHeight);
            if (isNaN(lineHeight))
                lineHeight = 1;

            return lineHeight;
        };

        flask.$$scrollTop = function () {
            var $ta = flask.$textarea.prev().find('.codeflask__textarea');

            var scroll = $ta.scrollTop();

            var lineHeight = flask.$$lineAlignment();
            scroll = Math.ceil(scroll / lineHeight) * lineHeight;

            return scroll;
        };

        flask.$$updateScroll = function () {
            if ($(document.body).hasClass('wrap-expreditor-text')) {
                var $ta = flask.$textarea.prev().find('.codeflask__textarea');
               
                var scrollTimeout = $ta.data('timeout');
                if (scrollTimeout) {
                    clearTimeout(scrollTimeout);
                    $ta.data('scrollTimeout', 0);
                }

                var $pre = $ta.next();

                if ($ta[0].offsetHeight < $ta[0].scrollHeight) {
                    $pre.attr('style', 'width: calc(100% - ' + getScrollbarWidth() + 'px) !important;');
                }
                else {
                    $pre.attr('style', '');
                }

                $pre.scrollTop(flask.$$scrollTop());

                var timeout = setTimeout(function (flask_) {
                    var scroll = flask.$$scrollTop();

                    $pre.scrollTop(scroll);
                    $ta.scrollTop($pre.scrollTop());

                    $ta.data('scrollTimeout', 0);
                }, 100, flask);

                $ta.data('scrollTimeout', timeout);
            }
        };

        flask.onUpdate(function (code) {
            if (!flask.initialised)
                return;

            flask.$textarea.val(code);

            angular.element(flask.$textarea[0]).triggerHandler('input');
            angular.element(flask.$textarea[0]).triggerHandler('change');

            var onUpdate = $el.attr('data-onupdate');

            var exprEditId = $el.attr('data-expressioneditor');

            if (onUpdate) {
                var result;

                var _this = window;

                if (window[onUpdate] !== undefined)
                    result = window[onUpdate].call(_this, $el, code, exprEditId);
                else {
                    var fn;

                    var $scope = angular.element($el[0]).scope();

                    while ($scope) {
                        fn = $scope[onUpdate];

                        if (fn) {
                            _this = $scope;
                            break;
                        }

                        $scope = $scope.$parent;
                    }

                    if (!fn)
                        fn = eval(onUpdate);

                    if (typeof fn === 'function')
                        result = fn.call(_this, $el, code, exprEditId);
                    else
                        result = fn;
                }
            }

            flask.$$updateScroll();
        });

        setTimeout(function (flask_) {
            flask_.updateCode(flask_.$textarea.val());
            flask_.initialised = true;

            var $ta = flask_.$textarea.prev().find('.codeflask__textarea');
            $ta.scroll(function () {
                flask_.$$updateScroll();
            });
        }, 1, flask);

        $el.find('.codeflask').addClass('form-control');

        var flaskId = nextFlaskId++;

        $el.attr('data-flaskId', flaskId);

        codeflasks[flaskId] = flask;
    }

    var resizing;

    $(function () {
        // A special way of handling dynamically created expression editors.
        $(document).on('animationstart', '.torus-expressioneditor', function (event) {
            setupExpressionEditor(this);
        });

        // Resizing for expression editors
        $(document).on('mousedown', '.torus-expressioneditor', function (event) {
            if (event.button === 0) {
                var $this = $(this);
                var $flask = $this.find('.codeflask');

                var resize = $this.attr('data-resize');

                var resizeX = resize === 'h' || resize === 'all' || resize === 'true';
                var resizeY = resize === 'v' || resize === 'all' || resize === 'true';

                if (resizeX || resizeY) {
                    var w = $flask.outerWidth();
                    var h = $flask.outerHeight();

                    var x = event.pageX - $this.offset().left;
                    var y = event.pageY - $this.offset().top;

                    // Drag by bottom-left corner...
                    if ((x >= (w - 15)) && (y >= (h - 15))) {
                        resizing = {
                            $flask: $flask,
                            $this: $this,
                            resizeX: resizeX,
                            resizeY: resizeY,
                            x: event.screenX,
                            y: event.screenY,
                            w: $this.width(),
                            h: $this.height(),
                            flask: codeflasks[$this.attr('data-flaskId')]
                        };

                        $flask.css('pointer-events', 'none');

                        event.preventDefault();
                        return false;
                    }
                }
            }
        });

        $(document.body).mouseup(function (event) {
            if (resizing) {

                resizing.$flask.css('pointer-events', 'all');

                setTimeout(function (flask_) {
                    flask_.$$updateScroll();
                }, null, resizing.flask);

                resizing = null;
            }
        });

        $(document.body).mousemove(function (event) {
            if (resizing) {
                var dx = event.screenX - resizing.x;
                var dy = event.screenY - resizing.y;
                var nw = resizing.w + dx;
                var nh = resizing.h + dy;

                var lineAlign = resizing.flask.$$lineAlignment();
                nh = Math.ceil(nh / lineAlign) * lineAlign;

                if (resizing.resizeX) {
                    resizing.$this.css('width', nw + 'px');
                }

                if (resizing.resizeY) {
                    resizing.$this.css('height', nh + 'px');
                }

                setTimeout(function (flask_) {
                    flask_.$$updateScroll();
                }, null, resizing.flask);

                event.preventDefault();

                return false;
            }
        });
    });
})();


function getScrollbarWidth() {
    var outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps

    document.body.appendChild(outer);

    var widthNoScroll = outer.offsetWidth;
    // force scrollbars
    outer.style.overflow = "scroll";

    // add innerdiv
    var inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);

    var widthWithScroll = inner.offsetWidth;

    // remove divs
    outer.parentNode.removeChild(outer);

    return widthNoScroll - widthWithScroll;
}

function formatTimeSpan(totalSeconds, includeMilliseconds)
{
    var pad = function(num, x) {
        return ("0" + num).slice(-x);
    };

    var seconds = Math.floor(totalSeconds);
    var milliseconds = (totalSeconds * 1000.0) - (seconds * 1000);
    var minutes = Math.floor(totalSeconds / 60.0);
    var hours = Math.floor(minutes / 60.0);

    milliseconds %= 1000;
    seconds %= 60;
    minutes %= 60;
    
    return pad(hours, 2) + ':' + pad(minutes, 2) + ':' + pad(seconds, 2) + (includeMilliseconds ? '.' + pad(milliseconds, 3) : '');
}

(function () {
    var __nextSpinnerId = 1;
    var __spinners = [];

	var __spinnersToValidate = {};
    var __validateInterval = setInterval(function () {
        
        for (var id in __spinnersToValidate) {
            validateSpinner(__spinnersToValidate[id], true);
        }
        
    }, 100);

    function toggleSpinner($el, toggle) {
        if (typeof $el === 'string')
            $el = $($el);

        $el.each(function () {
            var $self = $(this);

            var spinnerId = $self.attr('data-spinnerId');
            var $spinner;

            if (isNullOrUndefined(spinnerId)) {
                $(document.body).append('<div class="torus-spinner torus-element-spinner"><div class="bounce1"></div><div class="bounce2"></div><div class="bounce3"></div></div>');
                $spinner = $(document.body).children().last();

                spinnerId = __nextSpinnerId++;
                $self.attr('data-spinnerId', spinnerId);
                $spinner.attr('data-id', spinnerId);
            }
            else {
                $spinner = $('.torus-element-spinner[data-id="' + spinnerId + '"]');
                if ($spinner.length === 0) {
                    $(document.body).append('<div class="torus-spinner torus-element-spinner"><div class="bounce1"></div><div class="bounce2"></div><div class="bounce3"></div></div>');
                    $spinner = $(document.body).children().last();
                    
                    $self.attr('data-spinnerId', spinnerId);
                    $spinner.attr('data-id', spinnerId);

                    $spinner = $('.torus-element-spinner[data-id="' + spinnerId + '"]');
                }
            }

            if (validateSpinner($spinner)) {
                if (toggle) {
                    if (!$self.is(':visible') || $spinner.hasClass('show'))
                        return;

                    $spinner.addClass('show').fadeIn(300);
                }
                else {
                    if (!$spinner.hasClass('show'))
                        return;

                    $spinner.removeClass('show').fadeOut(300);
                }
            }
        });
    }

    function validateSpinner($spinner, dontAdd) {
        var spinnerId = $spinner.attr('data-id');
        var $el = $('[data-spinnerId="' + spinnerId + '"]');

        if ($el.length === 0) {
            $spinner.remove();
            return false;
        }
        else {
            if (!$el.is(':visible')) {
                $spinner.addClass('forceHide');

                if (!dontAdd) {
                    __spinnersToValidate[spinnerId] = $spinner;
                }

                return false;
            } else {
                $spinner.removeClass('forceHide');

                if (__spinnersToValidate[spinnerId]) {
                    delete __spinnersToValidate[spinnerId];
                }

                var offset = $el.offset();
                var w = $el.outerWidth();
                var h = $el.outerHeight();
                $spinner.css({
                    left: offset.left + 'px',
                    top: offset.top + 'px',
                    width: w + 'px',
                    height: h + 'px',
                });
            }
        }

        return true;
    }

    window.addEventListener('resize', function () {
        $('.torus-element-spinner.show').each(function () {
            validateSpinner($(this));
        });
    });

    $.fn.toggleSpinner = function (toggle) {
        toggleSpinner(this, toggle);
    };
})();

function EnableDragging($el, options) {
    if (window.$$dragState === undefined)
        window.$$dragState = null;

    var el = $el[0];

    var self = {
        startDragging: function (event) {
            var offset = $el.offset();

            window.$$dragState = {
                target: el,
                mouseX: event.clientX,
                mouseY: event.clientY,
                startX: parseInt(offset.left),
                startY: parseInt(offset.top),
                mouseXForDelta: event.clientX,
                mouseYForDelta: event.clientY
            };

            if (el.setCapture)
                el.setCapture();

            if (options.onDragStart)
                options.onDragStart($el, window.$$dragState.startY, window.$$dragState.startX, event);
        }
    };

    $el.on('mousedown', function (event) {
        if (window.$$dragState !== null)
            return;

        var el = event.currentTarget;
        var $el = $(el);

        if (event.button === 0) {
            if (options.canStartDrag && options.canStartDrag(event) === false)
                return;

            if (self.startDragging(event) === false)
                return;

            return false;
        }
    });

    $el.on('losecapture', function (event) {
        if (window.$$dragState === null || window.$$dragState.target !== el)
            return;

        window.$$dragState = null;

        if (options.onDragEnd)
            options.onDragEnd($el, event);
    });

    $(document).on('mouseup', function (event) {
        if (window.$$dragState === null || window.$$dragState.target !== el)
            return;

        if (event.button === 0) {
            window.$$dragState = null;

            if (options.onDragEnd)
                options.onDragEnd($el, event);

            return false;
        }
    });

    var dragTarget = el.setCapture ? el : document;

    $(dragTarget).on('mousemove', function (event) {
        if (window.$$dragState === null || window.$$dragState.target !== el)
            return;

        var dx = event.clientX - window.$$dragState.mouseXForDelta;
        var dy = event.clientY - window.$$dragState.mouseYForDelta;

        window.$$dragState.mouseXForDelta = event.clientX;
        window.$$dragState.mouseYForDelta = event.clientY;

        var top = window.$$dragState.startY + (event.clientY - window.$$dragState.mouseY);
        var left = window.$$dragState.startX + (event.clientX - window.$$dragState.mouseX);

        var setOffset = true;

        if (options.onDrag) {
            if (options.onDrag($el, top, left, dx, dy, event) === false)
                setOffset = false;
        }

        if (setOffset) {
            $el.css('top', top + 'px');
            $el.css('left', left + 'px');
        }
    });

    return self;
}

function IEVersion() {
    if (window.navigator.appName === 'Microsoft Internet Explorer') {
        // Check if the user agent has the pattern "MSIE (one or more numbers).(one or more numbers)";
        matches = /MSIE ([0-9]+\.[0-9]+)/.exec(window.navigator.userAgent);
        
        if (matches) {
            return window.parseFloat(matches[1]);
        }
    }

    if (!!window.MSInputMethodContext && !!document.documentMode)
        return 11;

    return null;
}

$(document).on('click', '.btn-wordwrap', function () {
    $(document.body).toggleClass('wrap-expreditor-text');
    return false;
});

function Base64ToUint8Array(base64) {
    var binstr = atob(base64);
    var len = binstr.length;
    var bytes = new Uint8Array(len);
    for (var i = 0; i < len; i++) {
        bytes[i] = binstr.charCodeAt(i);
    }
    return bytes.buffer;
}

function Uint8ArrayToBase64(array) {
    if (Array.isArray(array)) {
        array = Uint8Array.from(array);
    }

    if (array instanceof ArrayBuffer) {
        array = new Uint8Array(array);
    }

    var str = "";
    var len = array.byteLength;

    for (var i = 0; i < len; i++) {
        str += String.fromCharCode(array[i]);
    }
    return window.btoa(str);
}

function Base64UrlDecode(data) {
    data = ('' + data).replace(/-/g, "+").replace(/_/g, "/");
    var str = window.atob(data);
    var bytes = new Uint8Array(str.length);
    for (var i = 0; i < str.length; i++) {
        bytes[i] = str.charCodeAt(i);
    }
    return bytes.buffer;
}

function Base64UrlEncode(data) {
    if (Array.isArray(data))
        data = Uint8Array.from(data);

    if (data instanceof ArrayBuffer)
        data = new Uint8Array(data);
    
    var str = "";
    var len = data.byteLength;

    for (var i = 0; i < len; i++) {
        str += String.fromCharCode(data[i]);
    }

    var result = window.btoa(str);
    result = result.replace(/\+/g, "-").replace(/\//g, "_").replace(/=*$/g, "");

    return result;
}

function makeIdentifierReadable(text) {
    return text
        // insert a space between lower & upper
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        // space before last upper in a sequence followed by lower
        .replace(/\b([A-Z]+)([A-Z])([a-z])/, '$1 $2$3')
        // uppercase the first character
        .replace(/^./, function (str) { return str.toUpperCase(); });
}

function textNodesUnder(el) {
    var n, a = [], walk = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
    while (n = walk.nextNode()) a.push(n);
    return a;
}

function printMissingResources(includeSql) {
    var pattern = /Unknown Resource - [a-zA-Z-_.]+/g;

    var set = {};

    _.forEach(textNodesUnder(document.body), function (e) {
        var text = e.wholeText;

        while ((result = pattern.exec(text)) !== null) {
            set[result[0]] = true;
        }
    });

    var str = '';

    for (var p in set) {
        var t = p.substr('Unknown Resource - '.length);

        if (includeSql)
            t = "EXEC ##sPcR @n = '" + t + "', @v = 'text', @co = NULL";

        str += t + '\n'; 
    }

    console.log(str);
}

function decamelize(str, separator) {
    separator = isNullOrUndefined(separator) ? ' ' : separator;
    return str
        .replace(/([a-z\d])([A-Z])/g, '$1' + separator + '$2')
        .replace(/([A-Z]+)([A-Z][a-z\d]+)/g, '$1' + separator + '$2')
        .toLowerCase();
}

function humanizeString(input, separator) {
    input = decamelize(input, separator);
    input = input.toLowerCase().replace(/[\._-]+/g, ' ').replace(/\s{2,}/g, ' ').trim();
    input = input.charAt(0).toUpperCase() + input.slice(1);
    return input;
};
var angularModules = window.angularModules || {};

var torusApp = angular.module('torus', angularModules.list);

torusApp.value('suppressRequestEvents', { suppress: false });

// Configure the http interceptors
torusApp.config(['$httpProvider', '$angularCacheFactoryProvider', 'uiSelectConfig', 'httpEtagProvider', function ($httpProvider, $angularCacheFactoryProvider, uiSelectConfig, httpEtagProvider) {

    $httpProvider.interceptors.push('torusApiRequestInterceptor');
    $httpProvider.interceptors.push('torusUnauthorisedInterceptor');

    $httpProvider.defaults.headers.common["X-Requested-With"] = 'XMLHttpRequest';

    var antiForgeryToken = $('#apiAntiForgeryToken');
    if (antiForgeryToken !== undefined && antiForgeryToken !== null) {
        $httpProvider.defaults.headers.common.RequestVerificationToken = antiForgeryToken.val();
    }

    $angularCacheFactoryProvider.setCacheDefaults({
        maxAge: settings.browserCacheMaxAge,
        deleteOnExpire: 'aggressive',
        recycleFreq: settings.browserCacheRecycleFrequency
    });

    uiSelectConfig.appendToBody = true;
    uiSelectConfig.theme = 'select2';
    uiSelectConfig.spinnerClass = 'fa fa-refresh fa-spinner';
        
    httpEtagProvider
        .defineCache('localStorage', {
            cacheService:'localStorage'
        });

}]);

torusApp.run(['$templateCache', function ($templateCache) {
    $templateCache.put("bootstrap/match.tpl.html", "<div class=\"ui-select-match\" ng-hide=\"$select.open && $select.searchEnabled\" ng-disabled=\"$select.disabled\" ng-class=\"{\'btn-default-focus\':$select.focus}\"><span tabindex=\"-1\" class=\"btn btn-default form-control ui-select-toggle\" aria-label=\"{{ $select.baseTitle }} activate\" ng-disabled=\"$select.disabled\" ng-click=\"$select.activate()\" style=\"outline: 0;\"><span ng-show=\"$select.isEmpty()\" class=\"ui-select-placeholder text-muted\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"ui-select-match-text pull-left\" ng-class=\"{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}\" ng-transclude=\"\"></span> <i class=\"caret pull-right\" ng-click=\"$select.toggle($event)\"></i> <a ng-show=\"$select.allowClear && !$select.isEmpty() && ($select.disabled !== true)\" aria-label=\"{{ $select.baseTitle }} clear\" style=\"margin-right: 10px\" ng-click=\"$select.clear($event)\" class=\"btn btn-xs btn-link pull-right\"><i class=\"fa fa-remove\" aria-hidden=\"true\"></i></a></span></div>");
    $templateCache.put("select2/select.tpl.html", "<div class=\"ui-select-container select2 select2-container form-control\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled, \'select2-container-active\': $select.focus, \'select2-allowclear\': $select.allowClear && !$select.isEmpty()}\"><div class=\"ui-select-match\"></div><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open}\"><div class=\"search-container\" ng-class=\"{\'ui-select-search-hidden\':!$select.searchEnabled, \'select2-search\':$select.searchEnabled}\"><input type=\"search\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" ng-class=\"{\'select2-active\': $select.refreshing}\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" class=\"ui-select-search select2-input\" ng-model=\"$select.search\"></div><div class=\"ui-select-choices\"></div><div class=\"ui-select-no-choice\"></div></div></div>");
}]);

//TODO : this is left as an example of a testable controller but it
//cant be tested because it needs to be in its own file as all the code
//above it has missing dependencies that the test runner doesn't know how to
//run :-<
var jasmineApp = angular.module('jasmineApp', []);
jasmineApp.controller('jasmineAppController', function ($scope) {

    $scope.name = 'eric';

});

torusApp.run(['$rootScope', function ($rootScope) {
    $rootScope.useCarousel = $(document).width() >= 766;

    console.log("Torus Server/Version: " + version.currentVersion);

    $rootScope.carouselOptions = {
        items: 1,
        nav: true
    };
}]);

// Invalidate etags on new user
torusApp.run(['torusCache', function (torusCache) {

    let currentUserId = currentUser.id;
    let etagCacheId = torusCache.get('etag_id');

    if (currentUserId !== etagCacheId) {

        var etagKeys = [];

        for (let i = 0, len = localStorage.length; i < len; ++i) {
            let key = localStorage.key(i);
            if (key.startsWith('localStorage:/api')) {
                etagKeys.push(key);
            }
        }

        for (let i = 0; i < etagKeys.length; ++i) {
            localStorage.removeItem(etagKeys[i]);
        }

        torusCache.set('etag_id', currentUser.id);
    }
    
}]);
;
var torusControllers = angular.module('torus.controllers', ['torus.factories']);

torusControllers.controller('FooterCtrl', ['$scope', '$location', '$anchorScroll',function ($scope, $location, $anchorScroll) {
    $scope.gotoTop = function (location) {

		// set the location.hash to the id of
		// the element you wish to scroll to.
		$location.hash(location || 'wrap');
		// call $anchorScroll()
		$anchorScroll();
	};
}]);

torusControllers.controller('ConfidentialityController', ['$rootScope', '$scope', '$timeout', 'torusSetSensitiveValuesDisplayCookie', function ($rootScope, $scope, $timeout, torusSetSensitiveValuesDisplayCookie) {

    $scope.loadConfidentialityCtrlComplete = false;

    $scope.confidentialityOverlayVisibility = false; // controls use of confidential overlay

	$scope.closeConfidentialityOverlay = function () {
		$timeout(function () { $scope.confidentialityOverlayVisibility = false; }, 1);
	};

	$scope.openConfidentialityOverlay = function () {
		$timeout(function () { $scope.confidentialityOverlayVisibility = true; }, 1);
	};

	$scope.switchConfidentialityOverlay = function (state) {
		$timeout(function () { $scope.confidentialityOverlayVisibility = state; }, 1);
	};

    $scope.$on("openConfidentialityOverlay", function () {
        if (!$scope.confidentialityOverlayVisibility) {
            $timeout(function () { $scope.confidentialityOverlayVisibility = true; }, 1);
        }
	});

	$scope.sensitiveValuesShowHide = !isNullOrUndefined(confidentialityData) ? confidentialityData.defaultStateHideShowSensitive : true; // controls use of confidential overlay

	$scope.switchSensitiveValuesShowHide = function (state) {
		$timeout(function () {
			torusSetSensitiveValuesDisplayCookie.setSensitiveValuesDisplay('SensistiveValuesHideShowDisplay', state, 180);
			$scope.sensitiveValuesShowHide = state;
			$rootScope.$broadcast('switchSensitiveValuesShowHide', { state: state });
		}, 1);
	};

    $scope.loadConfidentialityCtrlComplete = true;

}]);

torusControllers.controller('OffsiteLinkDisclaimerController', ['$scope', '$timeout', function ($scope, $timeout) {

    $scope.offsiteLink = "";
    $scope.offsiteLinkDisclaimerOverlayVisibility = false; // controls use of offsite dislaimer

	$scope.closeOffsiteLinkDisclaimerOverlay = function () {
		$timeout(function () { $scope.offsiteLinkDisclaimerOverlayVisibility = false; }, 1);
	};

    $scope.$on("openOffsiteLinkDisclaimerOverlay", function (event, args) {
        if (!$scope.offsiteLinkDisclaimerOverlayVisibility) {
            $timeout(function () {
                $scope.offsiteLink = args.href;
                $scope.target = args.target;
                $scope.offsiteLinkDisclaimerOverlayVisibility = true;
            }, 1);
        }
    });

	$scope.navOffsiteLinkDisclaimerOverlay = function () {
		if (!isNullOrUndefined($scope.offsiteLink) && $scope.offsiteLink !== '') {
			$scope.closeOffsiteLinkDisclaimerOverlay();
			if (!isNullOrUndefined($scope.target) && $scope.target !== '') {
				window.open($scope.offsiteLink, $scope.target);
				return false;
			}
			window.location = $scope.offsiteLink;
		}
	};

}]);

torusControllers.controller('AcceptCookiesEuController', ['$scope', 'torusAcceptCookiesEu', function ($scope, torusAcceptCookiesEu) {
    // button/actions
    $scope.acceptCookiesClick = function () {
        torusAcceptCookiesEu.acceptCookies('AcceptedCookies', 180);
    };
}]);

torusControllers.controller('VersionUpdateController', ['$scope', 'torusVersionUpdateCookie', function ($scope, torusVersionUpdateCookie) {
    // bind
	$scope.bindMsgLink = function () {
		if (!isNullOrUndefined(resourcesVU.mainMessage) && !isNullOrUndefined(resourcesVU.verLink)) {
			return String.format(resourcesVU.mainMessage, resourcesVU.verLink);
		}
		return "";
	};
    // button/actions
    $scope.acceptVersionUpdateClick = function () {
        torusVersionUpdateCookie.acceptVersionUpdate('AcceptedVersionUpdate', resourcesVU.verNumber, 180);
    };
}]);

torusControllers.controller('PrivacyPolicyController', ['$scope', 'torusPrivacyPolicyCookie', function ($scope, torusPrivacyPolicyCookie) {
    // button/actions
    $scope.acceptPolicyClick = function () {
        torusPrivacyPolicyCookie.acceptPolicy('PrivacyPolicy', policyAcceptance.verNumber, 180);
    };
}]);


torusControllers.controller('AdminKbsArticleOverlayController', ['$scope', '$rootScope', '$timeout', 'torusNavBarService', function ($scope, $rootScope, $timeout, torusNavBarService) {

    $rootScope.torusScreenDimmer = false;
    $scope.adminKbsArticleOverlayVisibility = false; // controls use of article overlay
    $scope.adminKbsArticleLoading = true; // controls use of spinner while fetching content

	$scope.closeAdminKbsArticleOverlay = function () {
		$timeout(function () {
			$scope.adminKbsArticleOverlayVisibility = false;
			$timeout(function () {
				$rootScope.torusScreenDimmer = false;
			}, 5000);
		}, 5);
	};

    $scope.$on("closeAdminKbsArticleOverlay", function () {
        if ($scope.adminKbsArticleOverlayVisibility) {
            $timeout(function () {
                $rootScope.torusScreenDimmer = $scope.adminKbsArticleOverlayVisibility = false;
            }, 1);
        }
    });

    $scope.$on("openAdminKbsArticleOverlay", function (event, args) {
        if (!$scope.adminKbsArticleOverlayVisibility) {
            $timeout(function () {
                $rootScope.torusScreenDimmer = $scope.adminKbsArticleOverlayVisibility = true;
                torusNavBarService.getKbsArticleForOverlay(args.ref).then(function (articleData) {
                    $scope.adminKbsArticleTitle = articleData.title;
                    $scope.adminKbsArticleContent = articleData.content;
                    $scope.adminKbsArticleOpenPath = args.ref;
                    $scope.adminKbsArticleLoading = false;
                });
            }, 10);
        }
    });

}]);

torusControllers.controller('TitleController', ['$scope', function ($scope) {

    var pageTitle = window.pageTitle || {};

    $scope.title = pageTitle.title;
    $scope.subTitle = pageTitle.subTitle;
    $scope.showTitle = true;
    $scope.titleEnabled = true;
    $scope.subTitleEnabled = true;
    
    $scope.$on('enablePageTitle', function (event, enabled) {
        $scope.titleEnabled = enabled;
    });

    $scope.$on('enablePageSubTitle', function (event, enabled) {
        $scope.subTitleEnabled = enabled;
    });

    $scope.$on('changePageTitle', function (event, title) {
        $scope.title = title;
    });

    $scope.$on('changePageSubTitle', function (event, subTitle) {
        $scope.subTitle = subTitle;
    });

    $scope.$on('showPageTitle', function () {
        $scope.showTitle = true;
    });

    $scope.$on('hidePageTitle', function () {
        $scope.showTitle = false;
    });

    $scope.shouldShowTitle = function () {
        return $scope.showTitle && (
              ($scope.titleEnabled && !isNullOrUndefined($scope.title) && $scope.title !== ''));
    };

    $scope.shouldShowSubTitle = function () {
        return $scope.showTitle && (
              ($scope.subTitleEnabled && !isNullOrUndefined($scope.subTitle) && $scope.subTitle !== ''));
    };

    $scope.shouldShowTitleOrSubTitle = function () {
        return $scope.shouldShowTitle() || $scope.shouldShowSubTitle();
    };

    $scope.setTitles = function (title, subTitle) {
        $scope.title = title;
        $scope.subTitle = subTitle;
    };

}]);

torusControllers.controller('BookmarkController', ['$scope', 'torusBookmarkService', function ($scope, torusBookmarkService) {

	$scope.usrBookmark = null;

    $scope.bindBookmarkLinkText = function () {
		if (!isNullOrUndefined($scope.usrBookmark)) {
            var strHtml = "<span title='{0}'><i class='{1}'></i> {2}</span>";
            var strTitle = $scope.usrBookmark.id === 0 ? String.format(resourcesUBM.textBookmarkThisPageTitle, "\"/" + pageDataUBM.safeUrl.replace('_', '/') + "\"") : String.format(resourcesUBM.textRemoveBookmarkTitle, "\"/" + pageDataUBM.safeUrl.replace('_', '/') + "\"");
            return $scope.usrBookmark.id === 0 ?
                String.format(strHtml, strTitle, "fa fa-star-o", resourcesUBM.textBookmarkThisPage) : String.format(strHtml, strTitle, "fa fa-star", resourcesUBM.textRemoveBookmark);
        }
        return "";
    };

    $scope.setBookmarkState = function () {
        if (isNullOrUndefined($scope.usrBookmark.title)) { $scope.usrBookmark.title = pageDataUBM.pageTitle; } // ensure page title is in...
        torusBookmarkService.setUserBookmarkStatus($scope.usrBookmark).then(function (data) {
            if (!isNullOrUndefined(data)) {
                loadBookmarkData();
            }
        });
    };

	var loadBookmarkData = function () {
		torusBookmarkService.getUserBookmarkStatus(currentUser.id, pageDataUBM.safeUrl).then(function (bookmarkDetails) {
			if (!isNullOrUndefined(bookmarkDetails)) {
				$scope.usrBookmark = bookmarkDetails;
			}
		});
	};

    loadBookmarkData();

}]);

torusControllers.controller('ClientMenuController', ['$scope', '$filter', 'torusMenuService', 'torusNavBarService', 'torusPageTitleService', function ($scope, $filter, torusMenuService, torusNavBarService, torusPageTitleService) {

    var activeMenuItem = window.activeMenuItem || {};

    var menu = [];

    $scope.menuItems = [];

    $scope.activeMenuItemId = activeMenuItem.id;

    $scope.menuLoadComplete = false;

    $scope.pageBusy = false;

    $scope.breadcrumbs = [];

    $scope.landingPageItem = {};

    $scope.landingPageMenuId = '';

	$scope.avatarImageFile = '';

    $scope.unopenedMsgCount = 0;

    $scope.topNavBarItems = window.topNavBarItems; //bs3 specific

    $scope.getMenuItemId = function (i) {
        return 'menuItem_' + i.title.replace(/\s/g, '_');
    };

	$scope.bindUnreadMsgCount = function () {
		if ($scope.unopenedMsgCount > 0) {
			return String.format(settingsMenu.clientMenuLabelFormat, $scope.unopenedMsgCount);
		}
		return "";
	};

	torusMenuService.getClientMenu().then(function (data) {
        menu = data;
        var selectedMenuGroupId = 0;

        for (var i = 0; i < menu.menuItems.length; i++) {
            if (hasActiveItem(menu.menuItems[i].menuSubItems)) {
                selectedMenuGroupId = i;
                break;
            }
        }

        if (menu.menuItems.length > 0) {
            $scope.menuItems = menu.menuItems[selectedMenuGroupId].menuSubItems;

            setBreadcrumbs($scope.menuItems);
            if ($scope.breadcrumbs.length > 0) {
                $scope.breadcrumbs = $scope.breadcrumbs.slice().reverse();
            }

            if ($scope.landingPageMenuId !== '') {
                var item = $filter('filter')($scope.menuItems, { name: $scope.landingPageMenuId });
                if (item.length > 0) {
                    $scope.landingPageItem = item[0];
                    torusPageTitleService.changeTitle($scope.menuText(item[0]));
                }
            }
		}

        if (settings.clientMessagingEnabled) { // no need to fire API call if not enabled
            if (!isNullOrUndefined(currentUser.id)) { // tenant ID always populated, user only after login made
			    torusMenuService.getClientMenuUserMsgOpenCount(currentUser.tenantId, currentUser.id).then(function (msgCount) {
				    $scope.unopenedMsgCount = msgCount;
				    $scope.menuLoadComplete = true;
			    }, function () {
				    $scope.menuLoadComplete = true;
			    });
            }
		}
		else {
			$scope.menuLoadComplete = true;
		}

    });

    // watch/reloads
	$scope.$on('reloadclientavatar', function () {
		loadAvatar();
	});

    // avatar
    $scope.bindAvatar = function (fg) {
        if (!isNullOrUndefined(fg) || fg !== '') {
            return '/file/' + fg;
        }
        return "";
    };

	var loadAvatar = function () {
		if (isNullOrUndefined(currentUser) || isNullOrUndefined(currentUser.id)) {
			return;
		}
		torusNavBarService.getAvatar(currentUser.id).then(function (aG) {
			if (!isNullOrUndefined(aG)) { $scope.avatarImageFile = aG.replace(/\"/g, ""); }
		});
	};

    var setBreadcrumbs = function (items) {

        if ($scope.activeMenuItemId === '') {
            return false;
        }

        for (var i = 0; i < items.length; i++) {
            var hasActiveItems = false;
            if (items[i].menuSubItems.length > 0) {
                hasActiveItems = setBreadcrumbs(items[i].menuSubItems);
            }

            if ($scope.activeMenuItemId === items[i].name || hasActiveItems) {
                $scope.breadcrumbs.push({ title: $scope.menuText(items[i]), url: items[i].url === null || items[i].url === undefined ? '' : items[i].url });
                return true;
            }
        }

        return false;
    };

    $scope.setLandingPageMenuId = function (menuItemId) {
        $scope.landingPageMenuId = menuItemId;
    };

	$scope.menuActiveClass = function (href, exactMatchOnly) {
		if (!isNullOrUndefined(href)) {
			var jsp = href.substring(0, 1) !== "/" ? window.location.href : window.location.pathname;
			if (jsp === href) { return true; } // return true if match with current
			if (exactMatchOnly) { return false; } // if only interested in total matches, exit now...
			var hArr = href.split("/"); // module page section detect, split target href...
			var wlpArr = window.location.pathname.split("/"); // module page section detect, split mvc path on slashes...
			if (hArr.length > 1 && wlpArr.length > 1) { // [0]/[1]/[n]...
				if (hArr.length <= wlpArr.length && hArr[1] === wlpArr[1]) { return true; } // same level (or lower), same module...
			}
		}
		return false;
	};

    $scope.menuGroupClick = function (menuGroupName) {
        var menuGroup = $filter('filter')(menu.menuItems, { name: menuGroupName })[0];
        $scope.menuItems = menuGroup.menuSubItems;
    };

    $scope.menuItemUrl = function (menuItem) {
        if (menuItem.menuSubItems.length > 0)
            return null;
        return menuItem.url;
    };

    $scope.menuItemClick = function (menuItem) {
        if (menuItem.menuSubItems.length > 0)
            return;
        $scope.breadCrumbClick(menuItem);
    };

    $scope.breadCrumbClick = function (menuItem) {
        if ($scope.pageBusy)
            return;
        $scope.pageBusy = true;

        if (menuItem.url !== null && menuItem.url !== undefined && menuItem.url !== '') {
            if (!menuItem.externalUrl) {
                window.location = menuItem.url;
            } else {
                window.open(menuItem.url);
            }
        }
        $scope.pageBusy = false;
    };

    $scope.getIconClass = function (item) {
        return item.iconImage; // class is "iconImage" now, should only access this function if type=0 for webicon
    };

    $scope.getActiveClass = function (item) {

        if ($scope.activeMenuItemId === '') {
            return '';
        }
		if (!isNullOrUndefined($scope.activeMenuItemId) && !isNullOrUndefined(item.name)) {
			if ($scope.activeMenuItemId.toLowerCase() === item.name.toLowerCase()) {
				return 'active';
			}
		}
		if (!isNullOrUndefined($scope.activeMenuItemId) && !isNullOrUndefined(item.title)) {
			if ($scope.activeMenuItemId.toLowerCase() === item.title.toLowerCase()) {
				return 'active';
			}
		}
		if (!isNullOrUndefined($scope.activeMenuItemId) && !isNullOrUndefined(item.url)) {
			if ("/" + $scope.activeMenuItemId.toLowerCase() === item.url.toLowerCase()) {
				return 'active';
			}
		}
        if (hasActiveItem(item.menuSubItems)) {
            return 'active open';
        }
        return '';
    };

    $scope.getActiveClientClass = function (selMenuRef, selMenuExact, menuUrl) {
        if (!isNullOrUndefined(selMenuRef) && !isNullOrUndefined(menuUrl)) {
            if (selMenuRef != "" && menuUrl != "" && menuUrl != "/") {
                if (selMenuExact && selMenuRef == menuUrl) { return "active"; }
                if (!selMenuExact && menuUrl.indexOf(selMenuRef) == 0) { return "active"; }
            }
        }
        return "";
    };

    $scope.menuText = function (item, useDescription) {
		if (isNullOrUndefined(item)) {
            return '';
        }
		if (item.menuContext === 1 && !isNullOrUndefined(session.selectedTenant) && item.name === 'SelectedTenant') {
            return session.selectedTenant.name;
        }
		if (item.menuContext === 2 && !isNullOrUndefined(session.selectedUser)) {
            return session.selectedUser.username;
        }
        return useDescription ? item.description : item.title;
    };

    $scope.menuImgSrc = function (item) {
        if (!isNullOrUndefined(item)) {
            return "/file/" + item.iconImage;
        }
        return "";
    };

    $scope.menuClassName = function (item, cLong, cShort) {
        if (item !== undefined && item !== null) {
            var mt = $scope.menuText(item, false);
            var total = $scope.menuItems.length;
            switch (total) {
                case 1: case 2: case 3: 
                    return cLong;
                case 4:
                    return mt.length <= 25 ? cShort : cLong; 
                case 5:
                    return mt.length <= 14 ? cShort : cLong;
                default: // 6+
                    return cShort;
            }
        }
        if (!isNullOrUndefined(cShort)) { return cShort; } // return long class if there but no item...
        return "";
    };

    $scope.showMenuGroup = function (menuGroupName) {

        if (menu.menuItems === undefined || menu.menuItems === null) {
            return false;
        }
        var menuGroup = $filter('filter')(menu.menuItems, { name: menuGroupName })[0];
		if (isNullOrUndefined(menuGroup)) {
            return false;
        }
        return menuGroup.menuSubItems.length > 0;
    };

    var hasActiveItem = function (items) {

        if ($scope.activeMenuItemId === '' || items.length === 0) {
            return false;
        }
        var activeItems = $filter('filter')(items, { name: $scope.activeMenuItemId });
        if (activeItems.length > 0) {
            return true;
        } else {
            for (var i = 0; i < items.length; i++) {
                if (hasActiveItem(items[i].menuSubItems)) {
                    return true;
                }
            }
        }
        return false;
    };

    loadAvatar();

}]);

torusControllers.controller('AdminMenuController', ['$scope', '$filter', 'torusMenuService', 'torusPageTitleService', '$timeout', function ($scope, $filter, torusMenuService, torusPageTitleService, $timeout) {

    var activeMenuItem = window.activeMenuItem || {};

    var menu = [];

    $scope.menuItems = [];

    $scope.activeMenuItemId = activeMenuItem.id;

    $scope.menuLoadComplete = false;

    $scope.pageBusy = false;

    $scope.landingPageItem = {};

    $scope.landingPageMenuId = '';

    torusMenuService.getAdminMenu().then(function (data) {
        menu = data;

        var selectedMenuGroupId = 0;

		if (!isNullOrUndefined(menu.menuItems)) {

            if (menu.menuItems.length > 0) {

                for (var i = 0; i < menu.menuItems.length; i++) {
                    if (hasActiveItem(menu.menuItems[i].menuSubItems)) {
                        selectedMenuGroupId = i;
                        $scope.activeMenuGroup = menu.menuItems[i].name;
                        break;
                    }
                }

                if ($scope.activeMenuGroup === '')
                    $scope.menuItems = [];
                else
                    $scope.menuItems = menu.menuItems[selectedMenuGroupId].menuSubItems;

                if ($scope.landingPageMenuId !== '') {
                    var item = $filter('filter')($scope.menuItems, { name: $scope.landingPageMenuId });
                    if (item.length > 0) {
                        $scope.landingPageItem = item[0];
                        torusPageTitleService.changeTitle($scope.menuText(item[0]));
                    }
                }
            }

        }

        $scope.menuLoadComplete = true;
    });

	$scope.setLandingPageMenuId = function (menuItemId) {
		$scope.landingPageMenuId = menuItemId;
	};

    $scope.activeMenuGroup = 'PlatformManager';

    $scope.menuGroupClick = function (menuGroupName) {
        if ($scope.activeMenuGroup !== menuGroupName) {
            var element = "div#sidebar-shortcuts-mini button";
            $(element).removeClass('ng-hide').addClass('ng-hide');
            $scope.activeMenuGroup = menuGroupName;
            var menuGroup = $filter('filter')(menu.menuItems, { name: menuGroupName })[0];
            $scope.menuItems = menuGroup.menuSubItems;
        }
    };

    $scope.menuItemUrl = function (menuItem) {
        if (menuItem.menuSubItems.length > 0)
            return null;

        return menuItem.url;
    };
    
    $scope.getIconClass = function (item) {
        if (item.menuContext === 1 && isNullOrUndefined(session.selectedUser) && item.name === 'TenantSelectedTenantUser') {
            return '';
        }
        return item.iconImage; // class is "iconImage" now, should only access this function if type=0 for webicon
    };

    $scope.getActiveClass = function (item) {

		if (item.menuContext === 1 && isNullOrUndefined(session.selectedTenant)) {
            return 'ng-hide';
        }
		if (item.menuContext === 2 && isNullOrUndefined(session.selectedUser)) {
            return 'ng-hide';
        }
        if ($scope.activeMenuItemId === '') {
            return '';
        }
        if ($scope.activeMenuItemId === item.name) {
            return 'active';
        }
        if (hasActiveItem(item.menuSubItems)) {
            return 'active open';
        }
        return '';
    };

    $scope.menuText = function (item, useDescription) {

        if (item === undefined || item === null) {
            return '';
        }
		if (!isNullOrUndefined(session.selectedUser) && (item.name ==='PlatformSelectedTenantUser' || item.name === 'TenantSelectedTenantUser' || item.name ==='UserSelectedTenantUser')) {
			return isNullOrUndefined(session.selectedUser.surname) ? '[' + session.selectedUser.username + ']' : String.format("{0} {1}", session.selectedUser.forenames, session.selectedUser.surname);
        }
		if (!isNullOrUndefined(session.selectedTenant) && (item.name === 'PlatformSelectedTenant' || item.name === 'SelectedTenant' || item.name === 'UserSelectedTenant')) {
            return session.selectedTenant.name;
        }
        return useDescription ? item.description : item.title;
    };

    $scope.menuImgSrc = function (item) {
        if (!isNullOrUndefined(item)) {
            return "/file/" + item.iconImage;
        }
        return "";
    };

    $scope.showMenuGroup = function (menuGroupName) {

        if (menu.menuItems === undefined || menu.menuItems === null) {
            return false;
        }
        var menuGroup = $filter('filter')(menu.menuItems, { name: menuGroupName })[0];
		if (isNullOrUndefined(menuGroup)) {
            return false;
        }
        return menuGroup.menuSubItems.length > 0;
    };

	$scope.showMenuGroups = function () {

		if (isNullOrUndefined(menu) || isNullOrUndefined(menu.menuItems)) {
			return false;
		}
		return menu.menuItems.length > 1;
	};

    var hasActiveItem = function (items) {

        if ($scope.activeMenuItemId === '' || items.length === 0) {
            return false;
        }
        var activeItems = $filter('filter')(items, filterMenu);
        if (activeItems.length > 0) {
            return true;
        } else {
            for (var i = 0; i < items.length; i++) {
                if (hasActiveItem(items[i].menuSubItems)) {
                    return true;
                }
            }
        }
		return false;
    };

    $scope.navigateToPlatformDashboard = function () {
        window.location.href = '/dashboard/platform';
    };

	var filterMenu = function (menuItem) {
		return menuItem.name === $scope.activeMenuItemId;
	};

}]);

torusControllers.controller('AdminTenantsNavController', ['$scope', '$http', '$sanitize', 'torusOData', function ($scope, $http, $sanitize, torusOData) {

    $scope.loading = false;

}]);

torusControllers.controller('AdminNavBarController', ['$scope', '$rootScope', '$animate', '$timeout', 'torusNavBarService', 'gritterService', '$http', '$sanitize', 'torusOData', function ($scope, $rootScope, $animate, $timeout, torusNavBarService, gritterService, $http, $sanitize, torusOData) {
    
    // initialise the notification data - alerts; notifications, tasks and unread messages
    $scope.alerts = [];
    $scope.alerts.notifications = [];
    $scope.alerts.notifications.hasOutstandingNotifications = false;
    $scope.alerts.notifications.alternateDisplay = false;
    $scope.alerts.notifications.outstandingCount = 0;

    $scope.alerts.tasks = [];
    $scope.alerts.tasks.hasTasks = false;
    $scope.alerts.tasks.tasksCount = 0;

    $scope.alerts.messaging = [];
    $scope.alerts.messaging.hasNewMessages = false;
    $scope.alerts.messaging.newMessagesCount = 0;

    $scope.alerts.changeNotes = {};
    $scope.alerts.changeNotes.contextId = 0;
    $scope.alerts.changeNotes.jsRefId = -1;
    $scope.alerts.changeNotes.loading = true;
    $scope.alerts.changeNotes.adding = false;
    $scope.alerts.changeNotes.loadCount = settingsChangeNotes.changeNotesLoadNumber; // no page section if no permission for change notes...
    $scope.alerts.changeNotes.skip = 0;
    $scope.alerts.changeNotes.count = 0;
    $scope.alerts.changeNotes.show = false;
    $scope.alerts.changeNotes.newNoteText = '';
    $scope.alerts.changeNotes.notes = [];

    $scope.alerts.adminDownloads = {};
    $scope.alerts.adminDownloads.platformReportDownloadCount = 0;
    $scope.alerts.adminDownloads.platformReportDownloadNewCount = 0;
    $scope.alerts.adminDownloads.tenantReportDownloadCount = 0;
    $scope.alerts.adminDownloads.tenantReportDownloadNewCount = 0;
    $scope.alerts.adminDownloads.platformDataDownloadCount = 0;
    $scope.alerts.adminDownloads.platformDataDownloadNewCount = 0;
    $scope.alerts.adminDownloads.tenantDataDownloadCount = 0;
    $scope.alerts.adminDownloads.tenantDataDownloadNewCount = 0;
    $scope.alerts.adminDownloads.downloadsCount = 0;
    $scope.alerts.adminDownloads.downloadsNewCount = 0;
    $scope.alerts.adminDownloads.newDownloadsCount = 0;
    $scope.alerts.adminDownloads.hasNewDownloads = false;
    $scope.alerts.adminDownloads.initialTab = 'platformreports';
    $scope.avatarImageFile = {};

    var ctId = !isNullOrUndefined(session.selectedTenant) ? session.selectedTenant.id : 0;
	var ctuId = !isNullOrUndefined(session.selectedUser) ? session.selectedUser.id : 0;

    // watch/reloads
    $scope.$on('reloadadminavatar', function () {
        loadAvatar();
    });
    $scope.$on('reloadchangenotes', function (event, refId) {
        var cn = $scope.alerts.changeNotes;
        cn.loading = true;
        cn.jsRefId = parseInt(refId);
        $timeout(function () {
            refreshChangeNotesCount(); loadChangeNotes(cn.loadCount, cn.skip);
        }, 500);
    });

    // notifications
    $scope.refreshNotificationCount = function () {
        torusNavBarService.notificationCount().then(function (notificationCount) {
            var scp = $scope.alerts.notifications;
            scp.outstandingCount = parseInt(notificationCount);
            scp.alternateDisplay = !scp.alternateDisplay;
            scp.hasOutstandingNotifications = scp.outstandingCount > 0;
        });
    };
    $scope.addToNotificationCount = function () {
        var scp = $scope.alerts.notifications;
        scp.outstandingCount = scp.outstandingCount + 1;
        scp.alternateDisplay = !scp.alternateDisplay;
        scp.hasOutstandingNotifications = true;
    };
    $scope.removeFromNotificationCount = function () {
        var scp = $scope.alerts.notifications;
        scp.outstandingCount = scp.outstandingCount - 1;
        scp.hasOutstandingNotifications = scp.outstandingCount > 0;
        if (scp.hasOutstandingNotifications < 0) {
            scp.hasOutstandingNotifications = 0;
        }
        //scp.alternateDisplay = !scp.alternateDisplay; // won't display the ringer if the count decreases
    };

    // tasks
    $scope.addToTaskCount = function (taskCount) {
        $scope.alerts.tasks.tasksCount = $scope.alerts.tasks.tasksCount + parseInt(taskCount);
        $scope.alerts.tasks.hasTasks = $scope.alerts.tasks.tasksCount > 0;
    };
    $scope.removeFromTaskCount = function (taskCount) {
        $scope.alerts.tasks.tasksCount = $scope.alerts.tasks.tasksCount - parseInt(taskCount);
        $scope.alerts.tasks.hasTasks = $scope.alerts.tasks.tasksCount > 0;
    };
    $scope.refreshTaskCount = function () {
        torusNavBarService.taskCount().then(function (taskCount) {
            $scope.alerts.tasks.tasksCount = parseInt(taskCount);
            $scope.alerts.tasks.hasTasks = $scope.alerts.tasks.tasksCount > 0;
        });
    };

    // messaging
    $scope.refreshMessagingUnreadCount = function () {
        torusNavBarService.adminMessagingMessageCount(currentUser.id, true).then(function (messageCountUnassigned) {
            torusNavBarService.adminMessagingMessageCount(currentUser.id, false).then(function (messageCountForAdmin) {
                var scp = $scope.alerts.messaging;
                scp.messageCount = parseInt(messageCountUnassigned) + parseInt(messageCountForAdmin);
                scp.messageCountUnassigned = parseInt(messageCountUnassigned);
                scp.messageCountForAdmin = parseInt(messageCountForAdmin);
                scp.hasNewMessages = scp.messageCount > 0;
            });
        });
    };

    // admin downloads...
    $scope.setInitialTab = function (downloadSummary) {
        if (parseInt(downloadSummary.tenantReportDownloadCount) > 0) { return "tenantreports"; }
        if (parseInt(downloadSummary.platformDataDownloadCount) > 0) { return "platformdatatransferdownloads"; }
        if (parseInt(downloadSummary.tenantDataDownloadCount) > 0) { return "tenantdatatransferdownloads"; }
        return "platformreports";
    };

    $scope.refreshAdminDownloadsCount = function () {
        torusNavBarService.adminDownloadsCount(currentUser.id, true).then(function (downloadSummary) {
            var scp = $scope.alerts.adminDownloads;
            scp.platformReportDownloadCount = parseInt(downloadSummary.platformReportDownloadCount);
            scp.platformReportDownloadNewCount = parseInt(downloadSummary.platformReportDownloadNewCount);
            scp.tenantReportDownloadCount = parseInt(downloadSummary.tenantReportDownloadCount);
            scp.tenantReportDownloadNewCount = parseInt(downloadSummary.tenantReportDownloadNewCount);
            scp.platformDataDownloadCount = parseInt(downloadSummary.platformDataDownloadCount);
            scp.platformDataDownloadNewCount = parseInt(downloadSummary.platformDataDownloadNewCount);
            scp.tenantDataDownloadCount = parseInt(downloadSummary.tenantDataDownloadCount);
            scp.tenantDataDownloadNewCount = parseInt(downloadSummary.tenantDataDownloadNewCount);
            scp.downloadsCount = scp.platformReportDownloadCount + scp.tenantReportDownloadCount + scp.platformDataDownloadCount + scp.tenantDataDownloadCount;
            scp.downloadsNewCount = scp.platformReportDownloadNewCount + scp.tenantReportDownloadNewCount + scp.platformDataDownloadNewCount + scp.tenantDataDownloadNewCount;
            scp.hasNewDownloads = scp.downloadsNewCount > 0;
            scp.initialTab = $scope.setInitialTab(downloadSummary);
        });
    };

    // avatar
    $scope.bindAvatar = function (fg) {
        if (!isNullOrUndefined(fg) || fg !== '') {
            return '/file/' + fg;
        }
        return "";
    };

    var loadAvatar = function () {
        torusNavBarService.getAvatar(currentUser.id).then(function (aG) {
            if (aG !== null) { $scope.avatarImageFile = aG.replace(/\"/g, ""); }
        });
    };

    // changeNotes
	var cnJsRefResolve = function () { // used to determine aJS tier granularity, should this grow, maybe move to back end service lookup?
		var h = window.location.hash;
		switch (window.location.pathname) {
			case "/tenant/benefits":
				if (h.indexOf("#/edit/") > -1) { return parseInt(h.replace("#/edit/", "")); } break;
			case "/tenant/task-list-management/policy-templates":
				if (h.indexOf("#/manage/") > -1) { return parseInt(h.replace("#/manage/", "")); } break;
			default:
				return 0;
		}
		return 0;
	};
    var refreshChangeNotesCount = function () {
        var jsRef = $scope.alerts.changeNotes.jsRefId > -1 ? $scope.alerts.changeNotes.jsRefId : cnJsRefResolve(); // default if not already set
        torusNavBarService.adminChangeNotesCount(currentUser.id, ctId, ctuId, jsRef, window.location.pathname, settingsAdmin.changeNotesMvcContextId).then(function (changeNoteCount) {
            $scope.alerts.changeNotes.count = parseInt(changeNoteCount);
            $scope.alerts.changeNotes.loading = false;
        });
    };
    var loadChangeNotes = function (n, skip) {
        var jsRef = $scope.alerts.changeNotes.jsRefId > -1 ? $scope.alerts.changeNotes.jsRefId : cnJsRefResolve(); // default if not already set
        var cn = $scope.alerts.changeNotes;
        cn.loading = true;
		var strSkip = ""; if (skip > 0) { strSkip = "&$skip=" + skip; }
        var oData = "?$inlinecount=allpages&$top=" + n + strSkip;
        torusNavBarService.getAdminChangeNotes(currentUser.id, ctId, ctuId, jsRef, window.location.pathname, cn.contextId, oData).then(function (changeNotes) {
            cn.skip = skip;
            cn.notes = changeNotes.results;
            cn.count = changeNotes.count;
            var n = cn.notes;
            var m = moment();
            for (var i = 0; i < n.length; i++) {
                m = moment(n[i].dateCreated);
                n[i].dateCreatedDisplay = m.isValid() ? m.format('L') : n[i].dateCreated;
                n[i].dateTimeCreatedDisplay = m.isValid() ? m.format('L HH:mm') : n[i].dateCreated;
            }
            cn.loading = false;
        });
    };
    $scope.showChangeNotes = function (contextId, n, skip) {
        var li = document.getElementById('liChangeNotes');
        if ($scope.alerts.changeNotes.show && li.className.indexOf('open-add') > -1) { $scope.alerts.changeNotes.show = false; } // update scope should the user have just clicked away and hidden dropdown that way...
        $scope.alerts.changeNotes.show = !$scope.alerts.changeNotes.show;
        if ($scope.alerts.changeNotes.show) {
            var jsRef = $scope.alerts.changeNotes.jsRefId > -1 ? $scope.alerts.changeNotes.jsRefId : cnJsRefResolve(); // default if not already set
            $scope.alerts.changeNotes.contextId = contextId;
            $scope.alerts.changeNotes.jsRefId = jsRef;
            loadChangeNotes(n, skip);
        }
    };
	$scope.bindChangeNotesTenantName = function () {
		if (!isNullOrUndefined(session.selectedTenant)) {
			return session.selectedTenant.name;
		}
		return "";
	};
	$scope.bindChangeNotesUserDisplayName = function () {
		if (!isNullOrUndefined(session.selectedUser)) {
			if (session.selectedUser.surname !== "") {
				return session.selectedUser.forenames + " " + session.selectedUser.surname + " ";
			}
			return session.selectedUser.username;
		}
		return "";
	};
	$scope.bindChangeNotesJsRefName = function (pn) {
		if ($scope.alerts.changeNotes.jsRefId > 0) {
			return String.format(resources.textShowJsRefTitle, pn, $scope.alerts.changeNotes.jsRefId);
		}
		return "";
	};
    $scope.bindChangeNotesOlderNewer = function (olderNewer) {
        var recLeft = 0;
        var cn = $scope.alerts.changeNotes;
		if (!isNullOrUndefined(cn) && cn.notes.length > 0) {
            if (olderNewer) { // old(down)
                recLeft = cn.count - (cn.notes.length + cn.skip);
                return String.format(resources.textShowOlder, recLeft);
            }
            else { // new(up)
                recLeft = cn.skip;
                return String.format(resources.textShowEarlier, recLeft);
            }
        }
        return "";
    };
    $scope.showChangeNotesOlderNewer = function (olderNewer, n, skip) {
        var cn = $scope.alerts.changeNotes;
		if (!isNullOrUndefined(cn)) {
            if (olderNewer) { // old(down)
                cn.skip = cn.skip + skip;
            }
            else { // new(up)
                cn.skip = cn.skip - skip;
            }
            loadChangeNotes(n, cn.skip);
        }
        return "";
    };
    $scope.bindChangeNotesIndex = function (ind) {
        var cn = $scope.alerts.changeNotes;
		if (!isNullOrUndefined(cn)) {
            return "(" + (ind + 1 + cn.skip) + '/' + cn.count + ")";
        }
        return "";
    };
    $scope.addNewChangeNote = function (n) {
        var jsRef = $scope.alerts.changeNotes.jsRefId > -1 ? $scope.alerts.changeNotes.jsRefId : cnJsRefResolve(); // default if not already set
        $scope.alerts.changeNotes.adding = true;
        var cn = $scope.alerts.changeNotes;
        torusNavBarService.setAdminChangeNotes(currentUser.id, ctId, ctuId, jsRef, window.location.pathname, cn.contextId, cn.newNoteText).then(function (data) {
            $scope.alerts.changeNotes.adding = false;
            $scope.alerts.changeNotes.newNoteText = "";
            gritterService.addGritter("btn-success", notifications.changeNoteAddedSuccessTitle, notifications.changeNoteAddedSuccessMessage, false);
            loadChangeNotes(n, 0); // reload at top
        });
    };

    // kbs...
    $scope.openAdminKbsLink = function (ref) {
		if (!isNullOrUndefined(ref)) {
            $rootScope.$broadcast('openAdminKbsArticleOverlay', { ref: ref });
        }
    };

    $scope.selectedTenant = null;
	if (!isNullOrUndefined(session) && !isNullOrUndefined(session.selectedTenant)) {
        $scope.selectedTenant = session.selectedTenant;
    }

    $scope.selectedUser = null;
	if (!isNullOrUndefined(session) && !isNullOrUndefined(session.selectedUser)) {
        $scope.selectedUser = session.selectedUser;
    }

    var formatTenant = function (tenant) { // must define ahead of call...
        return $sanitize(tenant.name);
    };

    var formatUser = function (user) { // must define ahead of call...
		if (!isNullOrUndefined(user.surname)) {
            return $sanitize(user.forenames + ' ' + user.surname);
        }
        return $sanitize('[' + user.username + ']');
    };

    var delayPromise;
    var delayList = function (fn) {
        return function (query) {
            if (delayPromise) {
                $timeout.cancel(delayPromise);
            }
            delayPromise = $timeout(function () {
                fn(query);
            }, 500);
        }
    };

    var getTenantList = function (query) {

        var params = {
            count: 10,
			page: isNullOrUndefined(query.page) ? 1 : query.page,
            sorting: { Name: 'asc' },
            filter: { Name: query.term, SubDomainName: query.term },
            filterUseOr: true
        };

        var oData = torusOData.format(params);

        $http.get('/api/admin/tenant/list/get' + oData, null).
            success(function (data) {

				if (isNullOrUndefined(data.results)) {
                    query.callback({
                        results: [],
                        more: false
                    });
                    return;
                }

                query.callback({
                    results: data.results,
                    more: data.count > params.page * params.count
                });
            }).
            error(function () {
                query.callback({
                    results: [],
                    more: false
                });
            });
    };

    var getUserList = function (query) {

        var params = {
            count: 10,
			page: isNullOrUndefined(query.page) ? 1 : query.page,
            sorting: { Surname: 'asc', Forenames: 'asc' },
            filter: { DisplayName: query.term, EmailAddress: query.term },
            filterUseOr: true
        };

        var oData = torusOData.format(params);

        $http.get('/api/admin/users/list/get/open/' + session.selectedTenant.subDomainName + oData, null).
            success(function (data) {

				if (isNullOrUndefined(data.results)) {
                    query.callback({
                        results: [],
                        more: false
                    });
                    return;
                }

                query.callback({
                    results: data.results,
                    more: data.count > params.page * params.count
                });
            }).
            error(function () {
                query.callback({
                    results: [],
                    more: false
                });
            });
    };

    $scope.tenantSelectOptions = {
        placeholder: resourcesPBCN.textSelectTenant,
        query: delayList(getTenantList),
        initSelection: function (element, callback) {
            callback($scope.selectedTenant);
        },
        formatResult: formatTenant, // omitted for brevity, see the source of this page
        formatSelection: formatTenant, // omitted for brevity, see the source of this page
        dropdownCssClass: "bigdrop", // apply css that makes the dropdown taller
        escapeMarkup: function (m) { return m; } // we do not want to escape markup since we are displaying html in results
    };

    $scope.userSelectOptions = {
        placeholder: resourcesPBCN.textSelectUser,
        query: delayList(getUserList),
        initSelection: function (element, callback) {
            callback($scope.selectedUser);
        },
        formatResult: formatUser, // omitted for brevity, see the source of this page
        formatSelection: formatUser, // omitted for brevity, see the source of this page
        dropdownCssClass: "bigdrop", // apply css that makes the dropdown taller
        escapeMarkup: function (m) { return m; } // we do not want to escape markup since we are displaying html in results
    };

    function selTenantOrUserRedir() {
        return settingsAdmin.selectedTenantUserStayOnPage ? "?r=" + window.location.pathname : "";
    }

    $scope.$watch('selectedTenant', function () {
		if (isNullOrUndefined($scope.selectedTenant) || $scope.selectedTenant === '') {
            return;
        }

		if (isNullOrUndefined(session) || isNullOrUndefined(session.selectedTenant) || $scope.selectedTenant.subDomainName !== session.selectedTenant.subDomainName) {
            $scope.loading = true;
            window.location.href = '/tenant/set/' + $scope.selectedTenant.subDomainName + selTenantOrUserRedir();
        }
    });

    $scope.$watch('selectedUser', function () {
		if (isNullOrUndefined($scope.selectedUser) || $scope.selectedUser === '') {
            return;
        }

		if (isNullOrUndefined(session) || isNullOrUndefined(session.selectedUser) || $scope.selectedUser.username !== session.selectedUser.username) {
            $scope.loading = true;
            window.location.href = '/tenant/user/setbyid/' + $scope.selectedUser.userAccountId + selTenantOrUserRedir();
        }
    });

    $scope.refreshNotificationCount();
    $scope.refreshTaskCount();
    $scope.refreshMessagingUnreadCount();
    $scope.refreshAdminDownloadsCount();
    refreshChangeNotesCount();
    loadAvatar();
}]);

torusControllers.controller('ClientMessageMenuController', ['$scope', '$filter', 'torusMenuService', function ($scope, $filter, torusMenuService) {

	$scope.menuLoadComplete = false;
	$scope.unopenedMsgCount = 0;

	$scope.bindUnreadMsgCount = function () {
		if ($scope.unopenedMsgCount > 0) {
			return String.format(settingsMenu.clientMenuLabelFormat, $scope.unopenedMsgCount);
		}
		return "";
	};

    if (settings.clientMessagingEnabled) { // no need to fire API call if not enabled
        if (!isNullOrUndefined(currentUser.id)) { // tenant ID always populated, user only after login made
		    torusMenuService.getClientMenuUserMsgOpenCount(currentUser.tenantId, currentUser.id).then(function (msgCount) {
			    $scope.unopenedMsgCount = msgCount;
			    $scope.menuLoadComplete = true;
		    }, function () {
			    $scope.menuLoadComplete = true;
		    });
        }
	}
	else {
		$scope.menuLoadComplete = true;
	}

}]);
;
var resources = window.resources || {};
var session = window.session || {};

var torusDirectives = angular.module('torus.directives', ['ngSanitize']).
  provider('markdownConverter', function () {
      var opts = {};
      return {
          config: function (newOpts) {
              opts = newOpts;
          },
          $get: function () {
              return new Showdown.converter(opts);
          }
      };
  });

torusDirectives.directive("stopPropagation", function () {
    return {
        restrict: "A",
        link: function ($scope, $element, $attrs) {
            var eventHandler, previousEventName;
            previousEventName = null;
            eventHandler = function (e) {
                return e.stopPropagation();
            };
            return $attrs.$observe("stopPropagation", function (eventName) {
                if (previousEventName) {
                    $element.off(previousEventName, eventHandler);
                }
                return $element.on(eventName, eventHandler);
            });
        }
    };
});

torusDirectives.directive("colorpickerStyling", function () {
    return {
        require: 'ngModel',
        restrict: "A",
        link: function ($scope, $element, $attrs) {

            function isHexColorLight(hexColor) {
                var c = hexColor.replace(/^#/, '');
                var sum = parseInt(c[0] + c[1], 16);
                sum += parseInt(c[2] + c[3], 16);
                sum += parseInt(c[4] + c[5], 16);
                return sum > 382.6;
            }

            $scope.$watch($attrs.ngModel, function (value) {
                if (iNoU(value)) {
                    return;
                }
                $element.css('background-color', value);
                $element.css('color', isHexColorLight(value) ? '#000' : '#fff');
            });
        }
    };
});

torusDirectives.directive('ngTorusPercSlider', function () {
    return {
        require: 'ngModel',
        link: function ($scope, el, attr, ctrl) {

            (function (el_) {
                var $el = $(el_);

                $scope.$watch(attr.ngModel, function (value) {
                    $el.slider('setValue', value);
                });

                $scope.$watch(function () {
                    return $el.attr('min') + ';' + $el.attr('max') + ';' + $el.attr('increment');
                }, function (value) {
                    var split = value.split(';');
                    $el.slider('setAttribute', 'min', split[0]);
                    $el.slider('setAttribute', 'max', split[1]);
                    $el.slider('setAttribute', 'increment', split[2]);
                    $el.slider('setValue', $scope.$eval(attr.ngModel));
                });
            })(el);

            var options = {
                'min': attr.min,
                'max': attr.max,
                'step': attr.increment
            };

            var formatter = attr.ngSliderFormatter;

            if (formatter) {
                formatter = $scope.$eval(formatter);
                options.formatter = formatter;
            } else {
                options.formatter = function (value) { return value; };
            }

            var tooltipFormatter = attr.ngSliderTooltipFormatter;

            if (tooltipFormatter) {
                tooltipFormatter = $scope.$eval(tooltipFormatter);
                options.tooltipFormatter = tooltipFormatter;
            } else {
                options.tooltipFormatter = function (value) { return value; };
            }

            if (attr.ngSlideBehaviour === 'onend') {
                $(el).slider(options).on('slideStop', function (e) {
                    ctrl.$setViewValue(e.value);
                    $scope.$eval(attr.ngSlide);
                    $scope.$apply();
                });
            }
            else {
                $(el).slider(options).on('slide', function (e) {
                    ctrl.$setViewValue(e.value);
                    $scope.$eval(attr.ngSlide);
                    $scope.$apply();
                }).on('slideStart', function (e) {
                    ctrl.$setViewValue(e.value);
                    $scope.$eval(attr.ngSlide);
                    $scope.$apply();
                });
            }
        }
    };
});

torusDirectives.directive('isolateForm', [function () {
    return {
        restrict: 'A',
        require: '?form',
        link: function (scope, el, attrs, ctrl) {
            if (!ctrl) {
                return;
            }

            // Do a copy of the controller
            var ctrlCopy = {};
            angular.copy(ctrl, ctrlCopy);

            // Get the parent of the form
            var parent = el.parent().controller('form');
            // Remove parent link to the controller
            parent.$removeControl(ctrl);

            // Replace form controller with a "isolated form"
            var isolatedFormCtrl = {
                $setValidity: function (validationToken, isValid, control) {
                    ctrlCopy.$setValidity(validationToken, isValid, control);
                    parent.$setValidity(validationToken, true, ctrl);
                },
                $setDirty: function () {
                    el.removeClass('ng-pristine').addClass('ng-dirty');
                    ctrl.$dirty = true;
                    ctrl.$pristine = false;
                }
            };
            angular.extend(ctrl, isolatedFormCtrl);
        }
    };
}]);

torusDirectives.directive('ngTorusDatePicker', function () {
    return {
        require: '?ngModel',
        restrict: 'A',
        link: function (scope, el, attr, ctrl) {

            var setDatePicker = function () {

                var dateFormat = moment.localeData().longDateFormat('L').toLowerCase();

                if (!iNoU(attr.dateFormat)) {
                    dateFormat = attr.dateFormat;
                }

                var startView = 0;
                if (!iNoU(attr.startView)) {
                    startView = parseInt(attr.startView);
                }

                var defaults = {
                    autoclose: true,
                    startView: startView,
                    format: dateFormat,
                    weekStart: 1,
                    startDate: attr.startDate,
                    endDate: attr.endDate
                };

                var options = scope.$eval(attr.ngTorusDatePicker);

                angular.extend(defaults, options);

                $(el).datepicker(defaults).next().on("click", function (e) {
                    e.preventDefault();
                    $(this).prev().focus();
                });

            };

            setDatePicker();

            if (!iNoU(attr.ngModel)) {

                attr.$observe('ngModel', function (value) {
                    scope.$watch(value, function () {
                        $(el).datepicker('update');
                    });
                });
            }

            attr.$observe('ngTorusDatePicker', function (value) {
                scope.$watch(value, function (options) {

                    if (iNoU(options)) {
                        return;
                    }

                    if (!iNoU(options.startDate)) {
                        $(el).datepicker('setStartDate', options.startDate);
                    }
                    if (!iNoU(options.endDate)) {
                        $(el).datepicker('setEndDate', options.endDate);
                    }

                }, true);
            });
            /*
            attr.$observe('startDate', function (value) {
                scope.$watch(value, function (startDate) {
                    $(el).datepicker('setStartDate', startDate);
                });
            });

            attr.$observe('endDate', function (value) {
                scope.$watch(value, function (endDate) {
                    $(el).datepicker('setEbdDate', endDate);
                });
            });
            */
        }
    };
});

torusDirectives.directive('ngTorusTimePicker', function () {
    return {
        require: '?ngModel',
        restrict: 'A',
        link: function (scope, el, attr, ctrl) {

            var setTimePicker = function () {

                var defaults = {
                    minuteStep: 1,
                    showSeconds: false,
                    showMeridian: false,
                    defaultTime: false
                };

                var options = scope.$eval(attr.ngTorusTimePicker);

                angular.extend(defaults, options);

                $(el).timepicker(defaults).next().on("click", function (e) {
                    e.preventDefault();
                    $(this).prev().focus();
                });

            };

            setTimePicker();

            if (!iNoU(attr.ngModel)) {

                attr.$observe('ngModel', function (value) {
                    scope.$watch(value, function (modelValue) {
                        $(el).timepicker('setTime', modelValue);
                    });
                });
            }

        }
    };
});

torusDirectives.directive('ngTorusPostcode', function () {
    return {
        require: 'ngModel',
        restrict: 'A',
        link: function (scope, el, attr, modelCtrl) {

            var regex = new RegExp(attr.ngTorusPostcode);

            // add a parser that will process each time the value is 
            // parsed into the model when the user updates it.
            modelCtrl.$parsers.unshift(function (value) {

                var postcode = value;

                if (value !== undefined) {
                    postcode = postcode.toUpperCase().replace(' ', '');

                    if (postcode.length === 5) {
                        postcode = postcode.substr(0, 2) + ' ' + postcode.substr(2);
                    } else if (postcode.length === 6 && postcode.substr(2, 1) !== ' ') {
                        postcode = postcode.substr(0, 3) + ' ' + postcode.substr(3);
                    } else if (postcode.length === 7 && postcode.substr(3, 1) !== ' ') {
                        postcode = postcode.substr(0, 4) + ' ' + postcode.substr(4);
                    }
                }

                if (postcode !== value) {
                    modelCtrl.$setViewValue(postcode);
                    modelCtrl.$render();
                }

                // test and set the validity after update.
                var valid = regex.test(postcode);
                modelCtrl.$setValidity('postcodeValidate', valid);

                return postcode;
            });
        }
    };
});

torusDirectives.directive('ngTorusRequiredLabel', function () {
    return {
        restrict: 'E',
        template: '<p class="torus-label form-control-static col-sm-2" style="padding-left:0"><span class="label label-danger">' + resources.textRequired + '</span></p>'
    };
});

torusDirectives.directive('ngTorusOptionalLabel', function () {
    return {
        restrict: 'E',
        template: '<p class="torus-label form-control-static col-sm-2" style="padding-left:0"><span class="label label-info">' + resources.textOptional + '</span></p>'
    };
});

torusDirectives.directive('ngTorusRequiredSmallSizedLabel', function () {
    return {
        restrict: 'E',
        template: '<p class="torus-label torus-label-small form-control-static col-sm-1" style="padding-left:0"><span class="label label-danger">' + resources.textRequired + '</span></p>'
    };
});

torusDirectives.directive('ngTorusRequiredOneFromGroupLabel', function () {
    return {
        restrict: 'E',
        template: '<p class="torus-label torus-label-small form-control-static col-sm-2" style="padding-left:0"><span class="label label-warning">' + resources.textRequiredOneFromGroup + '</span></p>'
    };
});

torusDirectives.directive('ngTorusDelayValidate', function () {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function (scope, el, attr, modelCtrl) {
            if (attr.type === 'radio' || attr.type === 'checkbox') { return; }

            var timeoutId = 0;
            var timeoutDelay = scope.$eval(attr.validationDelay) || 1000;

            el.unbind('input').unbind('keydown').unbind('change');

            el.bind('keydown', function () {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(function () {
                    scope.$apply(function () {
                        modelCtrl.$setViewValue(el.val());
                    });
                }, timeoutDelay);
            });

            el.bind('change', function () {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(function () {
                    scope.$apply(function () {
                        modelCtrl.$setViewValue(el.val());
                    });
                }, timeoutDelay);
            });

            el.bind('blur', function () {
                clearTimeout(timeoutId);
                scope.$apply(function () {
                    modelCtrl.$setViewValue(el.val());
                });
            });
        }
    };
});

torusDirectives.directive('ngTorusEqual', function () {
    return {
        restrict: 'A', // only activate on element attribute
        require: '?ngModel', // get a hold of ngModel Controller
        link: function (scope, elem, attrs, ngModel) {
            if (!ngModel) return; // do nothing if no ng-torus-equal

            // watch own value and re-validate on change
            scope.$watch(attrs.ngModel, function () {
                validate();
            });

            // observe the other value and re-validate on change
            attrs.$observe('ngTorusEqual', function () {
                validate();
            });

            var validate = function () {
                // values
                var val1 = ngModel.$viewValue;
                var val2 = attrs.ngTorusEqual;
                // set validity
                ngModel.$setValidity('ngTorusEqual', val1 === val2);
            };
        }
    };
});

torusDirectives.directive('ngNotZero', function () {
    return {
        restrict: 'A', // only activate on element attribute
        require: '?ngModel', // get a hold of ngModel Controller
        link: function (scope, elem, attrs, ngModel) {
            if (!ngModel) return; // do nothing if no ng-torus-equal

            // watch own value and re-validate on change
            scope.$watch(attrs.ngModel, function () {
                validate();
            });

            // observe the other value and re-validate on change
            attrs.$observe('ngNotZero', function () {
                validate();
            });

            var validate = function () {
                // values
                var val1 = parseFloat(ngModel.$modelValue);
                // set validity
                ngModel.$setValidity('ngTorusEqual', val1 > 0);
            };
        }
    };
});

torusDirectives.directive('torusRequiredAny', function () {
    // Hash for holding the state of each group
    var groups = {};

    // Helper function: Determines if at least one control
    //                  in the group is non-empty
    function determineIfRequired(groupName) {
        var group = groups[groupName];
        if (!group) return false;

        var keys = Object.keys(group);
        return keys.every(function (key) {
            return key === 'isRequired' || !group[key];
        });
    }

    return {
        restrict: 'A',
        require: '?ngModel',
        scope: {},   // an isolate scope is used for easier/cleaner
        // $watching and cleanup (on destruction)
        link: function postLink(scope, elem, attrs, modelCtrl) {
            // If there is no `ngModel` or no groupName has been specified,
            // then there is nothing we can do
            if (!modelCtrl || !attrs.torusRequiredAny) return;

            // Get a hold on the group's state object
            // (if it doesn't exist, initialize it first)
            var groupName = attrs.torusRequiredAny;
            if (groups[groupName] === undefined) {
                groups[groupName] = { isRequired: true };
            }
            var group = scope.group = groups[groupName];

            // Clean up when the element is removed
            scope.$on('$destroy', function () {
                delete (group[scope.$id]);
                if (Object.keys(group).length <= 1) {
                    delete (groups[groupName]);
                }
            });

            // Updates the validity state for the 'required' error-key
            // based on the group's status
            function updateValidity() {
                if (group.isRequired) {
                    modelCtrl.$setValidity('required', false);
                } else {
                    modelCtrl.$setValidity('required', true);
                }
            }

            // Updates the group's state and this control's validity
            function validate(value) {
                group[scope.$id] = !modelCtrl.$isEmpty(value);
                group.isRequired = determineIfRequired(groupName);
                updateValidity();
                return group.isRequired ? undefined : value;
            };

            // Make sure re-validation takes place whenever:
            //   either the control's value changes
            //   or the group's `isRequired` property changes
            modelCtrl.$formatters.push(validate);
            modelCtrl.$parsers.unshift(validate);
            scope.$watch('group.isRequired', updateValidity);
        }
    };
});

torusDirectives.directive('ngCheckStrength', ['passwordStrength', function (passwordStrength) {

    return {
        replace: false,
        restrict: 'A',
        require: '?ngModel', // get a hold of ngModel Controller
        link: function (scope, elem, attrs, ngModel) {
            scope.$watch(attrs.ngModel, function () {
                var val = ngModel.$viewValue || "";
                scope.strength = passwordStrength.getStrength(val);
            });
        },
        template: "<span class='label {{strength.className}}'>{{strength.title}}</span>"
    };

}]);

torusDirectives.directive('ngTorusReqPasswordStrength', ['passwordStrength', function (passwordStrength) {
    return {
        restrict: 'A', // only activate on element attribute
        require: '?ngModel', // get a hold of ngModel Controller
        link: function (scope, elem, attrs, ngModel) {
            if (!ngModel) return; // do nothing if no ng-torus-equal

            // watch own value and re-validate on change
            scope.$watch(attrs.ngModel, function () {
                validate();
            });

            var validate = function () {
                // set validity
                var setSrc = settings.minPasswordStrength != null ? settings : settingsLogin;
                var val = ngModel.$viewValue;
                var strengthIndex = passwordStrength.getStrength(val).index;
                ngModel.$setValidity('ngTorusReqPasswordStrength', strengthIndex >= setSrc.minPasswordStrength);
            };
        }
    };
}]);

torusDirectives.directive('ngNotEmptyArray', function () {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function (scope, elem, attr, ctrl) {

            scope.$watchCollection(function () {
                return ctrl.$modelValue;
            }, function (value) {
                ctrl.$setValidity('ngNotEmptyArray', value.length > 0);
            });

        }
    };
});

torusDirectives.directive('ngTorusSpinner', function () {
    return {
        restrict: 'E',
        template: '<div class="torus-spinner"><div class="bounce1"></div><div class="bounce2"></div><div class="bounce3"></div></div>'
    };
});

torusDirectives.directive('ngShowOnRequestBegin', function () {
    return {
        restrict: 'A',
        link: function (scope, el) {

            // hide the el initially
            el.hide();

            var startEvent = scope.$on('requestStart', function () {
                //console.log('ngShowOnRequestBegin - requestStart');
                // got the request start notification, show the el
                el.show();
            });

            var endEvent = scope.$on('requestEnd', function () {
                //console.log('ngShowOnRequestBegin - requestEnd');
                // got the request end notification, hide the el
                el.hide();
            });

            scope.$on('$destroy', function () {
                startEvent();
                endEvent();
            });
        }
    };
});

torusDirectives.directive('ngShowOnRequestEnd', function () {
    return {
        restrict: 'A',
        link: function (scope, el) {

            // hide the el initially
            el.hide();

            var startEvent = scope.$on('requestStart', function () {
                // got the request start notification, hide the element
                el.hide();
            });

            var endEvent = scope.$on('requestEnd', function () {
                // got the request end notification, show the element
                el.show();
            });

            scope.$on('$destroy', function () {
                startEvent();
                endEvent();
            });
        }
    };
});

torusDirectives.directive('ngSelectAllCheckbox', ['$filter', function ($filter) {
    return {
        replace: true,
        restrict: 'E',
        scope: {
            checkboxes: '=',
            allselected: '=allSelected',
            allclear: '=allClear',
            className: '@class',
            checkProp: '@checkProp',
            disabledProp: '@disabledProp',
            checkFunction: '&',
        },
        template: '<input title="Select all..." type="checkbox" ng-model="master" ng-change="masterChange()" class="{{className}}">',
        controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {

            var checkProp = iNoU($scope.checkProp) ? 'isSelected' : $scope.checkProp;
            var disabledProp = iNoU($scope.disabledProp) ? 'isDisabled' : $scope.disabledProp;

            $scope.masterChange = function () {

                var fn = $attrs.checkFunction;

                if ($scope.master) {
                    if (!iNoU(fn)) {
                        $scope.checkFunction({ checkboxes: $scope.checkboxes, checkProp: checkProp, disabledProp: disabledProp, checked: true });
                    } else {
                        angular.forEach($scope.checkboxes, function (cb) {
                            if (!cb[disabledProp]) { cb[checkProp] = true; };
                        });
                    }
                } else {
                    if (!iNoU(fn)) {
                        $scope.checkFunction({ checkboxes: $scope.checkboxes, checkProp: checkProp, disabledProp: disabledProp, checked: false });
                    } else {
                        angular.forEach($scope.checkboxes, function (cb) {
                            cb[checkProp] = false;
                        });
                    }
                }
            };

            $scope.$watch('checkboxes', function () {
                checkboxSetClear();
            }, true);

            var checkboxSetClear = function () {
                if (iNoU($scope.checkboxes)) { return; }
                var checkedItems = $filter('filter')($scope.checkboxes, checkboxFilter);
                var disabledItems = $filter('filter')($scope.checkboxes, checkboxDisabledFilter);

                var allClear = checkedItems.length === 0;
                var allSet = !allClear && (checkedItems.length === $scope.checkboxes.length); // the lot, can't be if any disabled...
                if (disabledItems.length) { allSet = checkedItems.length == ($scope.checkboxes.length - disabledItems.length) } // but then if disabled, all set of those that can be

                if ($scope.allselected !== undefined) {
                    $scope.allselected = allSet;
                }
                if ($scope.allclear !== undefined) {
                    $scope.allclear = allClear;
                }

                $element.prop('indeterminate', false);
                if (allSet) {
                    $scope.master = true;
                } else if (allClear) {
                    $scope.master = false;
                } else { // "some"...
                    $scope.master = false;
                    $element.prop('indeterminate', true);
                }
            }
            var checkboxFilter = function (checkbox) {
                return checkbox[checkProp] === true;
            };
            var checkboxDisabledFilter = function (checkbox) {
                return checkbox[disabledProp] === true;
            };
        }]
    };
}]);

torusDirectives.directive('ngConfirm', ['$document', function ($document) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {
            var buttonId, tmpl, html, message, nope, title, yep, placement, yesClass, noClass, useBtnIcons;

            buttonId = Math.floor(Math.random() * 10000000000);

            attrs.buttonId = buttonId;

            message = attrs.message || "";
            yep = attrs.yes || "Yes";
            nope = attrs.no || "No";
            title = attrs.title || "";
            placement = attrs.placement || 'right';
            yesClass = attrs.yesClass || 'btn-danger';
            noClass = attrs.noClass || 'btn-default';
            useBtnIcons = attrs.useBtnIcons || 'true';


            tmpl = "<div class='text-center' id='button-{0}'> \
                <p><span class='confirm-msg'>{1}</span></p> \
                <p><span class='confirm-yes btn {2}'><span>{3}{4}</span></span> \
                <span class='confirm-no btn {5}'><span>{6}{7}</span></span></p> \
              </div>";

            html = String.format(tmpl, buttonId, message, yesClass, useBtnIcons === 'true' ? '<i class="fa fa-check"></i> ' : '', yep, noClass, useBtnIcons === 'true' ? '<i class="fa fa-times"></i> ' : '', nope);

            element.popover({
                content: html,
                html: true,
                trigger: "manual",
                title: title,
                placement: placement,
                container: "body"
            });

            return element.bind('click', function (el) {
                var dontBubble = true,
                  pop;

                el.stopPropagation();
                element.popover('show');
                pop = $("#button-" + buttonId);

                pop.closest(".popover").click(function (e) {
                    e.preventDefault();
                    if (dontBubble) {
                        e.stopPropagation();
                    }
                });

                pop.find('.confirm-yes').click(function () {
                    // this closes popover and doesn't conflict with popup directive
                    pop.closest('.popover').remove();
                    scope.$apply(attrs.ngConfirm);
                });

                // just hide the popover from view
                pop.find('.confirm-no').click(function () {
                    // kill binds
                    $document.off('click.confirm.' + buttonId);
                    pop.closest('.popover').remove();
                });

                $document.on('click.confirm.' + buttonId, ":not(.popover, .popover *)", function () {
                    $document.off('click.confirm.' + buttonId);
                    pop.closest('.popover').remove();
                });
            });
        }
    };
}]);

torusDirectives.directive('ngChecklistModel', ['$parse', '$compile', function ($parse, $compile) {
    // contains
    function contains(arr, item) {
        if (angular.isArray(arr)) {
            for (var i = 0; i < arr.length; i++) {
                if (angular.equals(arr[i], item)) {
                    return true;
                }
            }
        }
        return false;
    }

    // add
    function add(arr, item) {
        arr = angular.isArray(arr) ? arr : [];
        for (var i = 0; i < arr.length; i++) {
            if (angular.equals(arr[i], item)) {
                return arr;
            }
        }
        arr.push(item);
        return arr;
    }

    // remove
    function remove(arr, item) {
        if (angular.isArray(arr)) {
            for (var i = 0; i < arr.length; i++) {
                if (angular.equals(arr[i], item)) {
                    arr.splice(i, 1);
                    break;
                }
            }
        }
        return arr;
    }

    // http://stackoverflow.com/a/19228302/1458162
    function postLinkFn(scope, elem, attrs) {
        // compile with `ng-model` pointing to `checked`
        $compile(elem)(scope);

        // getter / setter for original model
        var getter = $parse(attrs.checklistModel);
        var setter = getter.assign;

        // value added to list
        var value = $parse(attrs.checklistValue)(scope.$parent);

        // watch UI checked change
        scope.$watch('checked', function (newValue, oldValue) {
            if (newValue === oldValue) {
                return;
            }
            var current = getter(scope.$parent);
            if (newValue === true) {
                setter(scope.$parent, add(current, value));
            } else {
                setter(scope.$parent, remove(current, value));
            }
        });

        // watch original model change
        scope.$parent.$watch(attrs.checklistModel, function (newArr) {
            scope.checked = contains(newArr, value);
        }, true);
    }

    return {
        restrict: 'A',
        priority: 1000,
        terminal: true,
        scope: true,
        compile: function (tElement, tAttrs) {
            if (tElement[0].tagName !== 'INPUT' || !tElement.attr('type', 'checkbox')) {
                throw 'checklist-model should be applied to `input[type="checkbox"]`.';
            }

            if (!tAttrs.checklistValue) {
                throw 'You should provide `checklist-value`.';
            }

            // exclude recursion
            tElement.removeAttr('checklist-model');

            // local scope var storing individual checkbox model
            tElement.attr('ng-model', 'checked');

            return postLinkFn;
        }
    };
}]);

torusDirectives.directive('ngNumberFormat', ['$filter', '$locale', function ($filter, $locale) {
    return {
        require: 'ngModel',
        priority : 3,
        link: function (scope, element, attrs, ngModel) {
                       
            var filterType = attrs.ngNumberFormat;
            if (iNoU(filterType)) {
                filterType = 'number';
            }

            var decimalPlaces = scope.$eval(attrs.decimalPlaces);
            if (iNoU(decimalPlaces)) {
                decimalPlaces = (filterType === 'number') ? 0 : 2;
            }

            function decimalRex(dChar) {
                return RegExp("\\d|\\" + dChar, 'g');
            }

            function clearRex(dChar) {
                return RegExp("((\\" + dChar + ")|([0-9]{1,}\\" + dChar + "?))&?[0-9]{0," + decimalPlaces + "}", 'g');
            }

            function decimalSepRex(dChar) {
                return RegExp("\\" + dChar, "g");
            }

            function clearValue(value) {
                if (iNoU(value)) {
                    return null;
                }

                value = value.toString();
                var dSeparator = $locale.NUMBER_FORMATS.DECIMAL_SEP;
                var clear;

                if (value.match(decimalSepRex(dSeparator))) {
                    clear = value.match(decimalRex(dSeparator))
                        .join("").match(clearRex(dSeparator));
                    clear = clear ? clear[0].replace(dSeparator, ".") : null;
                } else if (value.match(decimalSepRex("."))) {
                    clear = value.match(decimalRex("."))
                        .join("").match(clearRex("."));
                    clear = clear ? clear[0] : null;
                } else {
                    clear = value.match(/\d/g);
                    clear = clear ? clear.join("") : null;
                }

                return clear;
            }

            var updateView = function (value) {
                var val = parseFloat(clearValue(value));
                ngModel.$setViewValue(val);
                ngModel.$render();
                return val;
            }

            var updateFormattedValue = function (value) {
                if (iNoU(value)) {
                    ngModel.$setViewValue('');
                    return;
                }
                if (isNaN(value)) {
                    ngModel.$setViewValue('');
                    return;
                }
                if (filterType === 'currency') {
                    return $filter('currency')(value);
                }
                else 
                if (filterType === 'percentage') {
                    return $filter('percentage')(value);
                } else {
                    return $filter('number')(value, decimalPlaces);
                }
            }

            ngModel.$formatters.unshift(function fromModelToView(value) {
                return updateFormattedValue(value);
            });

            ngModel.$parsers.unshift(function (value) {
                var val = parseFloat(clearValue(value));
                return val;
            });

            element.on('blur', function () {
                element.val(updateFormattedValue(ngModel.$modelValue));
            });

            element.on('focus', function () {
                updateView(ngModel.$modelValue);
            });

        }
    };
}]);

torusDirectives.directive("ngTorusImageSelect", ['imageService', 'torusOData', function (imageService, torusOData) {

    return {
        restrict: "E",
        scope: {
            selectedImage: "=",
            selectedImageType: "=",
            hideButtons: "=",
            placeholder: "=",
            ngRequired: "=",
            name: "@",
            id: "@",
            tenantName: "=",
            ngDisabled: "=",
        },
        template: '<div class="row">' +
            '<div ng-class="{\'col-sm-10\': (!hideButtons && !ngDisabled), \'col-sm-12\': (hideButtons || ngDisabled)}"><input type="hidden" name="{{name}}" id="{{id}}" class="form-control" ui-select2="imageSelectOptions" ng-model="image" ng-required="ngRequired" ng-disabled="ngDisabled" /></div>' +
            '<div class="col-sm-2 btn-group" ng-hide="(hideButtons || ngDisabled)">' +
            '<label class="btn btn-sm" ng-class="{true: \'btn-primary\', false: \'btn-white\'}[imageType===\'webicon\']" ng-model="imageType" uib-btn-radio="\'webicon\'" title=\"Web Icon\"><i class="icon-only ace-icon fa fa-flag bigger-110"></i></label>' +
            '<label class="btn btn-sm" ng-class="{true: \'btn-primary\', false: \'btn-white\'}[imageType===\'image\']" ng-model="imageType" uib-btn-radio="\'image\'" title=\"Image/Photo\"><i class="icon-only ace-icon fa fa-image bigger-110"></i></label>' +
            '</div>' +
            '</div>',
        compile: function () {
            return {
                pre: function ($scope) {

                    var initImage = $scope.selectedImage;
                    var initImageType = $scope.selectedImageType;
                    var tenant = $scope.tenantName;


                    var formatClassName = function (className) {
                        if (iNoU(className)) {
                            return '';
                        }

                        return className.replace(/fa[-\s]+/g, '');
                    };

                    var formatItem = function (item) {
                        var markup;
                        var tenant = $scope.tenantName;

                        if (iNoU(tenant) && !iNoU(session) && !iNoU(session.selectedTenant)) {
                            tenant = session.selectedTenant.subDomainName;
                        }

                        if ($scope.imageType === 'webicon' || $scope.imageType === 0) {
                            markup = String.format('<span style="display: inline-block; width:24px;"><i class="{0}"></i></span><span>{1}</span>', item.class, formatClassName(item.class));
                        } else {
                            if (iNoU(tenant)) {
                                markup = String.format('<span><img alt="{0}" src="/thumbnail/gallery/{1}" height="20" width ="20" /> {0}</span>', item.filename, item.guid);
                            } else {
                                markup = String.format('<span><img alt="{0}" src="/thumbnail/gallery/{1}/{2}" height="20" width ="20" /> {0}</span>', item.filename, item.guid, tenant);
                            }
                        }

                        return markup;
                    };


                    var getImageList = function (query) {

                        if (iNoU(tenant) && !iNoU(session) && !iNoU(session.selectedTenant)) {
                            tenant = session.selectedTenant.subDomainName;
                        }

                        var params = {
                            count: 20,
                            page: iNoU(query.page) ? 1 : query.page,
                            filter: { Filename: query.term },
                            sorting: { Filename: 'asc' }
                        };

                        var oData = torusOData.format(params);

                        imageService.getImagesList($scope.imageType, tenant, oData).then(
                            function (data) {
                                query.callback({
                                    results: data.results,
                                    more: (data.count > (params.page * params.count))
                                });
                            },
                            function () {
                                query.callback({
                                    results: [],
                                    more: false
                                });
                            }
                        );

                    };

                    var getImage = function (callback) {

                        if (iNoU(initImage)) {
                            callback({});
                            return;
                        }

                        if (iNoU(tenant) && !iNoU(session) && !iNoU(session.selectedTenant)) {
                            tenant = session.selectedTenant.subDomainName;
                        }

                        imageService.getImage(initImageType, tenant, initImage).then(
                            function (data) {
                                if (!iNoU(data)) {
                                    callback(data);
                                }
                                return;
                            },
                            function () {
                                //callback({});
                                return;
                            }
                        );

                    };

                    $scope.image = initImage;
                    $scope.imageType = iNoU(initImageType) ? 'webicon' : initImageType;

                    $scope.$watch('imageType', function () {
                        if ($scope.selectedImageType != $scope.imageType) {
                            $scope.selectedImageType = $scope.imageType;
                            $scope.image = null;
                        }
                    });

                    $scope.$watch('image', function () {
                        if (iNoU($scope.image)) {
                            $scope.selectedImage = null;
                            return;
                        }

                        if ($scope.imageType === 'webicon') {
                            $scope.selectedImage = $scope.image.class;
                        } else {
                            $scope.selectedImage = $scope.image.guid;
                        }
                    });

                    $scope.imageSelectOptions = {
                        placeholder: iNoU($scope.placeholder) ? 'Select image' : $scope.placeholder,
                        allowClear: true,
                        query: getImageList,
                        initSelection: function (element, callback) {
                            getImage(callback);
                        },
                        formatResult: formatItem,
                        formatSelection: formatItem,
                        dropdownCssClass: "bigdrop",
                        escapeMarkup: function (m) { return m; } // we do not want to escape markup since we are displaying html in results
                    };

                }
            };
        }
    };
}]);

torusDirectives.directive('ngSelectOnClick', function () {
    return {
        restrict: 'A',
        link: function (scope, element) {
            element.on('click', function () {
                this.select();
            });
        }
    };
});

torusDirectives.directive('ngMoveOnFill', ['$parse', function ($parse) {
    return {
        restrict: 'A',
        require: ['ngModel'],
        link: function (scope, element, attrs, ctrls) {
            var targetElId;
            targetElId = attrs.movetarget || "";
            var model = ctrls[0], form = ctrls[1];
            scope.next = function () {
                return model.$valid
            }
            scope.$watch(scope.next, function (newValue, oldValue) {
                if (newValue && model.$dirty) {
                    var nextinput = targetElId != "" ? document.getElementsByName(targetElId) : element.next('input');
                    if (nextinput.length === 1) {
                        nextinput[0].focus();
                    }
                }
            })
        }
    };
}]);

torusDirectives.directive('textInsert', [
    '$rootScope', function ($rootScope) {
        return {
            require: '?ngModel',
            link: function (scope, element, attrs, ngModel) {

                $rootScope.$on('insertText', function (e, id, val) {
                    
                    var domElement = element[0];

                    if (domElement.id !== id) {
                        return;
                    }

                    var $textarea = $(domElement);

                    var editorId = $textarea.attr('data-expressioneditorid');

                    if (editorId) {
                        insertParameterIntoExpressionEditor(editorId, val);
                        return;
                    }

                    if (document.selection) {
                        domElement.focus();
                        var sel = document.selection.createRange();
                        sel.text = val;
                        domElement.focus();
                    } else if (domElement.selectionStart || domElement.selectionStart === 0) {
                        var startPos = domElement.selectionStart;
                        var endPos = domElement.selectionEnd;
                        var scrollTop = domElement.scrollTop;
                        domElement.value = domElement.value.substring(0, startPos) + val + domElement.value.substring(endPos, domElement.value.length);
                        domElement.focus();
                        domElement.selectionStart = startPos + val.length;
                        domElement.selectionEnd = startPos + val.length;
                        domElement.scrollTop = scrollTop;
                    } else {
                        domElement.value += val;
                        domElement.focus();
                    }

                    if (!iNoU(ngModel)) {
                        ngModel.$setViewValue(domElement.value);
                    }

                });
            }
        }
    }
]);

torusDirectives.directive('markdown', ['$sanitize', '$compile', 'markdownConverter', function ($sanitize, $compile, markdownConverter) {
    return {
        restrict: 'AE',
        link: function (scope, element, attrs) {
            var md = '';
            if (attrs.markdown) {
                scope.$watch(attrs.markdown, function (newVal) {
                    md = newVal ? markdownConverter.makeHtml(newVal) : '';
                    element.html(md);
                    $compile(element.contents())(scope);
                });
            } else {
                md = markdownConverter.makeHtml(element.text());
                element.html(md);
                $compile(element.contents())(scope);
            }
        }
    };
}]);

torusDirectives.directive("templateContent", [
    '$compile', function ($compile) {
        return {
            restrict: "A",
            replace: true,
            scope: { templateContent: '=templateContent' },
            link: function (scope, ele, attr) {
                scope.$watch('templateContent', function (html) {
                    ele.html(html); 

                    $compile(ele.contents())(scope);

                    var id = attr.id;

                    scope.$emit('template-content-loaded', { id: id });
                });
            }
        };
    }
]);

torusDirectives.directive("scrollTo", ["$window", function ($window) {
    return {
        restrict: "AC",
        link: function (scope, element, attr) {

            var document = $window.document;

            function scrollInto(idOrName) {//find element with the give id of name and scroll to the first element it finds
                if (!idOrName)
                    $window.scrollTo(0, 0);
                //check if an element can be found with id attribute
                var el = document.getElementById(idOrName);
                if (!el) {//check if an element can be found with name attribute if there is no such id
                    el = document.getElementsByName(idOrName);

                    if (el && el.length)
                        el = el[0];
                    else
                        el = null;
                }

                if (el) //if an element is found, scroll to the element
                    el.scrollIntoView();
                //otherwise, ignore
            }

            element.bind("click", function (event) {
                scrollInto(attr.scrollTo);
            });
        }
    };
}]);

torusDirectives.directive('embedPdf', function () {
    return {
        restrict: 'A',
        scope: { fileGuid: '=' },
        link: function (scope, element) {
            scope.$watch('fileGuid', function () {
                element.html('<embed height="300" width="100%" src="/inlinefile/' + scope.fileGuid + '" type="application/pdf"></embed>');
            });
        }
    };
});

torusDirectives.directive('ngTorusConfidentiality', ['$rootScope', function ($rootScope) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {
            element.bind('keydown', function (event) {
                if (event.which === 27) {
					var dOpn = (iNoU($rootScope.aceDialogOpen) ? false : $rootScope.aceDialogOpen);
					var excptLst = '|/account/admin/planner|';
					if(!(dOpn && excptLst.indexOf(window.location.pathname) > -1)) { // no dialog open on listed page paths
						$rootScope.$broadcast('openConfidentialityOverlay');
					}
					else { // attempt shut of dialog instead
						try { $('button[data-bb-handler=close]').click(); } catch (e) { }
					}
                }
            });
        }
    };
}]);

torusDirectives.directive('a', ['$rootScope', function ($rootScope) {
	return {
		restrict: 'E',
		link: function (scope, element, attrs) {
			var ilpe = ["/peoplevalue", "/sso"]; // "internalLinkPrefixExceptions"
			if (attrs.bypassoffsitelinkcheck === undefined) {
				var tHref = !iNoU(attrs.href) ? attrs.href : !iNoU(attrs.ngHref) ? attrs.ngHref : null; // tHref = "true target destination"
				var extLink = false;
				if (!iNoU(tHref)) {
					extLink = tHref.length > 1 && (tHref.substring(0, 1) !== "/" && tHref.substring(0, 1) !== "#" && tHref !== "javascript:;");
					if (!extLink) {
						extLink = (tHref).indexOf(window.location.hostname) > 1; // if appears internal (ug absolute URL used) still check no appearance of current domain, to determine wholly externally).
						if (!extLink) { // if still not detected as external, also need to check exceptions that must be treated as such
							for (var i = 0; i < ilpe.length; i++) {
								if (tHref.toLowerCase().startsWith(ilpe[i])) { extLink = true; break; }
							}
						}
					}
				}
				element.on('click', function (e) {
					if (settings.useOffsiteLinkDisclaimer && extLink) {
						e.preventDefault();
						$rootScope.$broadcast('openOffsiteLinkDisclaimerOverlay', { href: tHref, target: attrs.target });
					}
				});
			}
		}
	};
}]);

torusDirectives.directive('masked', ['$rootScope', function ($rootScope) {
	return {
		restrict: 'E',

		scope: {
			scope: '='
		},

		link: function (scope, element, attrs) {
			scope.initMask = function (maskUnMask) {
				var mTypeNumeric = true; // assume number, but can do text...
				if (maskUnMask) { // masking+hiding
					if (!iNoU(element.attr("maskval"))) {
						element.html(element.attr("maskval")); // put in previous created mask
					}
					else { // build mask
						mTypeNumeric = !iNoU(attrs.masktype) && attrs.masktype === "text" ? false  : true;
						var mskP = !iNoU(attrs.maskprefix) ? attrs.maskprefix : "";
						var mskS = !iNoU(attrs.masksuffix) ? attrs.masksuffix : "";
						var mskC = !iNoU(attrs.maskchar) ? attrs.maskchar : "*";
						var mskStr = "";
						element.attr("rawval", element.html());
						if (!mTypeNumeric) {
							for (var i = 0; i < element.html().length; i++) {
								mskStr += mskC;
							}
						}
						else {
							mskStr = confidentialityData.defaultNumericMask;
						}
						element.attr("maskval", mskP + mskStr + mskS);
						element.html(mskP + mskStr + mskS);
					}
				}
				else { // unmasking...
					if (!iNoU(element.attr("rawval"))) {
						element.html(element.attr("rawval"));
					}
				}
			};
            if (!iNoU(confidentialityData)) { // check for pageData being available...
                // check for cookie for any live change first...
                var tVal = confidentialityData.defaultStateHideShowSensitive;
                var ckie = readCookie("SensistiveValuesHideShowDisplay");
                if (ckie != null) { tVal = (ckie == 'true'); }
                scope.initMask(tVal);
			}
			scope.$on("switchSensitiveValuesShowHide", function (event, args) {
				scope.initMask(args.state);
			});
		}
	};
}]);

torusDirectives.directive('faqHeader', ['$document', function ($document) {
    return {
        restrict: 'C',
        link: function (scope, element, attrs) {

            element.addClass('animated');

			element.bind('click', function () {

				var nearestFaqBody = $(element).next('.faq-body');

				var faqBodies = $document.find('.faq-body');

				for (var i = 0; i < faqBodies.length; i++) {
					var faqBody = $(faqBodies[i]);

					if (faqBody.is(nearestFaqBody)) {
						continue;
					}

					faqBody.removeClass('fadeIn').addClass('hide');
				}

				if (nearestFaqBody.hasClass('fadeIn')) {
					nearestFaqBody.removeClass('fadeIn').addClass('hide');
				} else {
					nearestFaqBody.addClass('fadeIn').removeClass('hide');
				}

			});

        }
    };
}]);

torusDirectives.directive('faqBody', ['$document', function ($document) {
    return {
        restrict: 'C',
        link: function (scope, element, attrs) {

            element.addClass('animated hide');;

        }
    };
}]);

torusDirectives.provider('dropzoneOps', function () {
    /*
     *	Add default options here
    **/
    var defOps = {
        //Add your options here
    };

	return {
		setOptions: function (newOps) {
			angular.extend(defOps, newOps);
		},
		$get: function () {
			return defOps;
		}
	};
});

torusDirectives.directive('ngDropzone', ['$timeout', 'dropzoneOps', function ($timeout, dropzoneOps) {
	return {
		restrict: 'AE',
		template: '<div></div>',
		replace: true,
		scope: {
			options: '=?', //http://www.dropzonejs.com/#configuration-options
			callbacks: '=?', //http://www.dropzonejs.com/#events
			methods: '=?' //http://www.dropzonejs.com/#dropzone-methods
		},
		link: function (scope, iElem, iAttr) {
			//Set options for dropzone {override from dropzone options provider}
			scope.options = scope.options || {};
			var initOps = angular.extend({}, dropzoneOps, scope.options);


			//Instantiate dropzone with initOps
			var dropzone = new Dropzone(iElem[0], initOps);

			/*********************************************/

			//Instantiate Dropzone methods (Control actions)
			scope.methods = scope.methods || {};

			scope.methods.getDropzone = function () {
				return dropzone; //Return dropzone instance
			};

			scope.methods.getAllFiles = function () {
				return dropzone.files; //Return all files
			};

			var controlMethods = [
				'removeFile', 'removeAllFiles', 'processQueue',
				'getAcceptedFiles', 'getRejectedFiles', 'getQueuedFiles', 'getUploadingFiles',
				'disable', 'enable', 'confirm', 'createThumbnailFromUrl'
			];

			angular.forEach(controlMethods, function (methodName) {
				scope.methods[methodName] = function () {
					dropzone[methodName].apply(dropzone, arguments);
					if (!scope.$$phase && !scope.$root.$$phase) scope.$apply();
				};
			});

			/*********************************************/

			//Set invents (callbacks)
			if (scope.callbacks) {
				var callbackMethods = [
					'drop', 'dragstart', 'dragend',
					'dragenter', 'dragover', 'dragleave', 'addedfile', 'removedfile',
					'thumbnail', 'error', 'processing', 'uploadprogress',
					'sending', 'success', 'complete', 'canceled', 'maxfilesreached',
					'maxfilesexceeded', 'processingmultiple', 'sendingmultiple', 'successmultiple',
					'completemultiple', 'canceledmultiple', 'totaluploadprogress', 'reset', 'queuecomplete'
				];
				angular.forEach(callbackMethods, function (method) {
					var callback = (scope.callbacks[method] || angular.noop);
					dropzone.on(method, function () {
						callback.apply(null, arguments);
						if (!scope.$$phase && !scope.$root.$$phase) scope.$apply();
					});
				});
			}
		}
	};
}]);

torusDirectives.directive('ngObfuscated', function () {
	return {
		restrict: 'A',
		link: function (scope, element, attrs) {
			makeObfuscated(element[0], true);
		}
	};
});

var nextUniqueEditorId = 0;

torusDirectives.directive('torusExpressionEditor', function () {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {
            var params = iNoU(attrs['torusExpressionEditor']) || attrs['torusExpressionEditor'] == '' ? {} : eval('(' + attrs['torusExpressionEditor'] + ')');

            if (!params['resize'])
                params['resize'] = true;

            var $originalTextarea = $(element);

            var editorId = $originalTextarea.attr('id') + nextUniqueEditorId + '_expreditor';
            nextUniqueEditorId++;

            $originalTextarea.attr('data-expressioneditorid', editorId);
            $originalTextarea.hide();

            $originalTextarea.before(
                '<div data-expressioneditor="' + editorId + '" '
                + (params['resize'] ? ('data-resize="' + params['resize'] + '" ') : '')
                + (params['onupdate'] ? ('data-onupdate="' + params['onupdate'] + '" ') : '')
                + (params['language'] ? ('data-language="' + params['language'] + '" ') : '')
                + 'class="torus-expressioneditor"></div>');
        }
    };
});

torusDirectives.directive("contenteditable", function () {
    return {
        restrict: "A",
        link: function (scope, element, attrs) {
            var ngModel = angular.element(element).controller('ngModel');

            if (!ngModel)
                return;

            function read() {
                ngModel.$setViewValue(element.html());
            }

            ngModel.$render = function () {
                element.html(ngModel.$viewValue || "");
            };

            element.bind("blur keyup change", function () {
                scope.$apply(read);
            });
        }
    };
});

torusDirectives.directive('convertToNumber', function () {
    return {
        priority: 900,
        require: 'ngModel',
        link: function (scope, element, attrs, ngModel) {
            ngModel.$parsers.push(function (val) {
                return val != null ? parseFloat(val) : null;
            });
            ngModel.$formatters.push(function (val) {
                return val != null ? '' + val : null;
            });
        }
    };
});

torusDirectives.directive('forceNumber', function () {
    return {
        priority: 900,
        require: 'ngModel',
        link: function (scope, element, attrs, ngModel) {
            ngModel.$parsers.push(function (val) {
                return val != null ? parseFloat(val) : null;
            });
            ngModel.$formatters.push(function (val) {
                return val != null ? parseFloat(val) : null;
            });
        }
    };
});

torusDirectives.directive('convertToBoolean', function () {
    return {
        priority: 900,
        require: 'ngModel',
        link: function (scope, element, attrs, ngModel) {
            ngModel.$parsers.push(function (val) {
                return val != null && ('' + val).toLowerCase() === 'true' ? true : false;
            });
            ngModel.$formatters.push(function (val) {
                return val != null ? '' + val : null;
            });
        }
    };
});

torusDirectives.directive('forceBool', function () {
    return {
        priority: 900,
        require: 'ngModel',
        link: function (scope, element, attrs, ngModel) {
            ngModel.$parsers.push(function (val) {
                return val != null && ('' + val).toLowerCase() === 'true' ? true : false;
            });
            ngModel.$formatters.push(function (val) {
                return val != null && ('' + val).toLowerCase() === 'true' ? true : false;
            });
        }
    };
});

var convertToStringDirective = function () {
    return {
        priority: 900,
        require: 'ngModel',
        link: function (scope, element, attrs, ngModel) {
            ngModel.$parsers.push(function (val) {
                debugger;
                return val != null ? '' + val : null;
            });
            ngModel.$formatters.push(function (val) {
                debugger;
                return val != null ? '' + val : null;
            });
        }
    };
};

torusDirectives.directive('convertToString', convertToStringDirective);
torusDirectives.directive('convertToText', convertToStringDirective);

torusDirectives.directive('torusJsFileDownload', function () {
    return {
        restrict: 'A',
        require: '?ngModel',
        link: function (scope, element, attrs, ngModel) {
            if (ngModel) {
                var parameters = attrs['torusJsFileDownload'];

                if (parameters.length > 0 && parameters[0] == '{')
                    parameters = eval('('+parameters+')');
                else
                if (parameters == 'json')
                    parameters = { type: 'json' };
                else
                if (parameters == 'base64')
                    parameters = { type: 'base64' };

                element.on('click', function () {
                    if ($(element).hasClass('disabled'))
                        return;
                  
                    var downloadEl = document.createElement('a');
                 
                    var filename = iNoU(parameters.name) || parameters.name === '' ? String(Math.random()) : parameters.name;
                    var data = ngModel.$modelValue;

                    if (parameters.type === 'json')
                        data = encodeURIComponent(JSON.stringify(data));
                    
                    if (parameters.type === 'base64')
                        data = 'data:text/plain;base64,' + data;
                    else
                        data = 'data:text/plain;charset=utf-8,' + data;

                    downloadEl.setAttribute('href', data);
                    downloadEl.setAttribute('download', filename);

                    downloadEl.style.display = 'none';
                    document.body.appendChild(downloadEl);

                    downloadEl.click();

                    document.body.removeChild(downloadEl);
                });
            }
        }
    }
});


torusDirectives.directive('torusFileInput', function () {
    return {
        restrict: 'A',
        require: '?ngModel',
        link: function (scope, element, attrs, ngModel) {
            if (ngModel && element[0].tagName === 'INPUT' && attrs['type'] === 'file') {
                element.on('change', function () {
                    var input = this;

                    if (input.files.length > 0) {
                        var parameters = attrs['torusFileInput'];

                        if (parameters.length > 0 && parameters[0] == '{')
                            parameters = eval('('+parameters+')');
                        else
                        if (parameters == 'read')
                            parameters = { read: true };
                        else
                        if (parameters == 'json')
                            parameters = { read: 'json' };
                        else
                        if (parameters == 'base64')
                            parameters = { read: 'base64' };

                        if (parameters.read !== undefined) {
                            var reader = new FileReader();

                            reader.onloadend = function () {
                                var data = reader.result;

                                if (parameters.read === 'json')
                                    data = JSON.parse(data);
                                else
                                if (parameters.read === 'base64')
                                    data = data.substr(data.indexOf(';base64,') + 8);

                                ngModel.$setViewValue(data);
                            };

                            if (parameters.read === 'base64')
                                reader.readAsDataURL(input.files[0]);
                            else
                                reader.readAsText(input.files[0]);
                        } else {
                            ngModel.$setViewValue(input.files[0]);
                        }
                    }
                });
            }
        }
    }
});

torusDirectives.directive("ngTorusExpressionToolbarFilter", ['$compile', '$parse', '$timeout', function ($compile, $parse, $timeout) {

    return {
        restrict: "E",

        transclude: true,

        scope: {
            scope: '='
        },

        template: 
            '<div class="input-group">'+
            '<input type="text" id="expressionMenuFilterInput" class="form-control exprsearch-control" ng-model="filter" ng-change="filterChanged" stop-propagation="click">' +
            '<div class="input-group-addon" stop-propagation="click">' +
            '<i class="input-group-text fa fa-filter"></i>'+
            '</div>'+
            '</div>',
        
        compile: function (element, attrs, $contents) {
            var groups = _.filter($contents({}), function (g) { return g.tagName === 'GROUP'; });

            return {
                pre: function ($scope, $element) {
                    $scope.filter = '';

                    $scope.groups = [];

                    _.forEach(groups, function (g) {
                        var $g = $(g);

                        $scope.groups.push({
                            modelName: $g.attr('model'),
                            listModel: $parse($g.attr('model')),
                            itemTitleModel: $parse($g.attr('itemTitle'))
                        });

                        var scopedObjectName = attrs['scope'];

                        var $ownerScope = $scope.$parent;
                        while (!$ownerScope.hasOwnProperty(scopedObjectName) && $ownerScope)
                            $ownerScope = $ownerScope.$parent;

                        $scope.scope = $ownerScope[scopedObjectName];

                        var collectionModel = scopedObjectName + '.' + $g.attr('model');
                        $ownerScope.$watch(collectionModel, function () {
                            $scope.filterChanged();
                        });
                    });

                    $scope.applyFilterToGroups = function () {
                        var pattern = new RegExp($scope.filter, 'ig');

                        _.forEach($scope.groups, function (g) {
                            var items = g.listModel($scope.scope);

                            if (iNoU(items)) {
                                items = [];
                                g.listModel.assign($scope.scope, items);
                            }

                            if (!$scope.filter || $scope.filter === '') {
                                items.anyVisible = items.length > 0;

                                _.forEach(items, function (i) {
                                    i.visible = true;
                                    i.highlightedTitle = g.itemTitleModel(i);
                                });
                            }
                            else {
                                items.anyVisible = false;

                                _.forEach(items, function (i) {
                                    var match = false;

                                    i.highlightedTitle = g.itemTitleModel(i).replace(pattern, function (s) {
                                        match = true;
                                        return '<strong>' + s + '</strong>';
                                    });

                                    i.visible = match;

                                    if (match)
                                        items.anyVisible = true;
                                });
                            }
                        });
                    };

                    $scope.filterChanged = _.debounce(function () {
                        $scope.$apply(function () {
                            $scope.applyFilterToGroups();
                        });
                    }, 300);

                    $scope.$watch('filter', function () {
                        $scope.filter = $scope.filter.replace(/[^a-z0-9_\s]/ig, '');
                        $scope.filterChanged();
                    });
                },

                post: function ($scope) {
                    $timeout(function () {
                        $scope.filterChanged();
                    }, 100);
                }
            };
        }
    };
}]);

torusDirectives.directive("owlCarousel", function () {
    return {
        restrict: 'E',
        transclude: false,
        link: function (scope) {
            scope.initCarousel = function (element) {
                // provide any default options you want
                var defaultOptions = {};
                var customOptions = scope.$eval($(element).attr('data-options'));
                // combine the two options objects
                for (var key in customOptions) {
                    defaultOptions[key] = customOptions[key];
                }
                // init carousel
                var curOwl = $(element).data('owlCarousel');
                if (!angular.isDefined(curOwl)) {
                    $(element).owlCarousel(defaultOptions);
                }
                scope.cnt++;
            };
        }
    };
}).directive('owlCarouselItem', [
    function () {
        return {
            restrict: 'A',
            transclude: false,
            link: function (scope, element) {
                // wait for the last item in the ng-repeat then call init
                if (scope.$last) {
                    scope.initCarousel(element.parent());
                }
            }
        };
    }
    ]);

function getAbsoluteUrl(url) {
    var base = document.createElement('BASE');
    base.href = url;
    return base.href;
}

torusDirectives.component('torusImage', {
    template: '<ng-transclude ng-if="loaded && !markup" ng-transclude-slot="fallback"></ng-transclude>'
            + '<ng-bind-html ng-if="loaded && markup" ng-bind-html="markup"></ng-bind-html>',

    transclude: {
        fallback: '?img'
    },

    bindings: {
        fileGuid: '<',
        imgClass: '<',
        imgStyle: '<'
    },

    controller: ['$scope', '$sce', '$transclude', '$element', '$timeout', 'imageMarkupCache', function ($scope, $sce, $transclude, $element, $timeout, imageMarkupCache) {
        var $ctrl = this;

        $scope.loaded = false;
        $scope.markup = null;

        $scope.setErrorMarkup = function () {
            if ($transclude.isSlotFilled('fallback')) {
                $scope.markup = null;
            }
            else {
                $scope.markup = $sce.trustAsHtml('');
            }
        };

        if (!$ctrl.fileGuid || $ctrl.fileGuid === '') {
            $scope.setErrorMarkup();
            $scope.loaded = true;
        } else {
            imageMarkupCache.getMarkup($ctrl.fileGuid, function (markup) {
                if (markup) {
                    $scope.markup = $sce.trustAsHtml(markup);

                    if ($ctrl.imgClass || $ctrl.imgStyle) {
                        $element.addClass('hidden');
                        $timeout(function () {
                            $element.find('img').addClass($ctrl.imgClass);
                            $element.find('img').attr('style', $ctrl.imgStyle);
                            $element.find('svg').addClass($ctrl.imgClass);
                            $element.find('svg').attr('style', $ctrl.imgStyle);
                            $element.removeClass('hidden');
                        });
                    }
                }
                else {
                    $scope.setErrorMarkup();
                }

                $scope.loaded = true;
            });
        }
    }]
});
;
var notifications = window.notifications || {};
var torusFactories = angular.module('torus.factories', []);

torusFactories.factory('torusCache', ['$angularCacheFactory', '$cookieStore', function ($angularCacheFactory, $cookieStore) {

    // Configure the angular cache module

    var cookieStorage = {
        getItem: function (key) {
            return angular.fromJson($cookieStore.get(key));
        },
        setItem: function (key, value) {
            $cookieStore.put(key, angular.toJson(value));
        },
        removeItem: function (key) {
            $cookieStore.remove(key);
        }
    };

    var options = {
        storageMode: 'localStorage'
    };

    try {
        // use cookies to store cache values if localstorage is not available
        if (!window.localStorage) {
            options.storageImpl = cookieStorage;
        }
    }
    catch (err) {
        options.storageImpl = cookieStorage;
    }

    var sessionOptions = {
        storageMode: 'sessionStorage'
    };

    try {
        // use cookies to store cache values if localstorage is not available
        if (!window.sessionStorage) {
            sessionOptions.storageImpl = cookieStorage;
        }
    }
    catch (err) {
        sessionOptions.storageImpl = cookieStorage;
    }

    var torusCache = $angularCacheFactory('torusCache', options);
    var torusSessionCache = $angularCacheFactory('torusSessionCache', sessionOptions);

    var cacheObj = {
        get: function (key) {
            return torusCache.get(key);
        },
        set: function (key, value, maxAge) {
            options.maxAge = maxAge;
            options.deleteOnExpire = isNullOrUndefined(maxAge) ? 'none' : 'passive';
            torusCache.put(key, value, options);
        },
        session: {
            get: function (key) {
                return torusSessionCache.get(key);
            },
            set: function (key, value, maxAge) {
                options.maxAge = maxAge;
                options.deleteOnExpire = isNullOrUndefined(maxAge) ? 'none' : 'passive';
                torusSessionCache.put(key, value, options);
            },
            remove: function (key) {
                torusSessionCache.remove(key);
            }
        },
        remove: function (key) {
            torusCache.remove(key);
        }
    };

    return cacheObj;

}]);

torusFactories.factory('torusApiRequestInterceptor', ['$q', '$rootScope', '$location', '$templateCache', 'suppressRequestEvents',
    function ($q, $rootScope, $location, $templateCache, suppressRequestEvents) {

        // save path to document cookie (used for return urls on login)
        // Do it in construction so we can capture the path before an unauthorised redirect occurs
        switch ($location.path().toLowerCase()) {
            case "/login": case "/register": case "/forgotpassword": case "/sessionlogout":
                // do nothing.  We don't need to capture these views
                break;
            default:
                document.cookie = 'returnPath=' + $location.path() + ';path=/;';
                break;
        }

        return {
            request: function (request) {
                //console.log(suppressRequestEvents.suppress);
                if (!suppressRequestEvents.suppress) {
                    $rootScope.$broadcast('requestStart');
                }

                if (request.url.indexOf('/api/') === 0) {
                    if (webapi.useProxy) {

                        var headers = {};
                        if (!isNullOrUndefined(request.headers['Authorisation'])) {
                            headers['Authorisation'] = request.headers['Authorisation'];
                        }

                        if (!isNullOrUndefined(request.headers['TorusCaptchaToken'])) {
                            headers['TorusCaptchaToken'] = request.headers['TorusCaptchaToken'];
                        }

                        if (!isNullOrUndefined(request.headers['If-None-Match'])) {
                            headers['If-None-Match'] = request.headers['If-None-Match'];
                        }

                        if (request.url.indexOf('#') !== -1) {
                            request.url = request.url.replace(/#/g, '%23');
                        }

                        var proxyData = { httpMethod: request.method, uri: request.url, postData: isNullOrUndefined(request.data) ? '' : JSON.stringify(request.data), headers: headers };

                        request.url = '/webapiproxy/post';
                        request.headers["Content-Type"] = "application/json;charset=utf-8";
                        request.data = proxyData;
                        request.method = 'POST';
                    } else {
                        request.headers.Authorization = 'Bearer ' + webapi.accessToken;
                        request.url = webapi.url + request.url;
                    }

                }

                return $q.when(request);
            },

            response: function (response) {
                if (!suppressRequestEvents.suppress) {
                    $rootScope.$broadcast('requestEnd');
                }
                return $q.when(response);
            },

            responseError: function (rejection) {
                if (!suppressRequestEvents.suppress) {
                    $rootScope.$broadcast('requestEnd');
                }
                return $q.reject(rejection);
            }
        };
    }]);

torusFactories.factory('torusUnauthorisedInterceptor', ['$q', '$injector', 'gritterService', '$timeout', 'suppressRequestEvents', function ($q, $injector, gritterService, $timeout, suppressRequestEvents) {
    return {
        responseError: function (rejection) {
            if (!rejection.config || !rejection.config.$$suppressRedirects) {
                if (rejection.status === 401) {
                    // User is not authenticated so reload page.  MVC will catch and redirect to login
                    gritterService.addGritter("btn-danger", torusFactoryResources.txtGritterRequestNotCompleted, torusFactoryResources.txtGritterLoginAgain, false);
                    $timeout(function () {
                        window.location = '/account/logout'; // --> alert("stop"); // <-- added this so if wish to catch cause in dev tools of the 403
                        //window.location.reload();
                        return $q;
                    }, 3000);
                }

                if (rejection.status === 403) {
                    // User is authenticated but does not have permission to the view.  Redirect to access denied page
                    window.location = '/error/accessdenied'; // --> alert("stop"); // <-- added this so if wish to catch cause in dev tools of the 403
                    return $q;
                }

                if (rejection.status === 440) {
                    // User is authenticated but does not have permission to the view.  Redirect to access denied page
                    window.location = '/account#/sessionlogout';
                    return $q;
                }
            }

            return $q.reject(rejection);
        }
    };
}]);

torusFactories.factory("gritterService", ['$q', function ($q) {
    return {
        addGritter: function (gClassName, gTitle, gText, gSticky, gTime, gFadeOutSpeed) {
            var dText = torusFactoryResources.txtGritterExpiredInactivity;
            return $.gritter.add({ class_name: gClassName, title: gTitle, text: gText !== "" ? gText : dText, sticky: gSticky, time: gTime, fade_out_speed: gFadeOutSpeed });
        },
        removeGritter: function (id, params) {
            $.gritter.remove(id, params);
        },
        removeAll: function () {
            var deferred = $q.defer();
            $.gritter.removeAll({
                after_close: function () {
                    deferred.resolve();
                }
            });
            return deferred.promise;
        }
    };
}]);

torusFactories.factory("torusAcceptCookiesEu", ['$rootScope', '$http', '$location', 'gritterService', function ($rootScope, $http, $location, gritterService) { // angular has ngCookies but does not allow expiry/secure settings...
    return {
        acceptCookies: function (cookiename, cookieexpiredays) {
            var data = { cookieName: cookiename, cookieExpireDays: cookieexpiredays }; // TTL in days
            $http.post('/set-cookies/set-eu-accept', data).
                success(function (d) {
                    if (d.acceptSet) {
                        //gritterService.addGritter("btn-success", "Accepted", "Thank you.", false);
                        $("div#cookieaccept").slideUp(); // then hide the message
                    } else {
                        gritterService.addGritter("btn-danger", cookieSetResources.txtFailTitle, String.format(cookieSetResources.txtFailTitle, d.cookieSetStatus), false);
                    }
                }).
                error(function (d) {
                    gritterService.addGritter("btn-danger", cookieSetResources.txtFailTitle, String.format(cookieSetResources.txtFailTitle, d.cookieSetStatus), false);
                });
        }
    };
}]);

torusFactories.factory("torusVersionUpdateCookie", ['$rootScope', '$http', '$location', 'gritterService', function ($rootScope, $http, $location, gritterService) { // angular has ngCookies but does not allow expiry/secure settings...
    return {
        acceptVersionUpdate: function (cookiename, cookievalue, cookieexpiredays) {
            var data = { cookieName: cookiename, cookieValue: cookievalue, cookieExpireDays: 365 }; // TTL in days
            $http.post('/set-cookies/set-version-update', data).
                success(function (d) {
                    if (d.acceptSet) {
                        $("div#torusversionupdateaccept").slideUp(); // then hide the message
                    } else {
                        gritterService.addGritter("btn-danger", cookieSetResources.txtFailTitle, String.format(cookieSetResources.txtFailTitle, d.cookieSetStatus), false);
                    }
                }).
                error(function (d) {
                    gritterService.addGritter("btn-danger", cookieSetResources.txtFailTitle, String.format(cookieSetResources.txtFailTitle, d.cookieSetStatus), false);
                });
        }
    };
}]);

torusFactories.factory("torusPrivacyPolicyCookie", ['$rootScope', '$http', '$location', 'gritterService', function ($rootScope, $http, $location, gritterService) { // angular has ngCookies but does not allow expiry/secure settings...
    return {
        acceptPolicy: function (cookiename, cookievalue, cookieexpiredays) {
            var data = { cookieName: cookiename, cookieValue: cookievalue, cookieExpireDays: 730 }; // TTL in days
            $http.post('/set-cookies/set-policy-acceptance', data).
                success(function (d) {
                    if (d.acceptSet) {
                        $("div#torusprivacypolicy").slideUp(); // then hide the message
                    } else {
                        gritterService.addGritter("btn-danger", cookieSetResources.txtFailTitle, String.format(cookieSetResources.txtFailTitle, d.cookieSetStatus), false);
                    }
                }).
                error(function (d) {
                    gritterService.addGritter("btn-danger", cookieSetResources.txtFailTitle, String.format(cookieSetResources.txtFailTitle, d.cookieSetStatus), false);
                });
        }
    };
}]);

torusFactories.factory("torusSetSensitiveValuesDisplayCookie", ['$rootScope', '$http', 'gritterService', function ($rootScope, $http, gritterService) {
    return {
        setSensitiveValuesDisplay: function (cookiename, cookievalue, cookieexpiredays) {
            var data = { cookieName: cookiename, cookieValue: cookievalue, cookieExpireDays: 365 }; // TTL in days
            $http.post('/set-cookies/set-sensitive-values-hideshow', data).
                success(function (d) {
                    var yn = cookievalue ? cookieSetResources.txtSensitiveValuesNoLonger : "";
                    gritterService.addGritter("btn-success", cookieSetResources.txtSensitiveValuesSuccessTitle, String.format(cookieSetResources.txtSensitiveValuesSuccessMessage, yn), false, 1000, 100);
                }).
                error(function (d) {
                    gritterService.addGritter("btn-danger", cookieSetResources.txtFailTitle, String.format(cookieSetResources.txtFailTitle, d.cookieSetStatus), false);
                });
        }
    };
}]);

torusFactories.factory("passwordStrength", function () {
    function scorePassword(pass) {
        var score = 0;
        var setSrc = !iNoU(settings.minPasswordLength) ? settings : settingsLogin;
        if (!pass || pass.length < setSrc.minPasswordLength)
            return score;

        // point for each of these...
        var variations = {
            digits: /\d/.test(pass),
            lower: /[a-z]/.test(pass),
            upper: /[A-Z]/.test(pass),
            nonWords: /[\W_]/.test(pass),
            charRepeater: /(.)\1{2,}/.test(pass)
        };

        var variationCount = 0;

        if (pass.length > 10)
            variationCount++;

        if (variations.digits === true)
            variationCount++;

        if (variations.lower === true)
            variationCount++;

        if (variations.upper === true)
            variationCount++;

        if (variations.nonWords === true)
            variationCount++;

        // Decrement strength if character repetions exist (more then 2 characters repeated after each other)
        if (variations.charRepeater === true)
            variationCount--;

        switch (variationCount) {
            case 5:
                return 2; // all conditions met = strong password
            case 3:
            case 4: // 3 to 4 conditions met = medium strength password
                return 1;
            default: // everything else is low strength
                return 0;
        }
    }
    var className = ['label-danger', 'label-warning', 'label-success'];
    var resSrc = !iNoU(resources.passwordStrengthLow) ? resources : resourcesLogin;
    var strengthTitle = [resSrc.passwordStrengthLow, resSrc.passwordStrengthMed, resSrc.passwordStrengthHigh];

    return {
        getStrength: function (p) {
            var idx = scorePassword(p);
            return {
                className: className[idx],
                title: strengthTitle[idx],
                index: idx
            };
        }
    };
});

torusFactories.factory("torusPageTitleService", ['$rootScope', function ($rootScope) {
    return {
        enableTitle: function (enabled) {
            $rootScope.$broadcast('enablePageTitle', enabled);
        },
        enableSubTitle: function (enabled) {
            $rootScope.$broadcast('enablePageSubTitle', enabled);
        },
        changeTitle: function (title) {
            $rootScope.$broadcast('changePageTitle', title);
        },
        changeSubTitle: function (subTitle) {
            $rootScope.$broadcast('changePageSubTitle', subTitle);
        },
        hideTitle: function () {
            $rootScope.$broadcast('hidePageTitle');
        },
        showTitle: function () {
            $rootScope.$broadcast('showPageTitle');
        }
    };
}]);

torusFactories.factory("torusOData", function () {
    return {
        format: function (params, filterExpressions) {

            var top = params.count;
            var skip = (params.page - 1) * params.count;
            var andOr = params.filterUseOr;
            var andOrTxt = andOr ? "or" : "and";

            var urlEncode = function (s) {
                var se = s.replace(/%/g, "%25").replace(/&/g, "%26").replace(/"/g, "%22").replace(/\?/g, "%3F").replace(/'/g, "''"); // encode up...
                return se;
            };

            var filter = '';
            for (var prop in params.filter) {
                if (params.filter[prop] !== '') {
                    if (!isNullOrUndefined(filterExpressions) && !isNullOrUndefined(filterExpressions[prop])) {
                        filter += " " + andOrTxt + " " + String.format(filterExpressions[prop], prop, params.filter[prop]);
                    } else {
                        if (prop.indexOf(" or ") === -1) {
                            var value = params.filter[prop];
                            if (typeof value === 'number') {
                                filter += String.format(' {0} {1} eq {2}', andOrTxt, value, prop);
                            }
                            else {
                                filter += String.format(" {0} substringof(tolower('{1}'),tolower({2}))", andOrTxt, urlEncode(params.filter[prop]), prop);
                            }
                        } else // prop itself contains spaced 'or' so need to sort out...
                        {
                            // andOr = true;
                            var propSplit = prop.split(" or "); // sorts out each side...
                            if (propSplit.length >= 1) {
                                var value = params.filter[prop];
                                if (typeof value === 'number') {
                                    filter += String.format(' {0} {1} eq {2}', andOrTxt, value, propSplit[0]);
                                }
                                else {
                                    filter += String.format(" {0} (substringof(tolower('{1}'),tolower({2}))", andOrTxt, urlEncode(params.filter[prop]), propSplit[0]);
                                }
                            }
                            for (var i = 1; i < propSplit.length; i++) {
                                filter += " or ";

                                if (i === 0) {
                                    filter += "(";
                                }
                                var value = params.filter[prop];
                                if (typeof value === 'number') {
                                    filter += String.format('{1} eq {2}', andOrTxt, value, propSplit[i]);
                                }
                                else {
                                    filter += String.format("substringof(tolower('{0}'),tolower({1}))", urlEncode(params.filter[prop]), propSplit[i]);
                                }
                            }
                            filter += ")";
                        }
                    }
                }
            }

            if (filter !== '') {
                filter = '&$filter=' + filter.substring(andOr ? 4 : 5).trim();
            }

            var orderBy = '';
            for (prop in params.sorting) {
                sortItems = prop.split(',');
                for (i = 0; i < sortItems.length; i++) { // added to properly support multiple column request sorting from a single column
                    if (params.sorting[prop] !== '') {
                        orderBy += String.format(",{0} {1}", sortItems[i], params.sorting[prop]);
                    }
                }
            }

            if (orderBy !== '') {
                orderBy = '&$orderby=' + orderBy.substring(1);
            }

            var oData = "?$inlinecount=allpages" + filter + orderBy + "&$top=" + top + "&$skip=" + skip;
            return oData;
        }
    };
});

torusFactories.factory("torusNavBarService", ['$rootScope', '$http', 'gritterService', '$q', function ($rootScope, $http, gritterService, $q) {

    // factory API calls
    return {
        notificationCount: function () {

            var deferred = $q.defer();

            $http.get('/api/useraccount/notifications/unassigned/count', null).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function () {
                    deferred.reject();
                });

            return deferred.promise;
        },

        taskCount: function () {

            var deferred = $q.defer();

            $http.get('/api/useraccount/tasks/assigned/count', null).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function () {
                    deferred.reject();
                });

            return deferred.promise;
        },

        adminMessagingMessageCount: function (userId, allOrUser) {

            var deferred = $q.defer();

            $http.get('/api/useraccount/messaging/' + (allOrUser ? 'unassigned' : 'admin') + '/all/count/' + userId, null).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function () {
                    deferred.reject();
                });

            return deferred.promise;
        },
        adminDownloadsCount: function (userId) {

            var deferred = $q.defer();

            $http.get('/api/useraccount/downloads/summary/' + userId, null).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function () {
                    deferred.reject();
                });

            return deferred.promise;
        },
        getAvatar: function (userId) {

            var deferred = $q.defer();

            $http.get('/api/useraccount/avatar/get/' + userId, null).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function () {
                    deferred.reject();
                });

            return deferred.promise;
        },
        adminChangeNotesCount: function (userId, tenantId, selUserId, jsRefId, cPath, iContextId) {

            var deferred = $q.defer();

            var dto = { currentPrincipalUaId: userId, tenantId: tenantId, userAccountId: selUserId, jsRefId: jsRefId, path: cPath, contextId: iContextId };
            $http.post('/api/useraccount/changenotes/count/', dto).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function () {
                    deferred.reject();
                });

            return deferred.promise;
        },
        getAdminChangeNotes: function (userId, selTenantId, selUserId, jsRefId, cPath, iContextId, oData) {

            var deferred = $q.defer();

            var dto = { currentPrincipalUaId: userId, tenantId: selTenantId, userAccountId: selUserId, jsRefId: jsRefId, path: cPath, contextId: iContextId };
            $http.post('/api/admin/change-notes/get' + oData, dto).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function () {
                    deferred.reject();
                });

            return deferred.promise;
        },
        setAdminChangeNotes: function (userId, selTenantId, selUserId, jsRefId, cPath, iContextId, sNoteText) {

            var deferred = $q.defer();

            var dto = { currentPrincipalUaId: userId, tenantId: selTenantId, userAccountId: selUserId, jsRefId: jsRefId, path: cPath, contextId: iContextId, noteText: sNoteText };
            $http.post('/api/admin/change-notes/set', dto).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function () {
                    deferred.reject();
                });

            return deferred.promise;
        },
        getKbsArticleForOverlay: function (ref) {

            var deferred = $q.defer();

            $http.get('/api/admin/kbs/article/getrev/-1/get/ref' + ref, null).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function () {
                    deferred.reject();
                });

            return deferred.promise;
        }
    };

}]);

torusFactories.factory("torusMenuService", ['$rootScope', '$http', 'gritterService', '$q', 'torusCache', function ($rootScope, $http, gritterService, $q, torusCache) {

    // factory API calls
    return {

        $getCachedValue: function (key) {
            try {
                return JSON.parse(torusCache.get(key));
            }
            catch (err) {
                return null;
            }
        },

        $setCachedValue: function (key, version, value) {
            try {
                torusCache.set(key, JSON.stringify({ version: version, value: value }));
            }
            catch (err) {
                //
            }
        },

        $processMenuItems: function (userMenu, visibilityFlags, indexRef, menuItems) {
            function sumItems(menuItems) {
                if (!menuItems)
                    return 0;

                var count = menuItems.length;

                for (var i = 0; i < menuItems.length; ++i)
                    count += sumItems(menuItems[i].menuSubItems);

                return count;
            }

            var $service = this;

            if (iNoU(menuItems))
                return menuItems;

            var newMenuItems = [];

            for (var i = 0; i < menuItems.length; ++i) {
                var flagPos = ~~(indexRef.index / 8); // ~~ enforce integer
                var flagBit = 1 << indexRef.index % 8;

                var visible = (visibilityFlags[flagPos] & flagBit) !== 0;

                var menuItem = menuItems[i];

                if (visible) {
                    newMenuItems.push(menuItem);

                    var userTitle = userMenu.titles[indexRef.index];
                    var userDesc = userMenu.descriptions[indexRef.index];

                    if (!isNullOrUndefined(userTitle))
                        menuItem.title = userTitle;

                    if (!isNullOrUndefined(userDesc))
                        menuItem.description = userDesc;

                    indexRef.index++;

                    menuItem.menuSubItems = $service.$processMenuItems(userMenu, visibilityFlags, indexRef, menuItem.menuSubItems);
                } else {
                    indexRef.index++;

                    indexRef.index += sumItems(menuItem.menuSubItems);
                }
            }

            return newMenuItems;
        },

        $userMenuToMenu: function (userMenu) {
            var $service = this;

            if (!userMenu.titles)
                userMenu.titles = {};

            if (!userMenu.descriptions)
                userMenu.descriptions = {};

            var visibilityFlags = [];

            for (var i = 0; i < userMenu.visibilityFlags.length; i += 2) {
                var str = userMenu.visibilityFlags.substr(i, 2);
                var num = parseInt(str, 16);
                visibilityFlags.push(num);
            }

            var menu = userMenu.menu.value;

            var indexRef = { index: 0 };

            menu.menuItems = $service.$processMenuItems(userMenu, visibilityFlags, indexRef, menu.menuItems, "");

            return menu;
        },

        getAdminMenu: function () {
            var $service = this;

            var cachedMenu = $service.$getCachedValue('Torus.AdminMenu');

            var deferred = $q.defer();

            $http.get('/menu/adminmenu' + (cachedMenu ? '/' + cachedMenu.version : ''), null).
                success(function (data) {
                    if (cachedMenu && data.menu.value === null) {
                        data.menu.value = cachedMenu.value;
                    } else {
                        $service.$setCachedValue('Torus.AdminMenu', data.menu.version, data.menu.value);
                    }

                    deferred.resolve($service.$userMenuToMenu(data));
                }).
                error(function () { // an error in this scenario is not a failed login, but that some form of exception has occured.
                    deferred.reject();
                });

            return deferred.promise;
        },

        getClientMenu: function () {
            var $service = this;

            var cachedMenu = $service.$getCachedValue('Torus.ClientMenu');

            var deferred = $q.defer();

            $http.get('/menu/clientmenu' + (cachedMenu ? '/' + cachedMenu.version : ''), null).
                success(function (data) {
                    if (cachedMenu && data.menu.value === null) {
                        data.menu.value = cachedMenu.value;
                    } else {
                        $service.$setCachedValue('Torus.ClientMenu', data.menu.version, data.menu.value);
                    }

                    deferred.resolve($service.$userMenuToMenu(data));
                }).
                error(function () { // an error in this scenario is not a failed login, but that some form of exception has occured.
                    deferred.reject();
                });

            return deferred.promise;
        },

        getClientMenuUserMsgOpenCount: function (tenantId, userId) {
            var deferred = $q.defer();
            $http.get('/api/messaging/open-count/via-sp/' + tenantId + '/' + userId, null).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function () { // an error in this scenario is not a failed login, but that some form of exception has occured.
                    deferred.reject();
                });
            return deferred.promise;
        }
    };
}]);

torusFactories.factory("torusCookiePersistor", ['$cookies', function ($cookies) {

    return {
        tryGetDataFromCookieCache: function (data) {

            if (iNoU(data)) { throw "have you declared $scope.data = new Array(); in your controller?"; }

            var fromCookie = angular.fromJson($cookies.data);
            for (item in fromCookie) {

                data[item] = fromCookie[item];
            }
        },
        persistDataToCookieCache: function (data) {

            var cookieArray = {};

            var currentCookie = {};
            if (!iNoU($cookies.data)) {
                currentCookie = angular.fromJson($cookies.data);
            }

            for (item in currentCookie) {
                cookieArray[item] = data[item];
            }

            for (item in data) {
                cookieArray[item] = data[item];
            }

            $cookies.data = angular.toJson(cookieArray);
        }
    };

}]);

torusFactories.factory("torusCrypto", function () {

    return {
        hash: function (message) {
            var hash = CryptoJS.SHA256(message);
            return hash.toString().toUpperCase();
        },
        hmac: function (message, key) {
            var hmac = CryptoJS.HmacSHA512(message, key);
            return hmac.toString().toUpperCase();
        }
    };

});

torusFactories.factory('imageService', ['$rootScope', '$http', '$location', 'gritterService', '$q', function ($rootScope, $http, $location, gritterService, $q) {

    // factory API calls
    return {

        getImagesList: function (imageType, tenant, oData) {

            var deferred = $q.defer();

            var url = '/api/admin/cm/files/images/list/' + imageType + '/' + (isNullOrUndefined(tenant) ? null : tenant);

            oData = oData || "";
            url += oData;

            $http.get(url).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function (data) { // error, for any reason, needs handling and browser redirected.
                    gritterService.addGritter("btn-danger", notifications.dataRetrievalFailure, data.message, false);
                    deferred.reject();
                });
            return deferred.promise;
        },

        getImage: function (imageType, tenant, imageName) {

            var deferred = $q.defer();

            var url = '/api/admin/cm/files/images/get/' + imageType + '/' + (isNullOrUndefined(tenant) ? null : tenant) + '/' + imageName;

            $http.get(url).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function () { // error, for any reason, needs handling and browser redirected.
                    //gritterService.addGritter("btn-danger", notifications.dataRetrievalFailure, data.message, false);
                    deferred.reject();
                });
            return deferred.promise;
        },

        uploadImage: function () {

            $http.post('/file/upload/admin/store'). // save to disk as admin via this path
                success(function () {
                    $rootScope.working = '';
                    $location.path('/home');
                }).
                error(function (data) {
                    $rootScope.working = '';
                    gritterService.addGritter("btn-danger", notifications.dataUpdateFailure, data.message, false);
                });
        },

        deleteImage: function (fileguid) {

            var deferred = $q.defer();
            var json = { fileGuid: fileguid };

            $http.get('/file/delete/' + fileguid, json).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function (data) {
                    gritterService.addGritter("btn-danger", notifications.deleteFailTitle, data, false);
                    deferred.reject();
                });
            return deferred.promise;
        }

    };
}]);

torusFactories.factory('snippetsService', ['$rootScope', '$http', '$location', 'gritterService', '$q', function ($rootScope, $http, $location, gritterService, $q) {

    return {
        getSystemContentSnippetsList: function () {

            var deferred = $q.defer();

            $http.get('/api/admin/cm/snippets/list/get/?$orderby=Name', null).
                success(function (data, status, headers, config) {
                    deferred.resolve(data);
                }).
                error(function (data, status, headers, config) {
                    gritterService.addGritter("btn-danger", notifications.dataRetrievalFailure, data.message, false);
                    deferred.reject();
                });
            return deferred.promise;
        },
        getTenantSystemContentSnippetsList: function (tenantId, suppressRedirects) {

            var deferred = $q.defer();

            $http.get('/api/admin/tm/snippets/list/all/get/' + tenantId + '/?$orderby=Name', { $$suppressRedirects: suppressRedirects }).
                success(function (data, status, headers, config) {
                    deferred.resolve(data);
                }).
                error(function (data, status, headers, config) {
                    if (!suppressRedirects) {
                        gritterService.addGritter("btn-danger", notifications.dataRetrievalFailure, data.message, false);
                    }

                    deferred.reject();
                });
            return deferred.promise;
        }
    };
}]);

torusFactories.factory("signalRService", ['$rootScope', function ($rootScope) {

    return {
        proxy: null,
        initialize: function (addToNotificationCount, removeFromNotificationCount, refreshNotificationCount, addToTaskCount, removeFromTaskCount, refreshTaskCount) {
            //Getting the connection object
            connection = $.hubConnection();

            //Creating proxy
            this.proxy = connection.createHubProxy('notificationHub');

            //Starting connection
            connection.start();

            //Attaching a callback to handle addToNotificationCount client call
            this.proxy.on('addToNotificationCount', function () {
                $rootScope.$apply(function () {
                    addToNotificationCount();
                });
            });

            //Attaching a callback to handle removeFromNotificationCount client call
            this.proxy.on('removeFromNotificationCount', function () {
                $rootScope.$apply(function () {
                    removeFromNotificationCount();
                });
            });

            //Attaching a callback to handle refreshNotificationCount client call
            this.proxy.on('refreshNotificationCount', function () {
                $rootScope.$apply(function () {
                    refreshNotificationCount();
                });
            });

            //Attaching a callback to handle addToTaskCount client call
            this.proxy.on('addToTaskCount', function (taskCount) {
                $rootScope.$apply(function () {
                    addToTaskCount(taskCount);
                });
            });

            //Attaching a callback to handle removeFromTaskCount client call
            this.proxy.on('removeFromTaskCount', function (taskCount) {
                $rootScope.$apply(function () {
                    removeFromTaskCount(taskCount);
                });
            });

            //Attaching a callback to handle refreshAlertCount client call
            this.proxy.on('refreshTaskCount', function () {
                $rootScope.$apply(function () {
                    refreshTaskCount();
                });
            });
        }
    };
}]);

torusFactories.factory("torusPickListService", ['$rootScope', '$http', '$q', function ($rootScope, $http, $q) {

    // factory API calls
    return {

        getPickListOptions: function (tId, plt, l, odata) {

            var deferred = $q.defer();

            $http.get('/api/company/picklistvalues/list/get/' + tId + '/' + plt + '/' + l + odata).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function () { // an error in this scenario is not a failed login, but that some form of exception has occured.
                    deferred.reject();
                });

            return deferred.promise;
        },

        getIsPickListOptionUnique: function (tenantId, pickListTypeId, pickListOption) {

            var deferred = $q.defer();

            $http.post('/api/company/unique-picklistoption-check/get/' + tenantId + '/' + pickListTypeId, pickListOption).
                success(function (data, status, headers, config) {
                    deferred.resolve(data);
                }).
                error(function (data, status, headers, config) {
                    deferred.reject();
                });
            return deferred.promise;
        }
    };
}]);

torusApp.factory('selectedTenantService', function () {
    return {
        getSelectedTenantSubDomainName: function () {
            return isNullOrUndefined(session.selectedTenant) ? currentUser.tenant : session.selectedTenant.subDomainName;
        },
        getSelectedTenantId: function (forUser) {
            return isNullOrUndefined(session.selectedTenant) ? (forUser ? currentUser.tenantId : 1) : session.selectedTenant.id;
        },
        getSelectedTenantTheme: function () {
            return isNullOrUndefined(session.selectedTenant) ? settings.defaultTheme : session.selectedTenant.theme;
        }
    };
});

torusFactories.factory("torusBookmarkService", ['$rootScope', '$http', 'gritterService', '$q', function ($rootScope, $http, gritterService, $q) {

    // factory API calls
    return {
        getUserBookmarkStatus: function (userId, mvcPathSafe) {

            var deferred = $q.defer();
            $http.get('/api/admin/url-bookmark/status/' + mvcPathSafe + '/user/get/' + userId, null).
                success(function (data) {
                    deferred.resolve(data);
                }).
                error(function () {
                    deferred.reject();
                });

            return deferred.promise;
        },

        setUserBookmarkStatus: function (usrBookmark) {
            var data = usrBookmark; // one to one...
            var addDel = data.id === 0;
            var deferred = $q.defer();
            $http.post('/api/admin/url-bookmark/status/post', data).
                success(function (d) {
                    gritterService.addGritter("btn-success", addDel ? notificationsUBM.bookmarkAddedSuccessTitle : notificationsUBM.bookmarkRemovedSuccessTitle, addDel ? notificationsUBM.bookmarkAddedSuccessMessage : notificationsUBM.bookmarkRemovedSuccessMessage, false);
                    deferred.resolve(data);
                }).
                error(function (d) {
                    gritterService.addGritter("btn-danger", notificationsUBM.bookmarkAddedFailTitle, notificationsUBM.bookmarkAddedFailMessage, false);
                    deferred.resolve(data);
                });
            return deferred.promise;
        }
    };
}]);

torusApp.factory('importXmlService', ['$http', '$location', 'gritterService', '$q', function ($http, $location, gritterService, $q) {

    // factory API calls
    return {
        importXml: function (api, file) {
            var deferred = $q.defer();

            var fd = new FormData();
            fd.set("file", file);

            if (api[0] !== '/')
                api = '/' + api;

            $http.post('/system/importxml' + api, fd, {
                transformRequest: angular.identity,
                headers: {
                    'Content-Type': undefined
                }
            })
                .success(function () {
                    deferred.resolve();
                })
                .error(function (data) {
                    gritterService.addGritter("btn-danger", notifications.dataUpdateFailure, data.message, false);
                    deferred.reject();
                });

            return deferred.promise;
        },

        bindImportForm: function ($form, api, onSuccess, onError) {
            var self = this;

            $form.change(function () {
                var files = $form[0].files;

                if (files.length > 0) {
                    self.importXml(api, files[0]).then(function () {
                        gritterService.addGritter("btn-success", notifications.dataUpdateSuccess, 'Imported successfully', false);

                        if (onSuccess)
                            onSuccess();
                    }, function () {
                        gritterService.addGritter("btn-danger", notifications.dataUpdateFailure, data.message, false);

                        if (onError)
                            onError();
                    });
                }
            });
        }
    };
}]);

torusApp.factory('debounce', ['$rootScope', function ($rootScope) {
    return function (callback, interval, immediate) {
        return _.debounce(function () {
            var This = this;
            var args = arguments;

            if (!$rootScope.$$phase) {
                $rootScope.$apply(function () {
                    switch (args.length) {
                        case 0: callback.call(This); break;
                        case 1: callback.call(This, args[0]); break;
                        case 2: callback.call(This, args[0], args[1]); break;
                        case 3: callback.call(This, args[0], args[1], args[2]); break;
                        case 4: callback.call(This, args[0], args[1], args[2], args[3]); break;
                        case 5: callback.call(This, args[0], args[1], args[2], args[3], args[4]); break;
                    }
                });
            }
            else {
                switch (args.length) {
                    case 0: callback.call(This); break;
                    case 1: callback.call(This, args[0]); break;
                    case 2: callback.call(This, args[0], args[1]); break;
                    case 3: callback.call(This, args[0], args[1], args[2]); break;
                    case 4: callback.call(This, args[0], args[1], args[2], args[3]); break;
                    case 5: callback.call(This, args[0], args[1], args[2], args[3], args[4]); break;
                }
            }

        }, interval, immediate);
    };
}]);

torusApp.factory('throttle', ['$rootScope', function ($rootScope) {
    return function (callback, interval) {
        return _.throttle(function () {
            var This = this;
            var args = arguments;

            if (!$rootScope.$$phase) {
                $rootScope.$apply(function () {
                    switch (args.length) {
                        case 0: callback.call(This); break;
                        case 1: callback.call(This, args[0]); break;
                        case 2: callback.call(This, args[0], args[1]); break;
                        case 3: callback.call(This, args[0], args[1], args[2]); break;
                        case 4: callback.call(This, args[0], args[1], args[2], args[3]); break;
                        case 5: callback.call(This, args[0], args[1], args[2], args[3], args[4]); break;
                    }
                });
            }
            else {
                switch (args.length) {
                    case 0: callback.call(This); break;
                    case 1: callback.call(This, args[0]); break;
                    case 2: callback.call(This, args[0], args[1]); break;
                    case 3: callback.call(This, args[0], args[1], args[2]); break;
                    case 4: callback.call(This, args[0], args[1], args[2], args[3]); break;
                    case 5: callback.call(This, args[0], args[1], args[2], args[3], args[4]); break;
                }
            }
        }, interval);
    };
}]);

torusApp.service('imageMarkupCache', ['$http', function ($http) {
    var _cache = {};
    var _callbacks = {};

    var _runCallbacks = function (fileGuid, node) {
        _.forEach(_callbacks[fileGuid], function (callback) {
            callback(node);
        });
    };

    var getMarkup = function (fileGuid, callback) {
        if (_cache[fileGuid] !== undefined) {
            callback(_cache[fileGuid]);
        }

        if (_callbacks[fileGuid] !== undefined) {
            _callbacks[fileGuid].push(callback);
        }
        else {
            _callbacks[fileGuid] = [];
            _callbacks[fileGuid].push(callback);

            $http.get('/imagemarkup/' + fileGuid).then(function (response) {
                var markup = response.data;
                _cache[fileGuid] = markup;
                _runCallbacks(fileGuid, markup);
            }, function (reason) {
                _cache[fileGuid] = null;
                _runCallbacks(fileGuid, null);
            });
        }
    };

    return {
        getMarkup: getMarkup
    };
}]);

torusApp.service('tableParamsCache', ['$rootScope', '$location', '$timeout', function ($rootScope, $location, $timeout) {

    var _getCurrentContext = function () {
        return $location.absUrl().substr(8).split('/').splice(1).join('/').replace(/#/g, '');
    };

    var _copyProps = function (from, to, props, ignoreNil) {
        var any = { changed: false };

        for (var i = 0; i < props.length; ++i) {
            var n = props[i];

            var src = from[n];

            if (isNullOrUndefined(src))
                continue;

            var dst = to[n];

            if (isNullOrUndefined(dst))
                to[n] = dst = {};

            for (var p in src) {
                var v = src[p];

                if (ignoreNil && (isNullOrUndefined(v) || v === ''))
                    continue;

                if (dst[p] === v)
                    continue;

                dst[p] = v;

                any.changed = true;
                any[n] = true;
            }
        }

        return any;
    }

    var _serializeParams = function (params, context) {
        if (isNullOrUndefined(context))
            context = _getCurrentContext();

        var q = {};

        var changes = _copyProps(params.$params, q, ['filter', 'sorting'], true);

        if (changes.changed) {
            $rootScope[context + '$$cachedTableParams'] = q;
        }
    }

    var _deserializeParams = function (params, context) {
        if (isNullOrUndefined(context))
            context = _getCurrentContext();

        var q = $rootScope[context + '$$cachedTableParams'];

        if (isNullOrUndefined(q))
            return false;

        return _copyProps(q, params.$params, ['filter', 'sorting']);
    };

    return {
        load: function (params, $scope, callback, context, dontSave) {
            if (!$scope.$$cachedTableParamsLoaded) {
                $scope.$$cachedTableParamsLoaded = true;

                var changes = _deserializeParams(params, context);

                if (changes.changed && changes.filter === true) {
                    if (callback) {
                        $timeout(function () {
                            callback();
                        }, 100)
                    }
                }
            }

            if (!dontSave) {
                _serializeParams(params, context);
            }
        },

        save: function (params, context) {
            _serializeParams(params, context);
        }
    };
}]);
;
var torusFilters = angular.module('torus.filters', []);

torusFilters.filter("ngTableRecordInfo", function () {
    return function (input, currentPage, pageSize, totalRecords) {
        var start = (pageSize * (currentPage - 1)) + 1;
        var end = (pageSize * currentPage);
        if (end > totalRecords) {
            end = totalRecords;
        };
        return String.format(input, start, end, totalRecords);
    };

});

torusFilters.filter('ngAddEllipsis', function () {
    return function (input, charLength) {
        if (input) {
            // Replace this with the real implementation
            if (input.length > charLength) {
                return input.substring(0, charLength - 2) + '...';
            };
            return input;
        };
    };
});

torusFilters.filter('noFractionCurrency',
  ['$filter', '$locale',
  function ($filter, $locale) {
      var currency = $filter('currency'), formats = $locale.NUMBER_FORMATS;
      return function (amount, symbol) {
          var value = currency(amount, symbol);
          return value.replace(new RegExp('\\' + formats.DECIMAL_SEP + '\\d{2}'), '')
      };
  }]);

torusFilters.filter('sumByKey', function () {
    return function(data, key) {
        if (typeof (data) === 'undefined' || typeof (key) === 'undefined') {
            return 0;
        };
        var sum = 0;
        for (var i = data.length - 1; i >= 0; i--) {
            sum += parseFloat(data[i][key]);
        };
        return sum;
    };
});

torusFilters.filter('ngDateFormatter', function () {
    return function (input, momentFormat) {
        if (input) {
            var m = moment(input);
            return m.isValid() ? m.format(momentFormat) : input;
        };
        return input;
    };
});

torusFilters.filter('ngSystemTenant', function () { // items required to have tenantId property.
    return function (items, sysOrTenant) {
        var filteredItems = []
        angular.forEach(items, function (item) {
            if (sysOrTenant && item.tenantId == 0) { filteredItems.push(item); }
            else if (!sysOrTenant && item.tenantId > 0) { filteredItems.push(item); }
        });
        return filteredItems;
    }
})

// Underscore based filters:
// 
torusFilters.filter('groupBy', function($parse) {
    return _.memoize(function(items, field) {
        var getter = $parse(field);
        return _.groupBy(items, function(item) {
            return getter(item);
        });
    });
});

torusFilters.filter('percentage', ['$filter', function ($filter) {
    return function (input, decimals) {
        return $filter('number')(input, decimals) + '%';
    };
}]);

torusFilters.filter('prettifyIdentifier', ['$filter', function ($filter) {
    return function (input) {
        if (isNullOrUndefined(input))
            return input;

        return makeIdentifierReadable('' + input);
    };
}]);;
/*!
 * Bootstrap (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under the MIT license
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(a){"use strict";var b=a.fn.jquery.split(" ")[0].split(".");if(b[0]<2&&b[1]<9||1==b[0]&&9==b[1]&&b[2]<1)throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher")}(jQuery),+function(a){"use strict";function b(){var a=document.createElement("bootstrap"),b={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one("bsTransitionEnd",function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b(),a.support.transition&&(a.event.special.bsTransitionEnd={bindType:a.support.transition.end,delegateType:a.support.transition.end,handle:function(b){return a(b.target).is(this)?b.handleObj.handler.apply(this,arguments):void 0}})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var c=a(this),e=c.data("bs.alert");e||c.data("bs.alert",e=new d(this)),"string"==typeof b&&e[b].call(c)})}var c='[data-dismiss="alert"]',d=function(b){a(b).on("click",c,this.close)};d.VERSION="3.3.5",d.TRANSITION_DURATION=150,d.prototype.close=function(b){function c(){g.detach().trigger("closed.bs.alert").remove()}var e=a(this),f=e.attr("data-target");f||(f=e.attr("href"),f=f&&f.replace(/.*(?=#[^\s]*$)/,""));var g=a(f);b&&b.preventDefault(),g.length||(g=e.closest(".alert")),g.trigger(b=a.Event("close.bs.alert")),b.isDefaultPrevented()||(g.removeClass("in"),a.support.transition&&g.hasClass("fade")?g.one("bsTransitionEnd",c).emulateTransitionEnd(d.TRANSITION_DURATION):c())};var e=a.fn.alert;a.fn.alert=b,a.fn.alert.Constructor=d,a.fn.alert.noConflict=function(){return a.fn.alert=e,this},a(document).on("click.bs.alert.data-api",c,d.prototype.close)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.button"),f="object"==typeof b&&b;e||d.data("bs.button",e=new c(this,f)),"toggle"==b?e.toggle():b&&e.setState(b)})}var c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.isLoading=!1};c.VERSION="3.3.5",c.DEFAULTS={loadingText:"loading..."},c.prototype.setState=function(b){var c="disabled",d=this.$element,e=d.is("input")?"val":"html",f=d.data();b+="Text",null==f.resetText&&d.data("resetText",d[e]()),setTimeout(a.proxy(function(){d[e](null==f[b]?this.options[b]:f[b]),"loadingText"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},c.prototype.toggle=function(){var a=!0,b=this.$element.closest('[data-toggle="buttons"]');if(b.length){var c=this.$element.find("input");"radio"==c.prop("type")?(c.prop("checked")&&(a=!1),b.find(".active").removeClass("active"),this.$element.addClass("active")):"checkbox"==c.prop("type")&&(c.prop("checked")!==this.$element.hasClass("active")&&(a=!1),this.$element.toggleClass("active")),c.prop("checked",this.$element.hasClass("active")),a&&c.trigger("change")}else this.$element.attr("aria-pressed",!this.$element.hasClass("active")),this.$element.toggleClass("active")};var d=a.fn.button;a.fn.button=b,a.fn.button.Constructor=c,a.fn.button.noConflict=function(){return a.fn.button=d,this},a(document).on("click.bs.button.data-api",'[data-toggle^="button"]',function(c){var d=a(c.target);d.hasClass("btn")||(d=d.closest(".btn")),b.call(d,"toggle"),a(c.target).is('input[type="radio"]')||a(c.target).is('input[type="checkbox"]')||c.preventDefault()}).on("focus.bs.button.data-api blur.bs.button.data-api",'[data-toggle^="button"]',function(b){a(b.target).closest(".btn").toggleClass("focus",/^focus(in)?$/.test(b.type))})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.carousel"),f=a.extend({},c.DEFAULTS,d.data(),"object"==typeof b&&b),g="string"==typeof b?b:f.slide;e||d.data("bs.carousel",e=new c(this,f)),"number"==typeof b?e.to(b):g?e[g]():f.interval&&e.pause().cycle()})}var c=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(".carousel-indicators"),this.options=c,this.paused=null,this.sliding=null,this.interval=null,this.$active=null,this.$items=null,this.options.keyboard&&this.$element.on("keydown.bs.carousel",a.proxy(this.keydown,this)),"hover"==this.options.pause&&!("ontouchstart"in document.documentElement)&&this.$element.on("mouseenter.bs.carousel",a.proxy(this.pause,this)).on("mouseleave.bs.carousel",a.proxy(this.cycle,this))};c.VERSION="3.3.5",c.TRANSITION_DURATION=600,c.DEFAULTS={interval:5e3,pause:"hover",wrap:!0,keyboard:!0},c.prototype.keydown=function(a){if(!/input|textarea/i.test(a.target.tagName)){switch(a.which){case 37:this.prev();break;case 39:this.next();break;default:return}a.preventDefault()}},c.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(a){return this.$items=a.parent().children(".item"),this.$items.index(a||this.$active)},c.prototype.getItemForDirection=function(a,b){var c=this.getItemIndex(b),d="prev"==a&&0===c||"next"==a&&c==this.$items.length-1;if(d&&!this.options.wrap)return b;var e="prev"==a?-1:1,f=(c+e)%this.$items.length;return this.$items.eq(f)},c.prototype.to=function(a){var b=this,c=this.getItemIndex(this.$active=this.$element.find(".item.active"));return a>this.$items.length-1||0>a?void 0:this.sliding?this.$element.one("slid.bs.carousel",function(){b.to(a)}):c==a?this.pause().cycle():this.slide(a>c?"next":"prev",this.$items.eq(a))},c.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(".next, .prev").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){return this.sliding?void 0:this.slide("next")},c.prototype.prev=function(){return this.sliding?void 0:this.slide("prev")},c.prototype.slide=function(b,d){var e=this.$element.find(".item.active"),f=d||this.getItemForDirection(b,e),g=this.interval,h="next"==b?"left":"right",i=this;if(f.hasClass("active"))return this.sliding=!1;var j=f[0],k=a.Event("slide.bs.carousel",{relatedTarget:j,direction:h});if(this.$element.trigger(k),!k.isDefaultPrevented()){if(this.sliding=!0,g&&this.pause(),this.$indicators.length){this.$indicators.find(".active").removeClass("active");var l=a(this.$indicators.children()[this.getItemIndex(f)]);l&&l.addClass("active")}var m=a.Event("slid.bs.carousel",{relatedTarget:j,direction:h});return a.support.transition&&this.$element.hasClass("slide")?(f.addClass(b),f[0].offsetWidth,e.addClass(h),f.addClass(h),e.one("bsTransitionEnd",function(){f.removeClass([b,h].join(" ")).addClass("active"),e.removeClass(["active",h].join(" ")),i.sliding=!1,setTimeout(function(){i.$element.trigger(m)},0)}).emulateTransitionEnd(c.TRANSITION_DURATION)):(e.removeClass("active"),f.addClass("active"),this.sliding=!1,this.$element.trigger(m)),g&&this.cycle(),this}};var d=a.fn.carousel;a.fn.carousel=b,a.fn.carousel.Constructor=c,a.fn.carousel.noConflict=function(){return a.fn.carousel=d,this};var e=function(c){var d,e=a(this),f=a(e.attr("data-target")||(d=e.attr("href"))&&d.replace(/.*(?=#[^\s]+$)/,""));if(f.hasClass("carousel")){var g=a.extend({},f.data(),e.data()),h=e.attr("data-slide-to");h&&(g.interval=!1),b.call(f,g),h&&f.data("bs.carousel").to(h),c.preventDefault()}};a(document).on("click.bs.carousel.data-api","[data-slide]",e).on("click.bs.carousel.data-api","[data-slide-to]",e),a(window).on("load",function(){a('[data-ride="carousel"]').each(function(){var c=a(this);b.call(c,c.data())})})}(jQuery),+function(a){"use strict";function b(b){var c,d=b.attr("data-target")||(c=b.attr("href"))&&c.replace(/.*(?=#[^\s]+$)/,"");return a(d)}function c(b){return this.each(function(){var c=a(this),e=c.data("bs.collapse"),f=a.extend({},d.DEFAULTS,c.data(),"object"==typeof b&&b);!e&&f.toggle&&/show|hide/.test(b)&&(f.toggle=!1),e||c.data("bs.collapse",e=new d(this,f)),"string"==typeof b&&e[b]()})}var d=function(b,c){this.$element=a(b),this.options=a.extend({},d.DEFAULTS,c),this.$trigger=a('[data-toggle="collapse"][href="#'+b.id+'"],[data-toggle="collapse"][data-target="#'+b.id+'"]'),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&&this.toggle()};d.VERSION="3.3.5",d.TRANSITION_DURATION=350,d.DEFAULTS={toggle:!0},d.prototype.dimension=function(){var a=this.$element.hasClass("width");return a?"width":"height"},d.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var b,e=this.$parent&&this.$parent.children(".panel").children(".in, .collapsing");if(!(e&&e.length&&(b=e.data("bs.collapse"),b&&b.transitioning))){var f=a.Event("show.bs.collapse");if(this.$element.trigger(f),!f.isDefaultPrevented()){e&&e.length&&(c.call(e,"hide"),b||e.data("bs.collapse",null));var g=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded",!0),this.$trigger.removeClass("collapsed").attr("aria-expanded",!0),this.transitioning=1;var h=function(){this.$element.removeClass("collapsing").addClass("collapse in")[g](""),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!a.support.transition)return h.call(this);var i=a.camelCase(["scroll",g].join("-"));this.$element.one("bsTransitionEnd",a.proxy(h,this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])}}}},d.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var b=a.Event("hide.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded",!1),this.$trigger.addClass("collapsed").attr("aria-expanded",!1),this.transitioning=1;var e=function(){this.transitioning=0,this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")};return a.support.transition?void this.$element[c](0).one("bsTransitionEnd",a.proxy(e,this)).emulateTransitionEnd(d.TRANSITION_DURATION):e.call(this)}}},d.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()},d.prototype.getParent=function(){return a(this.options.parent).find('[data-toggle="collapse"][data-parent="'+this.options.parent+'"]').each(a.proxy(function(c,d){var e=a(d);this.addAriaAndCollapsedClass(b(e),e)},this)).end()},d.prototype.addAriaAndCollapsedClass=function(a,b){var c=a.hasClass("in");a.attr("aria-expanded",c),b.toggleClass("collapsed",!c).attr("aria-expanded",c)};var e=a.fn.collapse;a.fn.collapse=c,a.fn.collapse.Constructor=d,a.fn.collapse.noConflict=function(){return a.fn.collapse=e,this},a(document).on("click.bs.collapse.data-api",'[data-toggle="collapse"]',function(d){var e=a(this);e.attr("data-target")||d.preventDefault();var f=b(e),g=f.data("bs.collapse"),h=g?"toggle":e.data();c.call(f,h)})}(jQuery),+function(a){"use strict";function b(b){var c=b.attr("data-target");c||(c=b.attr("href"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\s]*$)/,""));var d=c&&a(c);return d&&d.length?d:b.parent()}function c(c){c&&3===c.which||(a(e).remove(),a(f).each(function(){var d=a(this),e=b(d),f={relatedTarget:this};e.hasClass("open")&&(c&&"click"==c.type&&/input|textarea/i.test(c.target.tagName)&&a.contains(e[0],c.target)||(e.trigger(c=a.Event("hide.bs.dropdown",f)),c.isDefaultPrevented()||(d.attr("aria-expanded","false"),e.removeClass("open").trigger("hidden.bs.dropdown",f))))}))}function d(b){return this.each(function(){var c=a(this),d=c.data("bs.dropdown");d||c.data("bs.dropdown",d=new g(this)),"string"==typeof b&&d[b].call(c)})}var e=".dropdown-backdrop",f='[data-toggle="dropdown"]',g=function(b){a(b).on("click.bs.dropdown",this.toggle)};g.VERSION="3.3.5",g.prototype.toggle=function(d){var e=a(this);if(!e.is(".disabled, :disabled")){var f=b(e),g=f.hasClass("open");if(c(),!g){"ontouchstart"in document.documentElement&&!f.closest(".navbar-nav").length&&a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click",c);var h={relatedTarget:this};if(f.trigger(d=a.Event("show.bs.dropdown",h)),d.isDefaultPrevented())return;e.trigger("focus").attr("aria-expanded","true"),f.toggleClass("open").trigger("shown.bs.dropdown",h)}return!1}},g.prototype.keydown=function(c){if(/(38|40|27|32)/.test(c.which)&&!/input|textarea/i.test(c.target.tagName)){var d=a(this);if(c.preventDefault(),c.stopPropagation(),!d.is(".disabled, :disabled")){var e=b(d),g=e.hasClass("open");if(!g&&27!=c.which||g&&27==c.which)return 27==c.which&&e.find(f).trigger("focus"),d.trigger("click");var h=" li:not(.disabled):visible a",i=e.find(".dropdown-menu"+h);if(i.length){var j=i.index(c.target);38==c.which&&j>0&&j--,40==c.which&&j<i.length-1&&j++,~j||(j=0),i.eq(j).trigger("focus")}}}};var h=a.fn.dropdown;a.fn.dropdown=d,a.fn.dropdown.Constructor=g,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=h,this},a(document).on("click.bs.dropdown.data-api",c).on("click.bs.dropdown.data-api",".dropdown form",function(a){a.stopPropagation()}).on("click.bs.dropdown.data-api",f,g.prototype.toggle).on("keydown.bs.dropdown.data-api",f,g.prototype.keydown).on("keydown.bs.dropdown.data-api",".dropdown-menu",g.prototype.keydown)}(jQuery),+function(a){"use strict";function b(b,d){return this.each(function(){var e=a(this),f=e.data("bs.modal"),g=a.extend({},c.DEFAULTS,e.data(),"object"==typeof b&&b);f||e.data("bs.modal",f=new c(this,g)),"string"==typeof b?f[b](d):g.show&&f.show(d)})}var c=function(b,c){this.options=c,this.$body=a(document.body),this.$element=a(b),this.$dialog=this.$element.find(".modal-dialog"),this.$backdrop=null,this.isShown=null,this.originalBodyPad=null,this.scrollbarWidth=0,this.ignoreBackdropClick=!1,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,a.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};c.VERSION="3.3.5",c.TRANSITION_DURATION=300,c.BACKDROP_TRANSITION_DURATION=150,c.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},c.prototype.toggle=function(a){return this.isShown?this.hide():this.show(a)},c.prototype.show=function(b){var d=this,e=a.Event("show.bs.modal",{relatedTarget:b});this.$element.trigger(e),this.isShown||e.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass("modal-open"),this.escape(),this.resize(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',a.proxy(this.hide,this)),this.$dialog.on("mousedown.dismiss.bs.modal",function(){d.$element.one("mouseup.dismiss.bs.modal",function(b){a(b.target).is(d.$element)&&(d.ignoreBackdropClick=!0)})}),this.backdrop(function(){var e=a.support.transition&&d.$element.hasClass("fade");d.$element.parent().length||d.$element.appendTo(d.$body),d.$element.show().scrollTop(0),d.adjustDialog(),e&&d.$element[0].offsetWidth,d.$element.addClass("in"),d.enforceFocus();var f=a.Event("shown.bs.modal",{relatedTarget:b});e?d.$dialog.one("bsTransitionEnd",function(){d.$element.trigger("focus").trigger(f)}).emulateTransitionEnd(c.TRANSITION_DURATION):d.$element.trigger("focus").trigger(f)}))},c.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event("hide.bs.modal"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),a(document).off("focusin.bs.modal"),this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"),this.$dialog.off("mousedown.dismiss.bs.modal"),a.support.transition&&this.$element.hasClass("fade")?this.$element.one("bsTransitionEnd",a.proxy(this.hideModal,this)).emulateTransitionEnd(c.TRANSITION_DURATION):this.hideModal())},c.prototype.enforceFocus=function(){a(document).off("focusin.bs.modal").on("focusin.bs.modal",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.trigger("focus")},this))},c.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keydown.dismiss.bs.modal",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off("keydown.dismiss.bs.modal")},c.prototype.resize=function(){this.isShown?a(window).on("resize.bs.modal",a.proxy(this.handleUpdate,this)):a(window).off("resize.bs.modal")},c.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.$body.removeClass("modal-open"),a.resetAdjustments(),a.resetScrollbar(),a.$element.trigger("hidden.bs.modal")})},c.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},c.prototype.backdrop=function(b){var d=this,e=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var f=a.support.transition&&e;if(this.$backdrop=a(document.createElement("div")).addClass("modal-backdrop "+e).appendTo(this.$body),this.$element.on("click.dismiss.bs.modal",a.proxy(function(a){return this.ignoreBackdropClick?void(this.ignoreBackdropClick=!1):void(a.target===a.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus():this.hide()))},this)),f&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!b)return;f?this.$backdrop.one("bsTransitionEnd",b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):b()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass("in");var g=function(){d.removeBackdrop(),b&&b()};a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one("bsTransitionEnd",g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):g()}else b&&b()},c.prototype.handleUpdate=function(){this.adjustDialog()},c.prototype.adjustDialog=function(){var a=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&a?this.scrollbarWidth:"",paddingRight:this.bodyIsOverflowing&&!a?this.scrollbarWidth:""})},c.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:"",paddingRight:""})},c.prototype.checkScrollbar=function(){var a=window.innerWidth;if(!a){var b=document.documentElement.getBoundingClientRect();a=b.right-Math.abs(b.left)}this.bodyIsOverflowing=document.body.clientWidth<a,this.scrollbarWidth=this.measureScrollbar()},c.prototype.setScrollbar=function(){var a=parseInt(this.$body.css("padding-right")||0,10);this.originalBodyPad=document.body.style.paddingRight||"",this.bodyIsOverflowing&&this.$body.css("padding-right",a+this.scrollbarWidth)},c.prototype.resetScrollbar=function(){this.$body.css("padding-right",this.originalBodyPad)},c.prototype.measureScrollbar=function(){var a=document.createElement("div");a.className="modal-scrollbar-measure",this.$body.append(a);var b=a.offsetWidth-a.clientWidth;return this.$body[0].removeChild(a),b};var d=a.fn.modal;a.fn.modal=b,a.fn.modal.Constructor=c,a.fn.modal.noConflict=function(){return a.fn.modal=d,this},a(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(c){var d=a(this),e=d.attr("href"),f=a(d.attr("data-target")||e&&e.replace(/.*(?=#[^\s]+$)/,"")),g=f.data("bs.modal")?"toggle":a.extend({remote:!/#/.test(e)&&e},f.data(),d.data());d.is("a")&&c.preventDefault(),f.one("show.bs.modal",function(a){a.isDefaultPrevented()||f.one("hidden.bs.modal",function(){d.is(":visible")&&d.trigger("focus")})}),b.call(f,g,this)})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tooltip"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.tooltip",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.type=null,this.options=null,this.enabled=null,this.timeout=null,this.hoverState=null,this.$element=null,this.inState=null,this.init("tooltip",a,b)};c.VERSION="3.3.5",c.TRANSITION_DURATION=150,c.DEFAULTS={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1,viewport:{selector:"body",padding:0}},c.prototype.init=function(b,c,d){if(this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(a.isFunction(this.options.viewport)?this.options.viewport.call(this,this.$element):this.options.viewport.selector||this.options.viewport),this.inState={click:!1,hover:!1,focus:!1},this.$element[0]instanceof document.constructor&&!this.options.selector)throw new Error("`selector` option must be specified when initializing "+this.type+" on the window.document object!");for(var e=this.options.trigger.split(" "),f=e.length;f--;){var g=e[f];if("click"==g)this.$element.on("click."+this.type,this.options.selector,a.proxy(this.toggle,this));else if("manual"!=g){var h="hover"==g?"mouseenter":"focusin",i="hover"==g?"mouseleave":"focusout";this.$element.on(h+"."+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+"."+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&"number"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},c.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),b instanceof a.Event&&(c.inState["focusin"==b.type?"focus":"hover"]=!0),c.tip().hasClass("in")||"in"==c.hoverState?void(c.hoverState="in"):(clearTimeout(c.timeout),c.hoverState="in",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){"in"==c.hoverState&&c.show()},c.options.delay.show)):c.show())},c.prototype.isInStateTrue=function(){for(var a in this.inState)if(this.inState[a])return!0;return!1},c.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),b instanceof a.Event&&(c.inState["focusout"==b.type?"focus":"hover"]=!1),c.isInStateTrue()?void 0:(clearTimeout(c.timeout),c.hoverState="out",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){"out"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide())},c.prototype.show=function(){var b=a.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(b);var d=a.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(b.isDefaultPrevented()||!d)return;var e=this,f=this.tip(),g=this.getUID(this.type);this.setContent(),f.attr("id",g),this.$element.attr("aria-describedby",g),this.options.animation&&f.addClass("fade");var h="function"==typeof this.options.placement?this.options.placement.call(this,f[0],this.$element[0]):this.options.placement,i=/\s?auto?\s?/i,j=i.test(h);j&&(h=h.replace(i,"")||"top"),f.detach().css({top:0,left:0,display:"block"}).addClass(h).data("bs."+this.type,this),this.options.container?f.appendTo(this.options.container):f.insertAfter(this.$element),this.$element.trigger("inserted.bs."+this.type);var k=this.getPosition(),l=f[0].offsetWidth,m=f[0].offsetHeight;if(j){var n=h,o=this.getPosition(this.$viewport);h="bottom"==h&&k.bottom+m>o.bottom?"top":"top"==h&&k.top-m<o.top?"bottom":"right"==h&&k.right+l>o.width?"left":"left"==h&&k.left-l<o.left?"right":h,f.removeClass(n).addClass(h)}var p=this.getCalculatedOffset(h,k,l,m);this.applyPlacement(p,h);var q=function(){var a=e.hoverState;e.$element.trigger("shown.bs."+e.type),e.hoverState=null,"out"==a&&e.leave(e)};a.support.transition&&this.$tip.hasClass("fade")?f.one("bsTransitionEnd",q).emulateTransitionEnd(c.TRANSITION_DURATION):q()}},c.prototype.applyPlacement=function(b,c){var d=this.tip(),e=d[0].offsetWidth,f=d[0].offsetHeight,g=parseInt(d.css("margin-top"),10),h=parseInt(d.css("margin-left"),10);isNaN(g)&&(g=0),isNaN(h)&&(h=0),b.top+=g,b.left+=h,a.offset.setOffset(d[0],a.extend({using:function(a){d.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),d.addClass("in");var i=d[0].offsetWidth,j=d[0].offsetHeight;"top"==c&&j!=f&&(b.top=b.top+f-j);var k=this.getViewportAdjustedDelta(c,b,i,j);k.left?b.left+=k.left:b.top+=k.top;var l=/top|bottom/.test(c),m=l?2*k.left-e+i:2*k.top-f+j,n=l?"offsetWidth":"offsetHeight";d.offset(b),this.replaceArrow(m,d[0][n],l)},c.prototype.replaceArrow=function(a,b,c){this.arrow().css(c?"left":"top",50*(1-a/b)+"%").css(c?"top":"left","")},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(".tooltip-inner")[this.options.html?"html":"text"](b),a.removeClass("fade in top bottom left right")},c.prototype.hide=function(b){function d(){"in"!=e.hoverState&&f.detach(),e.$element.removeAttr("aria-describedby").trigger("hidden.bs."+e.type),b&&b()}var e=this,f=a(this.$tip),g=a.Event("hide.bs."+this.type);return this.$element.trigger(g),g.isDefaultPrevented()?void 0:(f.removeClass("in"),a.support.transition&&f.hasClass("fade")?f.one("bsTransitionEnd",d).emulateTransitionEnd(c.TRANSITION_DURATION):d(),this.hoverState=null,this)},c.prototype.fixTitle=function(){var a=this.$element;(a.attr("title")||"string"!=typeof a.attr("data-original-title"))&&a.attr("data-original-title",a.attr("title")||"").attr("title","")},c.prototype.hasContent=function(){return this.getTitle()},c.prototype.getPosition=function(b){b=b||this.$element;var c=b[0],d="BODY"==c.tagName,e=c.getBoundingClientRect();null==e.width&&(e=a.extend({},e,{width:e.right-e.left,height:e.bottom-e.top}));var f=d?{top:0,left:0}:b.offset(),g={scroll:d?document.documentElement.scrollTop||document.body.scrollTop:b.scrollTop()},h=d?{width:a(window).width(),height:a(window).height()}:null;return a.extend({},e,g,h,f)},c.prototype.getCalculatedOffset=function(a,b,c,d){return"bottom"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:"top"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:"left"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},c.prototype.getViewportAdjustedDelta=function(a,b,c,d){var e={top:0,left:0};if(!this.$viewport)return e;var f=this.options.viewport&&this.options.viewport.padding||0,g=this.getPosition(this.$viewport);if(/right|left/.test(a)){var h=b.top-f-g.scroll,i=b.top+f-g.scroll+d;h<g.top?e.top=g.top-h:i>g.top+g.height&&(e.top=g.top+g.height-i)}else{var j=b.left-f,k=b.left+f+c;j<g.left?e.left=g.left-j:k>g.right&&(e.left=g.left+g.width-k)}return e},c.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr("data-original-title")||("function"==typeof c.title?c.title.call(b[0]):c.title)},c.prototype.getUID=function(a){do a+=~~(1e6*Math.random());while(document.getElementById(a));return a},c.prototype.tip=function(){if(!this.$tip&&(this.$tip=a(this.options.template),1!=this.$tip.length))throw new Error(this.type+" `template` option must consist of exactly 1 top-level element!");return this.$tip},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},c.prototype.enable=function(){this.enabled=!0},c.prototype.disable=function(){this.enabled=!1},c.prototype.toggleEnabled=function(){this.enabled=!this.enabled},c.prototype.toggle=function(b){var c=this;b&&(c=a(b.currentTarget).data("bs."+this.type),c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c))),b?(c.inState.click=!c.inState.click,c.isInStateTrue()?c.enter(c):c.leave(c)):c.tip().hasClass("in")?c.leave(c):c.enter(c)},c.prototype.destroy=function(){var a=this;clearTimeout(this.timeout),this.hide(function(){a.$element.off("."+a.type).removeData("bs."+a.type),a.$tip&&a.$tip.detach(),a.$tip=null,a.$arrow=null,a.$viewport=null})};var d=a.fn.tooltip;a.fn.tooltip=b,a.fn.tooltip.Constructor=c,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=d,this}}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.popover"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.popover",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.init("popover",a,b)};if(!a.fn.tooltip)throw new Error("Popover requires tooltip.js");c.VERSION="3.3.5",c.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),c.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),c.prototype.constructor=c,c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(".popover-title")[this.options.html?"html":"text"](b),a.find(".popover-content").children().detach().end()[this.options.html?"string"==typeof c?"html":"append":"text"](c),a.removeClass("fade top bottom left right in"),a.find(".popover-title").html()||a.find(".popover-title").hide()},c.prototype.hasContent=function(){return this.getTitle()||this.getContent()},c.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr("data-content")||("function"==typeof b.content?b.content.call(a[0]):b.content)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")};var d=a.fn.popover;a.fn.popover=b,a.fn.popover.Constructor=c,a.fn.popover.noConflict=function(){return a.fn.popover=d,this}}(jQuery),+function(a){"use strict";function b(c,d){this.$body=a(document.body),this.$scrollElement=a(a(c).is(document.body)?window:c),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||"")+" .nav li > a",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on("scroll.bs.scrollspy",a.proxy(this.process,this)),this.refresh(),this.process()}function c(c){return this.each(function(){var d=a(this),e=d.data("bs.scrollspy"),f="object"==typeof c&&c;e||d.data("bs.scrollspy",e=new b(this,f)),"string"==typeof c&&e[c]()})}b.VERSION="3.3.5",b.DEFAULTS={offset:10},b.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},b.prototype.refresh=function(){var b=this,c="offset",d=0;this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight(),a.isWindow(this.$scrollElement[0])||(c="position",d=this.$scrollElement.scrollTop()),this.$body.find(this.selector).map(function(){var b=a(this),e=b.data("target")||b.attr("href"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(":visible")&&[[f[c]().top+d,e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){b.offsets.push(this[0]),b.targets.push(this[1])})},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.getScrollHeight(),d=this.options.offset+c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(this.scrollHeight!=c&&this.refresh(),b>=d)return g!=(a=f[f.length-1])&&this.activate(a);if(g&&b<e[0])return this.activeTarget=null,this.clear();for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(void 0===e[a+1]||b<e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,this.clear();var c=this.selector+'[data-target="'+b+'"],'+this.selector+'[href="'+b+'"]',d=a(c).parents("li").addClass("active");d.parent(".dropdown-menu").length&&(d=d.closest("li.dropdown").addClass("active")),
d.trigger("activate.bs.scrollspy")},b.prototype.clear=function(){a(this.selector).parentsUntil(this.options.target,".active").removeClass("active")};var d=a.fn.scrollspy;a.fn.scrollspy=c,a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=d,this},a(window).on("load.bs.scrollspy.data-api",function(){a('[data-spy="scroll"]').each(function(){var b=a(this);c.call(b,b.data())})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tab");e||d.data("bs.tab",e=new c(this)),"string"==typeof b&&e[b]()})}var c=function(b){this.element=a(b)};c.VERSION="3.3.5",c.TRANSITION_DURATION=150,c.prototype.show=function(){var b=this.element,c=b.closest("ul:not(.dropdown-menu)"),d=b.data("target");if(d||(d=b.attr("href"),d=d&&d.replace(/.*(?=#[^\s]*$)/,"")),!b.parent("li").hasClass("active")){var e=c.find(".active:last a"),f=a.Event("hide.bs.tab",{relatedTarget:b[0]}),g=a.Event("show.bs.tab",{relatedTarget:e[0]});if(e.trigger(f),b.trigger(g),!g.isDefaultPrevented()&&!f.isDefaultPrevented()){var h=a(d);this.activate(b.closest("li"),c),this.activate(h,h.parent(),function(){e.trigger({type:"hidden.bs.tab",relatedTarget:b[0]}),b.trigger({type:"shown.bs.tab",relatedTarget:e[0]})})}}},c.prototype.activate=function(b,d,e){function f(){g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!1),b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded",!0),h?(b[0].offsetWidth,b.addClass("in")):b.removeClass("fade"),b.parent(".dropdown-menu").length&&b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!0),e&&e()}var g=d.find("> .active"),h=e&&a.support.transition&&(g.length&&g.hasClass("fade")||!!d.find("> .fade").length);g.length&&h?g.one("bsTransitionEnd",f).emulateTransitionEnd(c.TRANSITION_DURATION):f(),g.removeClass("in")};var d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return a.fn.tab=d,this};var e=function(c){c.preventDefault(),b.call(a(this),"show")};a(document).on("click.bs.tab.data-api",'[data-toggle="tab"]',e).on("click.bs.tab.data-api",'[data-toggle="pill"]',e)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.affix"),f="object"==typeof b&&b;e||d.data("bs.affix",e=new c(this,f)),"string"==typeof b&&e[b]()})}var c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on("scroll.bs.affix.data-api",a.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};c.VERSION="3.3.5",c.RESET="affix affix-top affix-bottom",c.DEFAULTS={offset:0,target:window},c.prototype.getState=function(a,b,c,d){var e=this.$target.scrollTop(),f=this.$element.offset(),g=this.$target.height();if(null!=c&&"top"==this.affixed)return c>e?"top":!1;if("bottom"==this.affixed)return null!=c?e+this.unpin<=f.top?!1:"bottom":a-d>=e+g?!1:"bottom";var h=null==this.affixed,i=h?e:f.top,j=h?g:b;return null!=c&&c>=e?"top":null!=d&&i+j>=a-d?"bottom":!1},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a=this.$target.scrollTop(),b=this.$element.offset();return this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(":visible")){var b=this.$element.height(),d=this.options.offset,e=d.top,f=d.bottom,g=Math.max(a(document).height(),a(document.body).height());"object"!=typeof d&&(f=e=d),"function"==typeof e&&(e=d.top(this.$element)),"function"==typeof f&&(f=d.bottom(this.$element));var h=this.getState(g,b,e,f);if(this.affixed!=h){null!=this.unpin&&this.$element.css("top","");var i="affix"+(h?"-"+h:""),j=a.Event(i+".bs.affix");if(this.$element.trigger(j),j.isDefaultPrevented())return;this.affixed=h,this.unpin="bottom"==h?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix","affixed")+".bs.affix")}"bottom"==h&&this.$element.offset({top:g-b-f})}};var d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return a.fn.affix=d,this},a(window).on("load",function(){a('[data-spy="affix"]').each(function(){var c=a(this),d=c.data();d.offset=d.offset||{},null!=d.offsetBottom&&(d.offset.bottom=d.offsetBottom),null!=d.offsetTop&&(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);;
/* KC Modified - to inject css classes because of positioning / page layout */
/* =========================================================
 * bootstrap-datepicker.js
 * Repo: https://github.com/eternicode/bootstrap-datepicker/
 * Demo: http://eternicode.github.io/bootstrap-datepicker/
 * Docs: http://bootstrap-datepicker.readthedocs.org/
 * Forked from http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Started by Stefan Petre; improvements by Andrew Rowls + contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

(function($, undefined){

	var $window = $(window);

	function UTCDate(){
		return new Date(Date.UTC.apply(Date, arguments));
	}
	function UTCToday(){
		var today = new Date();
		return UTCDate(today.getFullYear(), today.getMonth(), today.getDate());
	}
	function alias(method){
		return function(){
			return this[method].apply(this, arguments);
		};
	}

	var DateArray = (function(){
		var extras = {
			get: function(i){
				return this.slice(i)[0];
			},
			contains: function(d){
				// Array.indexOf is not cross-browser;
				// $.inArray doesn't work with Dates
				var val = d && d.valueOf();
				for (var i=0, l=this.length; i < l; i++)
					if (this[i].valueOf() === val)
						return i;
				return -1;
			},
			remove: function(i){
				this.splice(i,1);
			},
			replace: function(new_array){
				if (!new_array)
					return;
				if (!$.isArray(new_array))
					new_array = [new_array];
				this.clear();
				this.push.apply(this, new_array);
			},
			clear: function(){
				this.length = 0;
			},
			copy: function(){
				var a = new DateArray();
				a.replace(this);
				return a;
			}
		};

		return function(){
			var a = [];
			a.push.apply(a, arguments);
			$.extend(a, extras);
			return a;
		};
	})();


	// Picker object

	var Datepicker = function(element, options){
		this.dates = new DateArray();
		this.viewDate = UTCToday();
		this.focusDate = null;

		this._process_options(options);

		this.element = $(element);
		this.isInline = false;
		this.isInput = this.element.is('input');
		this.component = this.element.is('.date') ? this.element.find('.add-on, .input-group-addon, .btn') : false;
		this.hasInput = this.component && this.element.find('input').length;
		if (this.component && this.component.length === 0)
			this.component = false;

		this.picker = $(DPGlobal.template);
		this._buildEvents();
		this._attachEvents();

        if (this.o.classes) {
            this.picker.addClass(this.o.classes);
        }

		if (this.isInline){
			this.picker.addClass('datepicker-inline').appendTo(this.element);
		}
		else {
			this.picker.addClass('datepicker-dropdown dropdown-menu');
        }

		if (this.o.rtl){
			this.picker.addClass('datepicker-rtl');
		}

		this.viewMode = this.o.startView;

		if (this.o.calendarWeeks)
			this.picker.find('tfoot th.today')
						.attr('colspan', function(i, val){
							return parseInt(val) + 1;
						});

		this._allow_update = false;

		this.setStartDate(this._o.startDate);
		this.setEndDate(this._o.endDate);
		this.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled);

		this.fillDow();
		this.fillMonths();

		this._allow_update = true;

		this.update();
		this.showMode();

		if (this.isInline){
			this.show();
		}
	};

	Datepicker.prototype = {
		constructor: Datepicker,

		_process_options: function(opts){
			// Store raw options for reference
			this._o = $.extend({}, this._o, opts);
			// Processed options
			var o = this.o = $.extend({}, this._o);

			// Check if "de-DE" style date is available, if not language should
			// fallback to 2 letter code eg "de"
			var lang = o.language;
			if (!dates[lang]){
				lang = lang.split('-')[0];
				if (!dates[lang])
					lang = defaults.language;
			}
			o.language = lang;

			switch (o.startView){
				case 2:
				case 'decade':
					o.startView = 2;
					break;
				case 1:
				case 'year':
					o.startView = 1;
					break;
				default:
					o.startView = 0;
			}

			switch (o.minViewMode){
				case 1:
				case 'months':
					o.minViewMode = 1;
					break;
				case 2:
				case 'years':
					o.minViewMode = 2;
					break;
				default:
					o.minViewMode = 0;
			}

			o.startView = Math.max(o.startView, o.minViewMode);

			// true, false, or Number > 0
			if (o.multidate !== true){
				o.multidate = Number(o.multidate) || false;
				if (o.multidate !== false)
					o.multidate = Math.max(0, o.multidate);
				//else
				//	o.multidate = 1;
			}
			o.multidateSeparator = String(o.multidateSeparator);

			o.weekStart %= 7;
			o.weekEnd = ((o.weekStart + 6) % 7);

			var format = DPGlobal.parseFormat(o.format);
			if (o.startDate !== -Infinity){
				if (!!o.startDate){
					if (o.startDate instanceof Date)
						o.startDate = this._local_to_utc(this._zero_time(o.startDate));
					else
						o.startDate = DPGlobal.parseDate(o.startDate, format, o.language);
				}
				else {
					o.startDate = -Infinity;
				}
			}
			if (o.endDate !== Infinity){
				if (!!o.endDate){
					if (o.endDate instanceof Date)
						o.endDate = this._local_to_utc(this._zero_time(o.endDate));
					else
						o.endDate = DPGlobal.parseDate(o.endDate, format, o.language);
				}
				else {
					o.endDate = Infinity;
				}
			}

			o.daysOfWeekDisabled = o.daysOfWeekDisabled||[];
			if (!$.isArray(o.daysOfWeekDisabled))
				o.daysOfWeekDisabled = o.daysOfWeekDisabled.split(/[,\s]*/);
			o.daysOfWeekDisabled = $.map(o.daysOfWeekDisabled, function(d){
				return parseInt(d, 10);
			});

			var plc = String(o.orientation).toLowerCase().split(/\s+/g),
				_plc = o.orientation.toLowerCase();
			plc = $.grep(plc, function(word){
				return (/^auto|left|right|top|bottom$/).test(word);
			});
			o.orientation = {x: 'auto', y: 'auto'};
			if (!_plc || _plc === 'auto')
				; // no action
			else if (plc.length === 1){
				switch (plc[0]){
					case 'top':
					case 'bottom':
						o.orientation.y = plc[0];
						break;
					case 'left':
					case 'right':
						o.orientation.x = plc[0];
						break;
				}
			}
			else {
				_plc = $.grep(plc, function(word){
					return (/^left|right$/).test(word);
				});
				o.orientation.x = _plc[0] || 'auto';

				_plc = $.grep(plc, function(word){
					return (/^top|bottom$/).test(word);
				});
				o.orientation.y = _plc[0] || 'auto';
			}
		},
		_events: [],
		_secondaryEvents: [],
		_applyEvents: function(evs){
			for (var i=0, el, ch, ev; i < evs.length; i++){
				el = evs[i][0];
				if (evs[i].length === 2){
					ch = undefined;
					ev = evs[i][1];
				}
				else if (evs[i].length === 3){
					ch = evs[i][1];
					ev = evs[i][2];
				}
				el.on(ev, ch);
			}
		},
		_unapplyEvents: function(evs){
			for (var i=0, el, ev, ch; i < evs.length; i++){
				el = evs[i][0];
				if (evs[i].length === 2){
					ch = undefined;
					ev = evs[i][1];
				}
				else if (evs[i].length === 3){
					ch = evs[i][1];
					ev = evs[i][2];
				}
				el.off(ev, ch);
			}
		},
		_buildEvents: function(){
			if (this.isInput){ // single input
				this._events = [
					[this.element, {
						focus: $.proxy(this.show, this),
						keyup: $.proxy(function(e){
							if ($.inArray(e.keyCode, [27,37,39,38,40,32,13,9]) === -1)
								this.update();
						}, this),
						keydown: $.proxy(this.keydown, this)
					}]
				];
			}
			else if (this.component && this.hasInput){ // component: input + button
				this._events = [
					// For components that are not readonly, allow keyboard nav
					[this.element.find('input'), {
						focus: $.proxy(this.show, this),
						keyup: $.proxy(function(e){
							if ($.inArray(e.keyCode, [27,37,39,38,40,32,13,9]) === -1)
								this.update();
						}, this),
						keydown: $.proxy(this.keydown, this)
					}],
					[this.component, {
						click: $.proxy(this.show, this)
					}]
				];
			}
			else if (this.element.is('div')){  // inline datepicker
				this.isInline = true;
			}
			else {
				this._events = [
					[this.element, {
						click: $.proxy(this.show, this)
					}]
				];
			}
			this._events.push(
				// Component: listen for blur on element descendants
				[this.element, '*', {
					blur: $.proxy(function(e){
						this._focused_from = e.target;
					}, this)
				}],
				// Input: listen for blur on element
				[this.element, {
					blur: $.proxy(function(e){
						this._focused_from = e.target;
					}, this)
				}]
			);

			this._secondaryEvents = [
				[this.picker, {
					click: $.proxy(this.click, this)
				}],
				[$(window), {
					resize: $.proxy(this.place, this)
				}],
				[$(document), {
					'mousedown touchstart': $.proxy(function(e){
						// Clicked outside the datepicker, hide it
						if (!(
							this.element.is(e.target) ||
							this.element.find(e.target).length ||
							this.picker.is(e.target) ||
							this.picker.find(e.target).length
						)){
							this.hide();
						}
					}, this)
				}]
			];
		},
		_attachEvents: function(){
			this._detachEvents();
			this._applyEvents(this._events);
		},
		_detachEvents: function(){
			this._unapplyEvents(this._events);
		},
		_attachSecondaryEvents: function(){
			this._detachSecondaryEvents();
			this._applyEvents(this._secondaryEvents);
		},
		_detachSecondaryEvents: function(){
			this._unapplyEvents(this._secondaryEvents);
		},
		_trigger: function(event, altdate){
			var date = altdate || this.dates.get(-1),
				local_date = this._utc_to_local(date);

			this.element.trigger({
				type: event,
				date: local_date,
				dates: $.map(this.dates, this._utc_to_local),
				format: $.proxy(function(ix, format){
					if (arguments.length === 0){
						ix = this.dates.length - 1;
						format = this.o.format;
					}
					else if (typeof ix === 'string'){
						format = ix;
						ix = this.dates.length - 1;
					}
					format = format || this.o.format;
					var date = this.dates.get(ix);
					return DPGlobal.formatDate(date, format, this.o.language);
				}, this)
			});
		},

		show: function(){
			if (!this.isInline)
				this.picker.appendTo('body');
			this.picker.show();
			this.place();
			this._attachSecondaryEvents();
			this._trigger('show');
		},

		hide: function(){
			if (this.isInline)
				return;
			if (!this.picker.is(':visible'))
				return;
			this.focusDate = null;
			this.picker.hide().detach();
			this._detachSecondaryEvents();
			this.viewMode = this.o.startView;
			this.showMode();

			if (
				this.o.forceParse &&
				(
					this.isInput && this.element.val() ||
					this.hasInput && this.element.find('input').val()
				)
			)
				this.setValue();
			this._trigger('hide');
		},

		remove: function(){
			this.hide();
			this._detachEvents();
			this._detachSecondaryEvents();
			this.picker.remove();
			delete this.element.data().datepicker;
			if (!this.isInput){
				delete this.element.data().date;
			}
		},

		_utc_to_local: function(utc){
			return utc && new Date(utc.getTime() + (utc.getTimezoneOffset()*60000));
		},
		_local_to_utc: function(local){
			return local && new Date(local.getTime() - (local.getTimezoneOffset()*60000));
		},
		_zero_time: function(local){
			return local && new Date(local.getFullYear(), local.getMonth(), local.getDate());
		},
		_zero_utc_time: function(utc){
			return utc && new Date(Date.UTC(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate()));
		},

		getDates: function(){
			return $.map(this.dates, this._utc_to_local);
		},

		getUTCDates: function(){
			return $.map(this.dates, function(d){
				return new Date(d);
			});
		},

		getDate: function(){
			return this._utc_to_local(this.getUTCDate());
		},

		getUTCDate: function(){
			return new Date(this.dates.get(-1));
		},

		setDates: function(){
			var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
			this.update.apply(this, args);
			this._trigger('changeDate');
			this.setValue();
		},

		setUTCDates: function(){
			var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
			this.update.apply(this, $.map(args, this._utc_to_local));
			this._trigger('changeDate');
			this.setValue();
		},

		setDate: alias('setDates'),
		setUTCDate: alias('setUTCDates'),

		setValue: function(){
			var formatted = this.getFormattedDate();
			if (!this.isInput){
				if (this.component){
					this.element.find('input').val(formatted).change();
				}
			}
			else {
				this.element.val(formatted).change();
			}
		},

		getFormattedDate: function(format){
			if (format === undefined)
				format = this.o.format;

			var lang = this.o.language;
			return $.map(this.dates, function(d){
				return DPGlobal.formatDate(d, format, lang);
			}).join(this.o.multidateSeparator);
		},

		setStartDate: function(startDate){
			this._process_options({startDate: startDate});
			this.update();
			this.updateNavArrows();
		},

		setEndDate: function(endDate){
			this._process_options({endDate: endDate});
			this.update();
			this.updateNavArrows();
		},

		setDaysOfWeekDisabled: function(daysOfWeekDisabled){
			this._process_options({daysOfWeekDisabled: daysOfWeekDisabled});
			this.update();
			this.updateNavArrows();
		},

		place: function(){
			if (this.isInline)
				return;
			var calendarWidth = this.picker.outerWidth(),
				calendarHeight = this.picker.outerHeight(),
				visualPadding = 10,
				windowWidth = $window.width(),
				windowHeight = $window.height(),
				scrollTop = $window.scrollTop();

			var zIndex = parseInt(this.element.parents().filter(function(){
					return $(this).css('z-index') !== 'auto';
				}).first().css('z-index'))+10;
			var offset = this.component ? this.component.parent().offset() : this.element.offset();
			var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
			var width = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false);
			var left = offset.left,
				top = offset.top;

			this.picker.removeClass(
				'datepicker-orient-top datepicker-orient-bottom '+
				'datepicker-orient-right datepicker-orient-left'
			);

			if (this.o.orientation.x !== 'auto'){
				this.picker.addClass('datepicker-orient-' + this.o.orientation.x);
				if (this.o.orientation.x === 'right')
					left -= calendarWidth - width;
			}
			// auto x orientation is best-placement: if it crosses a window
			// edge, fudge it sideways
			else {
				// Default to left
				this.picker.addClass('datepicker-orient-left');
				if (offset.left < 0)
					left -= offset.left - visualPadding;
				else if (offset.left + calendarWidth > windowWidth)
					left = windowWidth - calendarWidth - visualPadding;
			}

			// auto y orientation is best-situation: top or bottom, no fudging,
			// decision based on which shows more of the calendar
			var yorient = this.o.orientation.y,
				top_overflow, bottom_overflow;
			if (yorient === 'auto'){
				top_overflow = -scrollTop + offset.top - calendarHeight;
				bottom_overflow = scrollTop + windowHeight - (offset.top + height + calendarHeight);
				if (Math.max(top_overflow, bottom_overflow) === bottom_overflow)
					yorient = 'top';
				else
					yorient = 'bottom';
			}
			this.picker.addClass('datepicker-orient-' + yorient);
			if (yorient === 'top')
				top += height;
			else
				top -= calendarHeight + parseInt(this.picker.css('padding-top'));

			this.picker.css({
				top: top,
				left: left,
				zIndex: zIndex
			});
		},

		_allow_update: true,
		update: function(){
			if (!this._allow_update)
				return;

			var oldDates = this.dates.copy(),
				dates = [],
				fromArgs = false;
			if (arguments.length){
				$.each(arguments, $.proxy(function(i, date){
					if (date instanceof Date)
						date = this._local_to_utc(date);
					dates.push(date);
				}, this));
				fromArgs = true;
			}
			else {
				dates = this.isInput
						? this.element.val()
						: this.element.data('date') || this.element.find('input').val();
				if (dates && this.o.multidate)
					dates = dates.split(this.o.multidateSeparator);
				else
					dates = [dates];
				delete this.element.data().date;
			}

			dates = $.map(dates, $.proxy(function(date){
				return DPGlobal.parseDate(date, this.o.format, this.o.language);
			}, this));
			dates = $.grep(dates, $.proxy(function(date){
				return (
					date < this.o.startDate ||
					date > this.o.endDate ||
					!date
				);
			}, this), true);
			this.dates.replace(dates);

			if (this.dates.length)
				this.viewDate = new Date(this.dates.get(-1));
			else if (this.viewDate < this.o.startDate)
				this.viewDate = new Date(this.o.startDate);
			else if (this.viewDate > this.o.endDate)
				this.viewDate = new Date(this.o.endDate);

			if (fromArgs){
				// setting date by clicking
				this.setValue();
			}
			else if (dates.length){
				// setting date by typing
				if (String(oldDates) !== String(this.dates))
					this._trigger('changeDate');
			}
			if (!this.dates.length && oldDates.length)
				this._trigger('clearDate');

			this.fill();
		},

		fillDow: function(){
			var dowCnt = this.o.weekStart,
				html = '<tr>';
			if (this.o.calendarWeeks){
				var cell = '<th class="cw">&nbsp;</th>';
				html += cell;
				this.picker.find('.datepicker-days thead tr:first-child').prepend(cell);
			}
			while (dowCnt < this.o.weekStart + 7){
				html += '<th class="dow">'+dates[this.o.language].daysMin[(dowCnt++)%7]+'</th>';
			}
			html += '</tr>';
			this.picker.find('.datepicker-days thead').append(html);
		},

		fillMonths: function(){
			var html = '',
			i = 0;
			while (i < 12){
				html += '<span class="month">'+dates[this.o.language].monthsShort[i++]+'</span>';
			}
			this.picker.find('.datepicker-months td').html(html);
		},

		setRange: function(range){
			if (!range || !range.length)
				delete this.range;
			else
				this.range = $.map(range, function(d){
					return d.valueOf();
				});
			this.fill();
		},

		getClassNames: function(date){
			var cls = [],
				year = this.viewDate.getUTCFullYear(),
				month = this.viewDate.getUTCMonth(),
				today = new Date();
			if (date.getUTCFullYear() < year || (date.getUTCFullYear() === year && date.getUTCMonth() < month)){
				cls.push('old');
			}
			else if (date.getUTCFullYear() > year || (date.getUTCFullYear() === year && date.getUTCMonth() > month)){
				cls.push('new');
			}
			if (this.focusDate && date.valueOf() === this.focusDate.valueOf())
				cls.push('focused');
			// Compare internal UTC date with local today, not UTC today
			if (this.o.todayHighlight &&
				date.getUTCFullYear() === today.getFullYear() &&
				date.getUTCMonth() === today.getMonth() &&
				date.getUTCDate() === today.getDate()){
				cls.push('today');
			}
			if (this.dates.contains(date) !== -1)
				cls.push('active');
			if (date.valueOf() < this.o.startDate || date.valueOf() > this.o.endDate ||
				$.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1){
				cls.push('disabled');
			}
			if (this.range){
				if (date > this.range[0] && date < this.range[this.range.length-1]){
					cls.push('range');
				}
				if ($.inArray(date.valueOf(), this.range) !== -1){
					cls.push('selected');
				}
			}
			return cls;
		},

		fill: function(){
			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth(),
				startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
				startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
				endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
				endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
				todaytxt = dates[this.o.language].today || dates['en'].today || '',
				cleartxt = dates[this.o.language].clear || dates['en'].clear || '',
				tooltip;
			this.picker.find('.datepicker-days thead th.datepicker-switch')
						.text(dates[this.o.language].months[month]+' '+year);
			this.picker.find('tfoot th.today')
						.text(todaytxt)
						.toggle(this.o.todayBtn !== false);
			this.picker.find('tfoot th.clear')
						.text(cleartxt)
						.toggle(this.o.clearBtn !== false);
			this.updateNavArrows();
			this.fillMonths();
			var prevMonth = UTCDate(year, month-1, 28),
				day = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());
			prevMonth.setUTCDate(day);
			prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7)%7);
			var nextMonth = new Date(prevMonth);
			nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
			nextMonth = nextMonth.valueOf();
			var html = [];
			var clsName;
			while (prevMonth.valueOf() < nextMonth){
				if (prevMonth.getUTCDay() === this.o.weekStart){
					html.push('<tr>');
					if (this.o.calendarWeeks){
						// ISO 8601: First week contains first thursday.
						// ISO also states week starts on Monday, but we can be more abstract here.
						var
							// Start of current week: based on weekstart/current date
							ws = new Date(+prevMonth + (this.o.weekStart - prevMonth.getUTCDay() - 7) % 7 * 864e5),
							// Thursday of this week
							th = new Date(Number(ws) + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),
							// First Thursday of year, year from thursday
							yth = new Date(Number(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay())%7*864e5),
							// Calendar week: ms between thursdays, div ms per day, div 7 days
							calWeek =  (th - yth) / 864e5 / 7 + 1;
						html.push('<td class="cw">'+ calWeek +'</td>');

					}
				}
				clsName = this.getClassNames(prevMonth);
				clsName.push('day');

				if (this.o.beforeShowDay !== $.noop){
					var before = this.o.beforeShowDay(this._utc_to_local(prevMonth));
					if (before === undefined)
						before = {};
					else if (typeof(before) === 'boolean')
						before = {enabled: before};
					else if (typeof(before) === 'string')
						before = {classes: before};
					if (before.enabled === false)
						clsName.push('disabled');
					if (before.classes)
						clsName = clsName.concat(before.classes.split(/\s+/));
					if (before.tooltip)
						tooltip = before.tooltip;
				}

				clsName = $.unique(clsName);
				html.push('<td class="'+clsName.join(' ')+'"' + (tooltip ? ' title="'+tooltip+'"' : '') + '>'+prevMonth.getUTCDate() + '</td>');
				if (prevMonth.getUTCDay() === this.o.weekEnd){
					html.push('</tr>');
				}
				prevMonth.setUTCDate(prevMonth.getUTCDate()+1);
			}
			this.picker.find('.datepicker-days tbody').empty().append(html.join(''));

			var months = this.picker.find('.datepicker-months')
						.find('th:eq(1)')
							.text(year)
							.end()
						.find('span').removeClass('active');

			$.each(this.dates, function(i, d){
				if (d.getUTCFullYear() === year)
					months.eq(d.getUTCMonth()).addClass('active');
			});

			if (year < startYear || year > endYear){
				months.addClass('disabled');
			}
			if (year === startYear){
				months.slice(0, startMonth).addClass('disabled');
			}
			if (year === endYear){
				months.slice(endMonth+1).addClass('disabled');
			}

			html = '';
			year = parseInt(year/10, 10) * 10;
			var yearCont = this.picker.find('.datepicker-years')
								.find('th:eq(1)')
									.text(year + '-' + (year + 9))
									.end()
								.find('td');
			year -= 1;
			var years = $.map(this.dates, function(d){
					return d.getUTCFullYear();
				}),
				classes;
			for (var i = -1; i < 11; i++){
				classes = ['year'];
				if (i === -1)
					classes.push('old');
				else if (i === 10)
					classes.push('new');
				if ($.inArray(year, years) !== -1)
					classes.push('active');
				if (year < startYear || year > endYear)
					classes.push('disabled');
				html += '<span class="' + classes.join(' ') + '">'+year+'</span>';
				year += 1;
			}
			yearCont.html(html);
		},

		updateNavArrows: function(){
			if (!this._allow_update)
				return;

			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth();
			switch (this.viewMode){
				case 0:
					if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear() && month <= this.o.startDate.getUTCMonth()){
						this.picker.find('.prev').css({visibility: 'hidden'});
					}
					else {
						this.picker.find('.prev').css({visibility: 'visible'});
					}
					if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear() && month >= this.o.endDate.getUTCMonth()){
						this.picker.find('.next').css({visibility: 'hidden'});
					}
					else {
						this.picker.find('.next').css({visibility: 'visible'});
					}
					break;
				case 1:
				case 2:
					if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear()){
						this.picker.find('.prev').css({visibility: 'hidden'});
					}
					else {
						this.picker.find('.prev').css({visibility: 'visible'});
					}
					if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear()){
						this.picker.find('.next').css({visibility: 'hidden'});
					}
					else {
						this.picker.find('.next').css({visibility: 'visible'});
					}
					break;
			}
		},

		click: function(e){
			e.preventDefault();
			var target = $(e.target).closest('span, td, th'),
				year, month, day;
			if (target.length === 1){
				switch (target[0].nodeName.toLowerCase()){
					case 'th':
						switch (target[0].className){
							case 'datepicker-switch':
								this.showMode(1);
								break;
							case 'prev':
							case 'next':
								var dir = DPGlobal.modes[this.viewMode].navStep * (target[0].className === 'prev' ? -1 : 1);
								switch (this.viewMode){
									case 0:
										this.viewDate = this.moveMonth(this.viewDate, dir);
										this._trigger('changeMonth', this.viewDate);
										break;
									case 1:
									case 2:
										this.viewDate = this.moveYear(this.viewDate, dir);
										if (this.viewMode === 1)
											this._trigger('changeYear', this.viewDate);
										break;
								}
								this.fill();
								break;
							case 'today':
								var date = new Date();
								date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);

								this.showMode(-2);
								var which = this.o.todayBtn === 'linked' ? null : 'view';
								this._setDate(date, which);
								break;
							case 'clear':
								var element;
								if (this.isInput)
									element = this.element;
								else if (this.component)
									element = this.element.find('input');
								if (element)
									element.val("").change();
								this.update();
								this._trigger('changeDate');
								if (this.o.autoclose)
									this.hide();
								break;
						}
						break;
					case 'span':
						if (!target.is('.disabled')){
							this.viewDate.setUTCDate(1);
							if (target.is('.month')){
								day = 1;
								month = target.parent().find('span').index(target);
								year = this.viewDate.getUTCFullYear();
								this.viewDate.setUTCMonth(month);
								this._trigger('changeMonth', this.viewDate);
								if (this.o.minViewMode === 1){
									this._setDate(UTCDate(year, month, day));
								}
							}
							else {
								day = 1;
								month = 0;
								year = parseInt(target.text(), 10)||0;
								this.viewDate.setUTCFullYear(year);
								this._trigger('changeYear', this.viewDate);
								if (this.o.minViewMode === 2){
									this._setDate(UTCDate(year, month, day));
								}
							}
							this.showMode(-1);
							this.fill();
						}
						break;
					case 'td':
						if (target.is('.day') && !target.is('.disabled')){
							day = parseInt(target.text(), 10)||1;
							year = this.viewDate.getUTCFullYear();
							month = this.viewDate.getUTCMonth();
							if (target.is('.old')){
								if (month === 0){
									month = 11;
									year -= 1;
								}
								else {
									month -= 1;
								}
							}
							else if (target.is('.new')){
								if (month === 11){
									month = 0;
									year += 1;
								}
								else {
									month += 1;
								}
							}
							this._setDate(UTCDate(year, month, day));
						}
						break;
				}
			}
			if (this.picker.is(':visible') && this._focused_from){
				$(this._focused_from).focus();
			}
			delete this._focused_from;
		},

		_toggle_multidate: function (date) {
		    
			if (!date){
			    this.dates.clear();
			    return;
			}


			if (typeof this.o.multidate === 'number' || this.o.multidate) {
			    var ix = this.dates.contains(date);

			    if (ix !== -1) {
			        this.dates.remove(ix);
			    } else {
			        this.dates.push(date);
			    }

			    if (typeof this.o.multidate === 'number')
			        while (this.dates.length > this.o.multidate)
			            this.dates.remove(0);

			    return;

			}

			this.dates.clear();
			this.dates.push(date);
			
		},

		_setDate: function(date, which){
			if (!which || which === 'date')
				this._toggle_multidate(date && new Date(date));
			if (!which || which  === 'view')
				this.viewDate = date && new Date(date);

			this.fill();
			this.setValue();
			this._trigger('changeDate');
			var element;
			if (this.isInput){
				element = this.element;
			}
			else if (this.component){
				element = this.element.find('input');
			}
			if (element){
				element.change();
			}
			if (this.o.autoclose && (!which || which === 'date')){
				this.hide();
			}
		},

		moveMonth: function(date, dir){
			if (!date)
				return undefined;
			if (!dir)
				return date;
			var new_date = new Date(date.valueOf()),
				day = new_date.getUTCDate(),
				month = new_date.getUTCMonth(),
				mag = Math.abs(dir),
				new_month, test;
			dir = dir > 0 ? 1 : -1;
			if (mag === 1){
				test = dir === -1
					// If going back one month, make sure month is not current month
					// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
					? function(){
						return new_date.getUTCMonth() === month;
					}
					// If going forward one month, make sure month is as expected
					// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
					: function(){
						return new_date.getUTCMonth() !== new_month;
					};
				new_month = month + dir;
				new_date.setUTCMonth(new_month);
				// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
				if (new_month < 0 || new_month > 11)
					new_month = (new_month + 12) % 12;
			}
			else {
				// For magnitudes >1, move one month at a time...
				for (var i=0; i < mag; i++)
					// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
					new_date = this.moveMonth(new_date, dir);
				// ...then reset the day, keeping it in the new month
				new_month = new_date.getUTCMonth();
				new_date.setUTCDate(day);
				test = function(){
					return new_month !== new_date.getUTCMonth();
				};
			}
			// Common date-resetting loop -- if date is beyond end of month, make it
			// end of month
			while (test()){
				new_date.setUTCDate(--day);
				new_date.setUTCMonth(new_month);
			}
			return new_date;
		},

		moveYear: function(date, dir){
			return this.moveMonth(date, dir*12);
		},

		dateWithinRange: function(date){
			return date >= this.o.startDate && date <= this.o.endDate;
		},

		keydown: function(e){
			if (this.picker.is(':not(:visible)')){
				if (e.keyCode === 27) // allow escape to hide and re-show picker
					this.show();
				return;
			}
			var dateChanged = false,
				dir, newDate, newViewDate,
				focusDate = this.focusDate || this.viewDate;
			switch (e.keyCode){
				case 27: // escape
					if (this.focusDate){
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.fill();
					}
					else
						this.hide();
					e.preventDefault();
					break;
				case 37: // left
				case 39: // right
					if (!this.o.keyboardNavigation)
						break;
					dir = e.keyCode === 37 ? -1 : 1;
					if (e.ctrlKey){
						newDate = this.moveYear(this.dates.get(-1) || UTCToday(), dir);
						newViewDate = this.moveYear(focusDate, dir);
						this._trigger('changeYear', this.viewDate);
					}
					else if (e.shiftKey){
						newDate = this.moveMonth(this.dates.get(-1) || UTCToday(), dir);
						newViewDate = this.moveMonth(focusDate, dir);
						this._trigger('changeMonth', this.viewDate);
					}
					else {
						newDate = new Date(this.dates.get(-1) || UTCToday());
						newDate.setUTCDate(newDate.getUTCDate() + dir);
						newViewDate = new Date(focusDate);
						newViewDate.setUTCDate(focusDate.getUTCDate() + dir);
					}
					if (this.dateWithinRange(newDate)){
						this.focusDate = this.viewDate = newViewDate;
						this.setValue();
						this.fill();
						e.preventDefault();
					}
					break;
				case 38: // up
				case 40: // down
					if (!this.o.keyboardNavigation)
						break;
					dir = e.keyCode === 38 ? -1 : 1;
					if (e.ctrlKey){
						newDate = this.moveYear(this.dates.get(-1) || UTCToday(), dir);
						newViewDate = this.moveYear(focusDate, dir);
						this._trigger('changeYear', this.viewDate);
					}
					else if (e.shiftKey){
						newDate = this.moveMonth(this.dates.get(-1) || UTCToday(), dir);
						newViewDate = this.moveMonth(focusDate, dir);
						this._trigger('changeMonth', this.viewDate);
					}
					else {
						newDate = new Date(this.dates.get(-1) || UTCToday());
						newDate.setUTCDate(newDate.getUTCDate() + dir * 7);
						newViewDate = new Date(focusDate);
						newViewDate.setUTCDate(focusDate.getUTCDate() + dir * 7);
					}
					if (this.dateWithinRange(newDate)){
						this.focusDate = this.viewDate = newViewDate;
						this.setValue();
						this.fill();
						e.preventDefault();
					}
					break;
				case 32: // spacebar
					// Spacebar is used in manually typing dates in some formats.
					// As such, its behavior should not be hijacked.
					break;
				case 13: // enter
					focusDate = this.focusDate || this.dates.get(-1) || this.viewDate;
					this._toggle_multidate(focusDate);
					dateChanged = true;
					this.focusDate = null;
					this.viewDate = this.dates.get(-1) || this.viewDate;
					this.setValue();
					this.fill();
					if (this.picker.is(':visible')){
						e.preventDefault();
						if (this.o.autoclose)
							this.hide();
					}
					break;
				case 9: // tab
				    focusDate = null;
				    this.viewDate = this.dates.get(-1) || this.viewDate;
					this.fill();
					this.hide();
					break;
			}
			if (dateChanged){
				if (this.dates.length)
					this._trigger('changeDate');
				else
					this._trigger('clearDate');
				var element;
				if (this.isInput){
					element = this.element;
				}
				else if (this.component){
					element = this.element.find('input');
				}
				if (element){
					element.change();
				}
			}
		},

		showMode: function(dir){
			if (dir){
				this.viewMode = Math.max(this.o.minViewMode, Math.min(2, this.viewMode + dir));
			}
			this.picker
				.find('>div')
				.hide()
				.filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName)
					.css('display', 'block');
			this.updateNavArrows();
		}
	};

	var DateRangePicker = function(element, options){
		this.element = $(element);
		this.inputs = $.map(options.inputs, function(i){
			return i.jquery ? i[0] : i;
		});
		delete options.inputs;

		$(this.inputs)
			.datepicker(options)
			.bind('changeDate', $.proxy(this.dateUpdated, this));

		this.pickers = $.map(this.inputs, function(i){
			return $(i).data('datepicker');
		});
		this.updateDates();
	};
	DateRangePicker.prototype = {
		updateDates: function(){
			this.dates = $.map(this.pickers, function(i){
				return i.getUTCDate();
			});
			this.updateRanges();
		},
		updateRanges: function(){
			var range = $.map(this.dates, function(d){
				return d.valueOf();
			});
			$.each(this.pickers, function(i, p){
				p.setRange(range);
			});
		},
		dateUpdated: function(e){
			// `this.updating` is a workaround for preventing infinite recursion
			// between `changeDate` triggering and `setUTCDate` calling.  Until
			// there is a better mechanism.
			if (this.updating)
				return;
			this.updating = true;

			var dp = $(e.target).data('datepicker'),
				new_date = dp.getUTCDate(),
				i = $.inArray(e.target, this.inputs),
				l = this.inputs.length;
			if (i === -1)
				return;

			$.each(this.pickers, function(i, p){
				if (!p.getUTCDate())
					p.setUTCDate(new_date);
			});

			if (new_date < this.dates[i]){
				// Date being moved earlier/left
				while (i >= 0 && new_date < this.dates[i]){
					this.pickers[i--].setUTCDate(new_date);
				}
			}
			else if (new_date > this.dates[i]){
				// Date being moved later/right
				while (i < l && new_date > this.dates[i]){
					this.pickers[i++].setUTCDate(new_date);
				}
			}
			this.updateDates();

			delete this.updating;
		},
		remove: function(){
			$.map(this.pickers, function(p){ p.remove(); });
			delete this.element.data().datepicker;
		}
	};

	function opts_from_el(el, prefix){
		// Derive options from element data-attrs
		var data = $(el).data(),
			out = {}, inkey,
			replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])');
		prefix = new RegExp('^' + prefix.toLowerCase());
		function re_lower(_,a){
			return a.toLowerCase();
		}
		for (var key in data)
			if (prefix.test(key)){
				inkey = key.replace(replace, re_lower);
				out[inkey] = data[key];
			}
		return out;
	}

	function opts_from_locale(lang){
		// Derive options from locale plugins
		var out = {};
		// Check if "de-DE" style date is available, if not language should
		// fallback to 2 letter code eg "de"
		if (!dates[lang]){
			lang = lang.split('-')[0];
			if (!dates[lang])
				return;
		}
		var d = dates[lang];
		$.each(locale_opts, function(i,k){
			if (k in d)
				out[k] = d[k];
		});
		return out;
	}

	var old = $.fn.datepicker;
	$.fn.datepicker = function(option){
		var args = Array.apply(null, arguments);
		args.shift();
		var internal_return;
		this.each(function(){
			var $this = $(this),
				data = $this.data('datepicker'),
				options = typeof option === 'object' && option;
			if (!data){
				var elopts = opts_from_el(this, 'date'),
					// Preliminary otions
					xopts = $.extend({}, defaults, elopts, options),
					locopts = opts_from_locale(xopts.language),
					// Options priority: js args, data-attrs, locales, defaults
					opts = $.extend({}, defaults, locopts, elopts, options);
				if ($this.is('.input-daterange') || opts.inputs){
					var ropts = {
						inputs: opts.inputs || $this.find('input').toArray()
					};
					$this.data('datepicker', (data = new DateRangePicker(this, $.extend(opts, ropts))));
				}
				else {
					$this.data('datepicker', (data = new Datepicker(this, opts)));
				}
			}
			if (typeof option === 'string' && typeof data[option] === 'function'){
				internal_return = data[option].apply(data, args);
				if (internal_return !== undefined)
					return false;
			}
		});
		if (internal_return !== undefined)
			return internal_return;
		else
			return this;
	};

	var defaults = $.fn.datepicker.defaults = {
		autoclose: false,
		beforeShowDay: $.noop,
		calendarWeeks: false,
		clearBtn: false,
		daysOfWeekDisabled: [],
		endDate: Infinity,
		forceParse: true,
		format: 'mm/dd/yyyy',
		keyboardNavigation: true,
		language: 'en',
		minViewMode: 0,
		multidate: false,
		multidateSeparator: ',',
		orientation: "auto",
		rtl: false,
		startDate: -Infinity,
		startView: 0,
		todayBtn: false,
		todayHighlight: false,
		weekStart: 0
	};
	var locale_opts = $.fn.datepicker.locale_opts = [
		'format',
		'rtl',
		'weekStart'
	];
	$.fn.datepicker.Constructor = Datepicker;
	var dates = $.fn.datepicker.dates = {
		en: {
			days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
			daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
			daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
			months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
			monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			today: "Today",
			clear: "Clear"
		}
	};

	var DPGlobal = {
		modes: [
			{
				clsName: 'days',
				navFnc: 'Month',
				navStep: 1
			},
			{
				clsName: 'months',
				navFnc: 'FullYear',
				navStep: 1
			},
			{
				clsName: 'years',
				navFnc: 'FullYear',
				navStep: 10
		}],
		isLeapYear: function(year){
			return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));
		},
		getDaysInMonth: function(year, month){
			return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
		},
		validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
		nonpunctuation: /[^ -\/:-@\[\u3400-\u9fff-`{-~\t\n\r]+/g,
		parseFormat: function(format){
			// IE treats \0 as a string end in inputs (truncating the value),
			// so it's a bad format delimiter, anyway
			var separators = format.replace(this.validParts, '\0').split('\0'),
				parts = format.match(this.validParts);
			if (!separators || !separators.length || !parts || parts.length === 0){
				throw new Error("Invalid date format.");
			}
			return {separators: separators, parts: parts};
		},
		parseDate: function(date, format, language){
			if (!date)
				return undefined;
			if (date instanceof Date)
				return date;
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			var part_re = /([\-+]\d+)([dmwy])/,
				parts = date.match(/([\-+]\d+)([dmwy])/g),
				part, dir, i;
			if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/.test(date)){
				date = new Date();
				for (i=0; i < parts.length; i++){
					part = part_re.exec(parts[i]);
					dir = parseInt(part[1]);
					switch (part[2]){
						case 'd':
							date.setUTCDate(date.getUTCDate() + dir);
							break;
						case 'm':
							date = Datepicker.prototype.moveMonth.call(Datepicker.prototype, date, dir);
							break;
						case 'w':
							date.setUTCDate(date.getUTCDate() + dir * 7);
							break;
						case 'y':
							date = Datepicker.prototype.moveYear.call(Datepicker.prototype, date, dir);
							break;
					}
				}
				return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);
			}
			parts = date && date.match(this.nonpunctuation) || [];
			date = new Date();
			var parsed = {},
				setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
				setters_map = {
					yyyy: function(d,v){
						return d.setUTCFullYear(v);
					},
					yy: function(d,v){
						return d.setUTCFullYear(2000+v);
					},
					m: function(d,v){
						if (isNaN(d))
							return d;
						v -= 1;
						while (v < 0) v += 12;
						v %= 12;
						d.setUTCMonth(v);
						while (d.getUTCMonth() !== v)
							d.setUTCDate(d.getUTCDate()-1);
						return d;
					},
					d: function(d,v){
						return d.setUTCDate(v);
					}
				},
				val, filtered;
			setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
			setters_map['dd'] = setters_map['d'];
			date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
			var fparts = format.parts.slice();
			// Remove noop parts
			if (parts.length !== fparts.length){
				fparts = $(fparts).filter(function(i,p){
					return $.inArray(p, setters_order) !== -1;
				}).toArray();
			}
			// Process remainder
			function match_part(){
				var m = this.slice(0, parts[i].length),
					p = parts[i].slice(0, m.length);
				return m === p;
			}
			if (parts.length === fparts.length){
				var cnt;
				for (i=0, cnt = fparts.length; i < cnt; i++){
					val = parseInt(parts[i], 10);
					part = fparts[i];
					if (isNaN(val)){
						switch (part){
							case 'MM':
								filtered = $(dates[language].months).filter(match_part);
								val = $.inArray(filtered[0], dates[language].months) + 1;
								break;
							case 'M':
								filtered = $(dates[language].monthsShort).filter(match_part);
								val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
								break;
						}
					}
					parsed[part] = val;
				}
				var _date, s;
				for (i=0; i < setters_order.length; i++){
					s = setters_order[i];
					if (s in parsed && !isNaN(parsed[s])){
						_date = new Date(date);
						setters_map[s](_date, parsed[s]);
						if (!isNaN(_date))
							date = _date;
					}
				}
			}
			return date;
		},
		formatDate: function(date, format, language){
			if (!date)
				return '';
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			var val = {
				d: date.getUTCDate(),
				D: dates[language].daysShort[date.getUTCDay()],
				DD: dates[language].days[date.getUTCDay()],
				m: date.getUTCMonth() + 1,
				M: dates[language].monthsShort[date.getUTCMonth()],
				MM: dates[language].months[date.getUTCMonth()],
				yy: date.getUTCFullYear().toString().substring(2),
				yyyy: date.getUTCFullYear()
			};
			val.dd = (val.d < 10 ? '0' : '') + val.d;
			val.mm = (val.m < 10 ? '0' : '') + val.m;
			date = [];
			var seps = $.extend([], format.separators);
			for (var i=0, cnt = format.parts.length; i <= cnt; i++){
				if (seps.length)
					date.push(seps.shift());
				date.push(val[format.parts[i]]);
			}
			return date.join('');
		},
		headTemplate: '<thead>'+
							'<tr>'+
								'<th class="prev">&laquo;</th>'+
								'<th colspan="5" class="datepicker-switch"></th>'+
								'<th class="next">&raquo;</th>'+
							'</tr>'+
						'</thead>',
		contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
		footTemplate: '<tfoot>'+
							'<tr>'+
								'<th colspan="7" class="today"></th>'+
							'</tr>'+
							'<tr>'+
								'<th colspan="7" class="clear"></th>'+
							'</tr>'+
						'</tfoot>'
	};
	DPGlobal.template = '<div class="datepicker">'+
							'<div class="datepicker-days">'+
								'<table class=" table-condensed">'+
									DPGlobal.headTemplate+
									'<tbody></tbody>'+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-months">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-years">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
						'</div>';

	$.fn.datepicker.DPGlobal = DPGlobal;


	/* DATEPICKER NO CONFLICT
	* =================== */

	$.fn.datepicker.noConflict = function(){
		$.fn.datepicker = old;
		return this;
	};


	/* DATEPICKER DATA-API
	* ================== */

	$(document).on(
		'focus.datepicker.data-api click.datepicker.data-api',
		'[data-provide="datepicker"]',
		function(e){
			var $this = $(this);
			if ($this.data('datepicker'))
				return;
			e.preventDefault();
			// component click requires us to explicitly show it
			$this.datepicker('show');
		}
	);
	$(function(){
		$('[data-provide="datepicker-inline"]').datepicker();
	});

}(window.jQuery));
;
/*!
 * Timepicker Component for Twitter Bootstrap
 *
 * Copyright 2013 Joris de Wit
 *
 * Contributors https://github.com/jdewit/bootstrap-timepicker/graphs/contributors
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
(function ($, window, document, undefined) {
    'use strict';

    // TIMEPICKER PUBLIC CLASS DEFINITION
    var Timepicker = function (element, options) {
        this.widget = '';
        this.$element = $(element);
        this.defaultTime = options.defaultTime;
        this.disableFocus = options.disableFocus;
        this.disableMousewheel = options.disableMousewheel;
        this.isOpen = options.isOpen;
        this.minuteStep = options.minuteStep;
        this.modalBackdrop = options.modalBackdrop;
        this.orientation = options.orientation;
        this.secondStep = options.secondStep;
        this.showInputs = options.showInputs;
        this.showMeridian = options.showMeridian;
        this.showSeconds = options.showSeconds;
        this.template = options.template;
        this.appendWidgetTo = options.appendWidgetTo;
        this.showWidgetOnAddonClick = options.showWidgetOnAddonClick;

        this._init();
    };

    Timepicker.prototype = {

        constructor: Timepicker,
        _init: function () {
            var self = this;

            if (this.showWidgetOnAddonClick && (this.$element.parent().hasClass('input-append') || this.$element.parent().hasClass('input-prepend'))) {
                this.$element.parent('.input-append, .input-prepend').find('.add-on').on({
                    'click.timepicker': $.proxy(this.showWidget, this)
                });
                this.$element.on({
                    'focus.timepicker': $.proxy(this.highlightUnit, this),
                    'click.timepicker': $.proxy(this.highlightUnit, this),
                    'keydown.timepicker': $.proxy(this.elementKeydown, this),
                    'blur.timepicker': $.proxy(this.blurElement, this),
                    'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy(this.mousewheel, this)
                });
            } else {
                if (this.template) {
                    this.$element.on({
                        'focus.timepicker': $.proxy(this.showWidget, this),
                        'click.timepicker': $.proxy(this.showWidget, this),
                        'blur.timepicker': $.proxy(this.blurElement, this),
                        'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy(this.mousewheel, this)
                    });
                } else {
                    this.$element.on({
                        'focus.timepicker': $.proxy(this.highlightUnit, this),
                        'click.timepicker': $.proxy(this.highlightUnit, this),
                        'keydown.timepicker': $.proxy(this.elementKeydown, this),
                        'blur.timepicker': $.proxy(this.blurElement, this),
                        'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy(this.mousewheel, this)
                    });
                }
            }

            if (this.template !== false) {
                this.$widget = $(this.getTemplate()).on('click', $.proxy(this.widgetClick, this));
            } else {
                this.$widget = false;
            }

            if (this.showInputs && this.$widget !== false) {
                this.$widget.find('input').each(function () {
                    $(this).on({
                        'click.timepicker': function () { $(this).select(); },
                        'keydown.timepicker': $.proxy(self.widgetKeydown, self),
                        'keyup.timepicker': $.proxy(self.widgetKeyup, self)
                    });
                });
            }

            this.setDefaultTime(this.defaultTime);
        },

        blurElement: function () {
            this.highlightedUnit = null;
            this.updateFromElementVal();
        },

        clear: function () {
            this.hour = '';
            this.minute = '';
            this.second = '';
            this.meridian = '';

            this.$element.val('');
        },

        decrementHour: function () {
            if (this.showMeridian) {
                if (this.hour === 1) {
                    this.hour = 12;
                } else if (this.hour === 12) {
                    this.hour--;

                    return this.toggleMeridian();
                } else if (this.hour === 0) {
                    this.hour = 11;

                    return this.toggleMeridian();
                } else {
                    this.hour--;
                }
            } else {
                if (this.hour <= 0) {
                    this.hour = 23;
                } else {
                    this.hour--;
                }
            }
        },

        decrementMinute: function (step) {
            var newVal;

            if (step) {
                newVal = this.minute - step;
            } else {
                newVal = this.minute - this.minuteStep;
            }

            if (newVal < 0) {
                this.decrementHour();
                this.minute = newVal + 60;
            } else {
                this.minute = newVal;
            }
        },

        decrementSecond: function () {
            var newVal = this.second - this.secondStep;

            if (newVal < 0) {
                this.decrementMinute(true);
                this.second = newVal + 60;
            } else {
                this.second = newVal;
            }
        },

        elementKeydown: function (e) {
            switch (e.keyCode) {
                case 9: //tab
                case 27: // escape
                    this.updateFromElementVal();
                    break;
                case 37: // left arrow
                    e.preventDefault();
                    this.highlightPrevUnit();
                    break;
                case 38: // up arrow
                    e.preventDefault();
                    switch (this.highlightedUnit) {
                        case 'hour':
                            this.incrementHour();
                            this.highlightHour();
                            break;
                        case 'minute':
                            this.incrementMinute();
                            this.highlightMinute();
                            break;
                        case 'second':
                            this.incrementSecond();
                            this.highlightSecond();
                            break;
                        case 'meridian':
                            this.toggleMeridian();
                            this.highlightMeridian();
                            break;
                    }
                    this.update();
                    break;
                case 39: // right arrow
                    e.preventDefault();
                    this.highlightNextUnit();
                    break;
                case 40: // down arrow
                    e.preventDefault();
                    switch (this.highlightedUnit) {
                        case 'hour':
                            this.decrementHour();
                            this.highlightHour();
                            break;
                        case 'minute':
                            this.decrementMinute();
                            this.highlightMinute();
                            break;
                        case 'second':
                            this.decrementSecond();
                            this.highlightSecond();
                            break;
                        case 'meridian':
                            this.toggleMeridian();
                            this.highlightMeridian();
                            break;
                    }

                    this.update();
                    break;
            }
        },

        getCursorPosition: function () {
            var input = this.$element.get(0);

            if ('selectionStart' in input) {// Standard-compliant browsers

                return input.selectionStart;
            } else if (document.selection) {// IE fix
                input.focus();
                var sel = document.selection.createRange(),
                  selLen = document.selection.createRange().text.length;

                sel.moveStart('character', -input.value.length);

                return sel.text.length - selLen;
            }
        },

        getTemplate: function () {
            var template,
              hourTemplate,
              minuteTemplate,
              secondTemplate,
              meridianTemplate,
              templateContent;

            if (this.showInputs) {
                hourTemplate = '<input type="text" class="bootstrap-timepicker-hour" maxlength="2"/>';
                minuteTemplate = '<input type="text" class="bootstrap-timepicker-minute" maxlength="2"/>';
                secondTemplate = '<input type="text" class="bootstrap-timepicker-second" maxlength="2"/>';
                meridianTemplate = '<input type="text" class="bootstrap-timepicker-meridian" maxlength="2"/>';
            } else {
                hourTemplate = '<span class="bootstrap-timepicker-hour"></span>';
                minuteTemplate = '<span class="bootstrap-timepicker-minute"></span>';
                secondTemplate = '<span class="bootstrap-timepicker-second"></span>';
                meridianTemplate = '<span class="bootstrap-timepicker-meridian"></span>';
            }

            templateContent = '<table>' +
               '<tr>' +
                 '<td><a href="#" data-action="incrementHour"><i class="fa fa-chevron-up"></i></a></td>' +
                 '<td class="separator">&nbsp;</td>' +
                 '<td><a href="#" data-action="incrementMinute"><i class="fa fa-chevron-up"></i></a></td>' +
                 (this.showSeconds ?
                   '<td class="separator">&nbsp;</td>' +
                   '<td><a href="#" data-action="incrementSecond"><i class="fa fa-chevron-up"></i></a></td>'
                 : '') +
                 (this.showMeridian ?
                   '<td class="separator">&nbsp;</td>' +
                   '<td class="meridian-column"><a href="#" data-action="toggleMeridian"><i class="fa fa-chevron-up"></i></a></td>'
                 : '') +
               '</tr>' +
               '<tr>' +
                 '<td>' + hourTemplate + '</td> ' +
                 '<td class="separator">:</td>' +
                 '<td>' + minuteTemplate + '</td> ' +
                 (this.showSeconds ?
                  '<td class="separator">:</td>' +
                  '<td>' + secondTemplate + '</td>'
                 : '') +
                 (this.showMeridian ?
                  '<td class="separator">&nbsp;</td>' +
                  '<td>' + meridianTemplate + '</td>'
                 : '') +
               '</tr>' +
               '<tr>' +
                 '<td><a href="#" data-action="decrementHour"><i class="fa fa-chevron-down"></i></a></td>' +
                 '<td class="separator"></td>' +
                 '<td><a href="#" data-action="decrementMinute"><i class="fa fa-chevron-down"></i></a></td>' +
                 (this.showSeconds ?
                  '<td class="separator">&nbsp;</td>' +
                  '<td><a href="#" data-action="decrementSecond"><i class="fa fa-chevron-down"></i></a></td>'
                 : '') +
                 (this.showMeridian ?
                  '<td class="separator">&nbsp;</td>' +
                  '<td><a href="#" data-action="toggleMeridian"><i class="fa fa-chevron-down"></i></a></td>'
                 : '') +
               '</tr>' +
             '</table>';

            switch (this.template) {
                case 'modal':
                    template = '<div class="bootstrap-timepicker-widget modal hide fade in" data-backdrop="' + (this.modalBackdrop ? 'true' : 'false') + '">' +
                      '<div class="modal-header">' +
                        '<a href="#" class="close" data-dismiss="modal">×</a>' +
                        '<h3>Pick a Time</h3>' +
                      '</div>' +
                      '<div class="modal-content">' +
                        templateContent +
                      '</div>' +
                      '<div class="modal-footer">' +
                        '<a href="#" class="btn btn-primary" data-dismiss="modal">OK</a>' +
                      '</div>' +
                    '</div>';
                    break;
                case 'dropdown':
                    template = '<div class="bootstrap-timepicker-widget dropdown-menu">' + templateContent + '</div>';
                    break;
            }

            return template;
        },

        getTime: function () {
            if (this.hour === '') {
                return '';
            }

            return this.hour + ':' + (this.minute.toString().length === 1 ? '0' + this.minute : this.minute) + (this.showSeconds ? ':' + (this.second.toString().length === 1 ? '0' + this.second : this.second) : '') + (this.showMeridian ? ' ' + this.meridian : '');
        },

        hideWidget: function () {
            if (this.isOpen === false) {
                return;
            }

            this.$element.trigger({
                'type': 'hide.timepicker',
                'time': {
                    'value': this.getTime(),
                    'hours': this.hour,
                    'minutes': this.minute,
                    'seconds': this.second,
                    'meridian': this.meridian
                }
            });

            if (this.template === 'modal' && this.$widget.modal) {
                this.$widget.modal('hide');
            } else {
                this.$widget.removeClass('open');
            }

            $(document).off('mousedown.timepicker, touchend.timepicker');

            this.isOpen = false;
            // show/hide approach taken by datepicker
            this.$widget.detach();
        },

        highlightUnit: function () {
            this.position = this.getCursorPosition();
            if (this.position >= 0 && this.position <= 2) {
                this.highlightHour();
            } else if (this.position >= 3 && this.position <= 5) {
                this.highlightMinute();
            } else if (this.position >= 6 && this.position <= 8) {
                if (this.showSeconds) {
                    this.highlightSecond();
                } else {
                    this.highlightMeridian();
                }
            } else if (this.position >= 9 && this.position <= 11) {
                this.highlightMeridian();
            }
        },

        highlightNextUnit: function () {
            switch (this.highlightedUnit) {
                case 'hour':
                    this.highlightMinute();
                    break;
                case 'minute':
                    if (this.showSeconds) {
                        this.highlightSecond();
                    } else if (this.showMeridian) {
                        this.highlightMeridian();
                    } else {
                        this.highlightHour();
                    }
                    break;
                case 'second':
                    if (this.showMeridian) {
                        this.highlightMeridian();
                    } else {
                        this.highlightHour();
                    }
                    break;
                case 'meridian':
                    this.highlightHour();
                    break;
            }
        },

        highlightPrevUnit: function () {
            switch (this.highlightedUnit) {
                case 'hour':
                    if (this.showMeridian) {
                        this.highlightMeridian();
                    } else if (this.showSeconds) {
                        this.highlightSecond();
                    } else {
                        this.highlightMinute();
                    }
                    break;
                case 'minute':
                    this.highlightHour();
                    break;
                case 'second':
                    this.highlightMinute();
                    break;
                case 'meridian':
                    if (this.showSeconds) {
                        this.highlightSecond();
                    } else {
                        this.highlightMinute();
                    }
                    break;
            }
        },

        highlightHour: function () {
            var $element = this.$element.get(0),
                self = this;

            this.highlightedUnit = 'hour';

            if ($element.setSelectionRange) {
                setTimeout(function () {
                    if (self.hour < 10) {
                        $element.setSelectionRange(0, 1);
                    } else {
                        $element.setSelectionRange(0, 2);
                    }
                }, 0);
            }
        },

        highlightMinute: function () {
            var $element = this.$element.get(0),
                self = this;

            this.highlightedUnit = 'minute';

            if ($element.setSelectionRange) {
                setTimeout(function () {
                    if (self.hour < 10) {
                        $element.setSelectionRange(2, 4);
                    } else {
                        $element.setSelectionRange(3, 5);
                    }
                }, 0);
            }
        },

        highlightSecond: function () {
            var $element = this.$element.get(0),
                self = this;

            this.highlightedUnit = 'second';

            if ($element.setSelectionRange) {
                setTimeout(function () {
                    if (self.hour < 10) {
                        $element.setSelectionRange(5, 7);
                    } else {
                        $element.setSelectionRange(6, 8);
                    }
                }, 0);
            }
        },

        highlightMeridian: function () {
            var $element = this.$element.get(0),
                self = this;

            this.highlightedUnit = 'meridian';

            if ($element.setSelectionRange) {
                if (this.showSeconds) {
                    setTimeout(function () {
                        if (self.hour < 10) {
                            $element.setSelectionRange(8, 10);
                        } else {
                            $element.setSelectionRange(9, 11);
                        }
                    }, 0);
                } else {
                    setTimeout(function () {
                        if (self.hour < 10) {
                            $element.setSelectionRange(5, 7);
                        } else {
                            $element.setSelectionRange(6, 8);
                        }
                    }, 0);
                }
            }
        },

        incrementHour: function () {
            if (this.showMeridian) {
                if (this.hour === 11) {
                    this.hour++;
                    return this.toggleMeridian();
                } else if (this.hour === 12) {
                    this.hour = 0;
                }
            }
            if (this.hour === 23) {
                this.hour = 0;

                return;
            }
            this.hour++;
        },

        incrementMinute: function (step) {
            var newVal;

            if (step) {
                newVal = this.minute + step;
            } else {
                newVal = this.minute + this.minuteStep - (this.minute % this.minuteStep);
            }

            if (newVal > 59) {
                this.incrementHour();
                this.minute = newVal - 60;
            } else {
                this.minute = newVal;
            }
        },

        incrementSecond: function () {
            var newVal = this.second + this.secondStep - (this.second % this.secondStep);

            if (newVal > 59) {
                this.incrementMinute(true);
                this.second = newVal - 60;
            } else {
                this.second = newVal;
            }
        },

        mousewheel: function (e) {
            if (this.disableMousewheel) {
                return;
            }

            e.preventDefault();
            e.stopPropagation();

            var delta = e.originalEvent.wheelDelta || -e.originalEvent.detail,
                scrollTo = null;

            if (e.type === 'mousewheel') {
                scrollTo = (e.originalEvent.wheelDelta * -1);
            }
            else if (e.type === 'DOMMouseScroll') {
                scrollTo = 40 * e.originalEvent.detail;
            }

            if (scrollTo) {
                e.preventDefault();
                $(this).scrollTop(scrollTo + $(this).scrollTop());
            }

            switch (this.highlightedUnit) {
                case 'minute':
                    if (delta > 0) {
                        this.incrementMinute();
                    } else {
                        this.decrementMinute();
                    }
                    this.highlightMinute();
                    break;
                case 'second':
                    if (delta > 0) {
                        this.incrementSecond();
                    } else {
                        this.decrementSecond();
                    }
                    this.highlightSecond();
                    break;
                case 'meridian':
                    this.toggleMeridian();
                    this.highlightMeridian();
                    break;
                default:
                    if (delta > 0) {
                        this.incrementHour();
                    } else {
                        this.decrementHour();
                    }
                    this.highlightHour();
                    break;
            }

            return false;
        },

        // This method was adapted from bootstrap-datepicker.
        place: function () {
            if (this.isInline) {
                return;
            }
            var widgetWidth = this.$widget.outerWidth(), widgetHeight = this.$widget.outerHeight(), visualPadding = 10, windowWidth =
              $(window).width(), windowHeight = $(window).height(), scrollTop = $(window).scrollTop();

            var zIndex = parseInt(this.$element.parents().filter(function () { }).first().css('z-index'), 10) + 10;
            var offset = this.component ? this.component.parent().offset() : this.$element.offset();
            var height = this.component ? this.component.outerHeight(true) : this.$element.outerHeight(false);
            var width = this.component ? this.component.outerWidth(true) : this.$element.outerWidth(false);
            var left = offset.left, top = offset.top;

            this.$widget.removeClass('timepicker-orient-top timepicker-orient-bottom timepicker-orient-right timepicker-orient-left');

            if (this.orientation.x !== 'auto') {
                this.picker.addClass('datepicker-orient-' + this.orientation.x);
                if (this.orientation.x === 'right') {
                    left -= widgetWidth - width;
                }
            } else {
                // auto x orientation is best-placement: if it crosses a window edge, fudge it sideways
                // Default to left
                this.$widget.addClass('timepicker-orient-left');
                if (offset.left < 0) {
                    left -= offset.left - visualPadding;
                } else if (offset.left + widgetWidth > windowWidth) {
                    left = windowWidth - widgetWidth - visualPadding;
                }
            }
            // auto y orientation is best-situation: top or bottom, no fudging, decision based on which shows more of the widget
            var yorient = this.orientation.y, topOverflow, bottomOverflow;
            if (yorient === 'auto') {
                topOverflow = -scrollTop + offset.top - widgetHeight;
                bottomOverflow = scrollTop + windowHeight - (offset.top + height + widgetHeight);
                if (Math.max(topOverflow, bottomOverflow) === bottomOverflow) {
                    yorient = 'top';
                } else {
                    yorient = 'bottom';
                }
            }
            this.$widget.addClass('timepicker-orient-' + yorient);
            if (yorient === 'top') {
                top += height;
            } else {
                top -= widgetHeight + parseInt(this.$widget.css('padding-top'), 10);
            }

            this.$widget.css({
                top: top,
                left: left,
                zIndex: zIndex
            });
        },

        remove: function () {
            $('document').off('.timepicker');
            if (this.$widget) {
                this.$widget.remove();
            }
            delete this.$element.data().timepicker;
        },

        setDefaultTime: function (defaultTime) {
            if (!this.$element.val()) {
                if (defaultTime === 'current') {
                    var dTime = new Date(),
                      hours = dTime.getHours(),
                      minutes = dTime.getMinutes(),
                      seconds = dTime.getSeconds(),
                      meridian = 'AM';

                    if (seconds !== 0) {
                        seconds = Math.ceil(dTime.getSeconds() / this.secondStep) * this.secondStep;
                        if (seconds === 60) {
                            minutes += 1;
                            seconds = 0;
                        }
                    }

                    if (minutes !== 0) {
                        minutes = Math.ceil(dTime.getMinutes() / this.minuteStep) * this.minuteStep;
                        if (minutes === 60) {
                            hours += 1;
                            minutes = 0;
                        }
                    }

                    if (this.showMeridian) {
                        if (hours === 0) {
                            hours = 12;
                        } else if (hours >= 12) {
                            if (hours > 12) {
                                hours = hours - 12;
                            }
                            meridian = 'PM';
                        } else {
                            meridian = 'AM';
                        }
                    }

                    this.hour = hours;
                    this.minute = minutes;
                    this.second = seconds;
                    this.meridian = meridian;

                    this.update();

                } else if (defaultTime === false) {
                    this.hour = 0;
                    this.minute = 0;
                    this.second = 0;
                    this.meridian = 'AM';
                } else {
                    this.setTime(defaultTime);
                }
            } else {
                this.updateFromElementVal();
            }
        },

        setTime: function (time, ignoreWidget) {
            if (!time) {
                this.clear();
                return;
            }

            var timeArray,
                hour,
                minute,
                second,
                meridian;

            if (typeof time === 'object' && time.getMonth) {
                // this is a date object
                hour = time.getHours();
                minute = time.getMinutes();
                second = time.getSeconds();

                if (this.showMeridian) {
                    meridian = 'AM';
                    if (hour > 12) {
                        meridian = 'PM';
                        hour = hour % 12;
                    }

                    if (hour === 12) {
                        meridian = 'PM';
                    }
                }
            } else {
                if (time.match(/p/i) !== null) {
                    meridian = 'PM';
                } else {
                    meridian = 'AM';
                }

                time = time.replace(/[^0-9\:]/g, '');

                timeArray = time.split(':');

                hour = timeArray[0] ? timeArray[0].toString() : timeArray.toString();
                minute = timeArray[1] ? timeArray[1].toString() : '';
                second = timeArray[2] ? timeArray[2].toString() : '';

                // idiot proofing
                if (hour.length > 4) {
                    second = hour.substr(4, 2);
                }
                if (hour.length > 2) {
                    minute = hour.substr(2, 2);
                    hour = hour.substr(0, 2);
                }
                if (minute.length > 2) {
                    second = minute.substr(2, 2);
                    minute = minute.substr(0, 2);
                }
                if (second.length > 2) {
                    second = second.substr(2, 2);
                }

                hour = parseInt(hour, 10);
                minute = parseInt(minute, 10);
                second = parseInt(second, 10);

                if (isNaN(hour)) {
                    hour = 0;
                }
                if (isNaN(minute)) {
                    minute = 0;
                }
                if (isNaN(second)) {
                    second = 0;
                }

                if (this.showMeridian) {
                    if (hour < 1) {
                        hour = 1;
                    } else if (hour > 12) {
                        hour = 12;
                    }
                } else {
                    if (hour >= 24) {
                        hour = 23;
                    } else if (hour < 0) {
                        hour = 0;
                    }
                    if (hour < 13 && meridian === 'PM') {
                        hour = hour + 12;
                    }
                }

                if (minute < 0) {
                    minute = 0;
                } else if (minute >= 60) {
                    minute = 59;
                }

                if (this.showSeconds) {
                    if (isNaN(second)) {
                        second = 0;
                    } else if (second < 0) {
                        second = 0;
                    } else if (second >= 60) {
                        second = 59;
                    }
                }
            }

            this.hour = hour;
            this.minute = minute;
            this.second = second;
            this.meridian = meridian;

            this.update(ignoreWidget);
        },

        showWidget: function () {
            if (this.isOpen) {
                return;
            }

            if (this.$element.is(':disabled')) {
                return;
            }

            // show/hide approach taken by datepicker
            this.$widget.appendTo(this.appendWidgetTo);
            var self = this;
            $(document).on('mousedown.timepicker, touchend.timepicker', function (e) {
                // This condition was inspired by bootstrap-datepicker.
                // The element the timepicker is invoked on is the input but it has a sibling for addon/button.
                if (!(self.$element.parent().find(e.target).length ||
                    self.$widget.is(e.target) ||
                    self.$widget.find(e.target).length)) {
                    self.hideWidget();
                }
            });

            this.$element.trigger({
                'type': 'show.timepicker',
                'time': {
                    'value': this.getTime(),
                    'hours': this.hour,
                    'minutes': this.minute,
                    'seconds': this.second,
                    'meridian': this.meridian
                }
            });

            this.place();
            if (this.disableFocus) {
                this.$element.blur();
            }

            // widget shouldn't be empty on open
            if (this.hour === '') {
                if (this.defaultTime) {
                    this.setDefaultTime(this.defaultTime);
                } else {
                    this.setTime('0:0:0');
                }
            }

            if (this.template === 'modal' && this.$widget.modal) {
                this.$widget.modal('show').on('hidden', $.proxy(this.hideWidget, this));
            } else {
                if (this.isOpen === false) {
                    this.$widget.addClass('open');
                }
            }

            this.isOpen = true;
        },

        toggleMeridian: function () {
            this.meridian = this.meridian === 'AM' ? 'PM' : 'AM';
        },

        update: function (ignoreWidget) {
            this.updateElement();
            if (!ignoreWidget) {
                this.updateWidget();
            }

            this.$element.trigger({
                'type': 'changeTime.timepicker',
                'time': {
                    'value': this.getTime(),
                    'hours': this.hour,
                    'minutes': this.minute,
                    'seconds': this.second,
                    'meridian': this.meridian
                }
            });
        },

        updateElement: function () {
            this.$element.val(this.getTime()).change();
        },

        updateFromElementVal: function () {
            this.setTime(this.$element.val());
        },

        updateWidget: function () {
            if (this.$widget === false) {
                return;
            }

            var hour = this.hour,
                minute = this.minute.toString().length === 1 ? '0' + this.minute : this.minute,
                second = this.second.toString().length === 1 ? '0' + this.second : this.second;

            if (this.showInputs) {
                this.$widget.find('input.bootstrap-timepicker-hour').val(hour);
                this.$widget.find('input.bootstrap-timepicker-minute').val(minute);

                if (this.showSeconds) {
                    this.$widget.find('input.bootstrap-timepicker-second').val(second);
                }
                if (this.showMeridian) {
                    this.$widget.find('input.bootstrap-timepicker-meridian').val(this.meridian);
                }
            } else {
                this.$widget.find('span.bootstrap-timepicker-hour').text(hour);
                this.$widget.find('span.bootstrap-timepicker-minute').text(minute);

                if (this.showSeconds) {
                    this.$widget.find('span.bootstrap-timepicker-second').text(second);
                }
                if (this.showMeridian) {
                    this.$widget.find('span.bootstrap-timepicker-meridian').text(this.meridian);
                }
            }
        },

        updateFromWidgetInputs: function () {
            if (this.$widget === false) {
                return;
            }

            var t = this.$widget.find('input.bootstrap-timepicker-hour').val() + ':' +
                    this.$widget.find('input.bootstrap-timepicker-minute').val() +
                    (this.showSeconds ? ':' + this.$widget.find('input.bootstrap-timepicker-second').val() : '') +
                    (this.showMeridian ? this.$widget.find('input.bootstrap-timepicker-meridian').val() : '')
            ;

            this.setTime(t, true);
        },

        widgetClick: function (e) {
            e.stopPropagation();
            e.preventDefault();

            var $input = $(e.target),
                action = $input.closest('a').data('action');

            if (action) {
                this[action]();
            }
            this.update();

            if ($input.is('input')) {
                $input.get(0).setSelectionRange(0, 2);
            }
        },

        widgetKeydown: function (e) {
            var $input = $(e.target),
                name = $input.attr('class').replace('bootstrap-timepicker-', '');

            switch (e.keyCode) {
                case 9: //tab
                    if ((this.showMeridian && name === 'meridian') || (this.showSeconds && name === 'second') || (!this.showMeridian && !this.showSeconds && name === 'minute')) {
                        return this.hideWidget();
                    }
                    break;
                case 27: // escape
                    this.hideWidget();
                    break;
                case 38: // up arrow
                    e.preventDefault();
                    switch (name) {
                        case 'hour':
                            this.incrementHour();
                            break;
                        case 'minute':
                            this.incrementMinute();
                            break;
                        case 'second':
                            this.incrementSecond();
                            break;
                        case 'meridian':
                            this.toggleMeridian();
                            break;
                    }
                    this.setTime(this.getTime());
                    $input.get(0).setSelectionRange(0, 2);
                    break;
                case 40: // down arrow
                    e.preventDefault();
                    switch (name) {
                        case 'hour':
                            this.decrementHour();
                            break;
                        case 'minute':
                            this.decrementMinute();
                            break;
                        case 'second':
                            this.decrementSecond();
                            break;
                        case 'meridian':
                            this.toggleMeridian();
                            break;
                    }
                    this.setTime(this.getTime());
                    $input.get(0).setSelectionRange(0, 2);
                    break;
            }
        },

        widgetKeyup: function (e) {
            if ((e.keyCode === 65) || (e.keyCode === 77) || (e.keyCode === 80) || (e.keyCode === 46) || (e.keyCode === 8) || (e.keyCode >= 46 && e.keyCode <= 57) || (e.keyCode >= 96 && e.keyCode <= 105)) {
                this.updateFromWidgetInputs();
            }
        }
    };

    //TIMEPICKER PLUGIN DEFINITION
    $.fn.timepicker = function (option) {
        var args = Array.apply(null, arguments);
        args.shift();
        return this.each(function () {
            var $this = $(this),
              data = $this.data('timepicker'),
              options = typeof option === 'object' && option;

            if (!data) {
                $this.data('timepicker', (data = new Timepicker(this, $.extend({}, $.fn.timepicker.defaults, options, $(this).data()))));
            }

            if (typeof option === 'string') {
                data[option].apply(data, args);
            }
        });
    };

    $.fn.timepicker.defaults = {
        defaultTime: 'current',
        disableFocus: false,
        disableMousewheel: false,
        isOpen: false,
        minuteStep: 15,
        modalBackdrop: false,
        orientation: { x: 'auto', y: 'auto' },
        secondStep: 15,
        showSeconds: false,
        showInputs: true,
        showMeridian: true,
        template: 'dropdown',
        appendWidgetTo: 'body',
        showWidgetOnAddonClick: true
    };

    $.fn.timepicker.Constructor = Timepicker;

})(jQuery, window, document);;
//! moment.js
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        return Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        var k;
        for (k in obj) {
            // even if its not own property I'd still call it non-empty
            return false;
        }
        return true;
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (utils_hooks__hooks.deprecationHandler != null) {
                utils_hooks__hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (utils_hooks__hooks.deprecationHandler != null) {
            utils_hooks__hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;
    utils_hooks__hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function get_set__set (mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function units_month__handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = create_utc__createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return units_month__handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (typeof value !== 'number') {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        //the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function day_of_week__handleStrictParse(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = create_utc__createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = create_utc__createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        ordinalParse: defaultOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    // treat as if there is no base config
                    deprecateSimple('parentLocaleUndefined',
                            'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, parentConfig = baseConfig;
            // MERGE
            if (locales[name] != null) {
                parentConfig = locales[name]._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function locale_locales__listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (isDate(input)) {
            config._d = input;
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!valid__isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(matchOffset, this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function moment_format__format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIOROITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add               = add_subtract__add;
    momentPrototype__proto.calendar          = moment_calendar__calendar;
    momentPrototype__proto.clone             = clone;
    momentPrototype__proto.diff              = diff;
    momentPrototype__proto.endOf             = endOf;
    momentPrototype__proto.format            = moment_format__format;
    momentPrototype__proto.from              = from;
    momentPrototype__proto.fromNow           = fromNow;
    momentPrototype__proto.to                = to;
    momentPrototype__proto.toNow             = toNow;
    momentPrototype__proto.get               = stringGet;
    momentPrototype__proto.invalidAt         = invalidAt;
    momentPrototype__proto.isAfter           = isAfter;
    momentPrototype__proto.isBefore          = isBefore;
    momentPrototype__proto.isBetween         = isBetween;
    momentPrototype__proto.isSame            = isSame;
    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
    momentPrototype__proto.isValid           = moment_valid__isValid;
    momentPrototype__proto.lang              = lang;
    momentPrototype__proto.locale            = locale;
    momentPrototype__proto.localeData        = localeData;
    momentPrototype__proto.max               = prototypeMax;
    momentPrototype__proto.min               = prototypeMin;
    momentPrototype__proto.parsingFlags      = parsingFlags;
    momentPrototype__proto.set               = stringSet;
    momentPrototype__proto.startOf           = startOf;
    momentPrototype__proto.subtract          = add_subtract__subtract;
    momentPrototype__proto.toArray           = toArray;
    momentPrototype__proto.toObject          = toObject;
    momentPrototype__proto.toDate            = toDate;
    momentPrototype__proto.toISOString       = moment_format__toISOString;
    momentPrototype__proto.toJSON            = toJSON;
    momentPrototype__proto.toString          = toString;
    momentPrototype__proto.unix              = unix;
    momentPrototype__proto.valueOf           = to_type__valueOf;
    momentPrototype__proto.creationData      = creationData;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    var momentPrototype = momentPrototype__proto;

    function moment_moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment_moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var prototype__proto = Locale.prototype;

    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto.ordinal         = ordinal;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months            =        localeMonths;
    prototype__proto.monthsShort       =        localeMonthsShort;
    prototype__proto.monthsParse       =        localeMonthsParse;
    prototype__proto.monthsRegex       = monthsRegex;
    prototype__proto.monthsShortRegex  = monthsShortRegex;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    prototype__proto.weekdaysRegex       =        weekdaysRegex;
    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = lists__get(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = locale_locales__getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return lists__get(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = lists__get(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function lists__listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function lists__listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function lists__listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function lists__listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var duration_get__months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes <= 1           && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   <= 1           && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    <= 1           && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  <= 1           && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   <= 1           && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function duration_humanize__getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = duration_get__months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports

    ;


    utils_hooks__hooks.version = '2.14.1';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.now                   = now;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment_moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment_moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.updateLocale          = updateLocale;
    utils_hooks__hooks.locales               = locale_locales__listLocales;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.calendarFormat        = getCalendarFormat;
    utils_hooks__hooks.prototype             = momentPrototype;

    var moment__default = utils_hooks__hooks;


    var af = moment__default.defineLocale('af', {
        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
        meridiemParse: /vm|nm/i,
        isPM : function (input) {
            return /^nm$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'vm' : 'VM';
            } else {
                return isLower ? 'nm' : 'NM';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Vandag om] LT',
            nextDay : '[Môre om] LT',
            nextWeek : 'dddd [om] LT',
            lastDay : '[Gister om] LT',
            lastWeek : '[Laas] dddd [om] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'oor %s',
            past : '%s gelede',
            s : '\'n paar sekondes',
            m : '\'n minuut',
            mm : '%d minute',
            h : '\'n uur',
            hh : '%d ure',
            d : '\'n dag',
            dd : '%d dae',
            M : '\'n maand',
            MM : '%d maande',
            y : '\'n jaar',
            yy : '%d jaar'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Röling : https://github.com/jjupiter
        },
        week : {
            dow : 1, // Maandag is die eerste dag van die week.
            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
        }
    });


    var ar_ma = moment__default.defineLocale('ar-ma', {
        months : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        monthsShort : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        weekdays : 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort : 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'في %s',
            past : 'منذ %s',
            s : 'ثوان',
            m : 'دقيقة',
            mm : '%d دقائق',
            h : 'ساعة',
            hh : '%d ساعات',
            d : 'يوم',
            dd : '%d أيام',
            M : 'شهر',
            MM : '%d أشهر',
            y : 'سنة',
            yy : '%d سنوات'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var ar_sa__symbolMap = {
        '1': '١',
        '2': '٢',
        '3': '٣',
        '4': '٤',
        '5': '٥',
        '6': '٦',
        '7': '٧',
        '8': '٨',
        '9': '٩',
        '0': '٠'
    }, ar_sa__numberMap = {
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',
        '٠': '0'
    };

    var ar_sa = moment__default.defineLocale('ar-sa', {
        months : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        monthsShort : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /ص|م/,
        isPM : function (input) {
            return 'م' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar : {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'في %s',
            past : 'منذ %s',
            s : 'ثوان',
            m : 'دقيقة',
            mm : '%d دقائق',
            h : 'ساعة',
            hh : '%d ساعات',
            d : 'يوم',
            dd : '%d أيام',
            M : 'شهر',
            MM : '%d أشهر',
            y : 'سنة',
            yy : '%d سنوات'
        },
        preparse: function (string) {
            return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                return ar_sa__numberMap[match];
            }).replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return ar_sa__symbolMap[match];
            }).replace(/,/g, '،');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var ar_tn = moment__default.defineLocale('ar-tn', {
        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'في %s',
            past: 'منذ %s',
            s: 'ثوان',
            m: 'دقيقة',
            mm: '%d دقائق',
            h: 'ساعة',
            hh: '%d ساعات',
            d: 'يوم',
            dd: '%d أيام',
            M: 'شهر',
            MM: '%d أشهر',
            y: 'سنة',
            yy: '%d سنوات'
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });


    var ar__symbolMap = {
        '1': '١',
        '2': '٢',
        '3': '٣',
        '4': '٤',
        '5': '٥',
        '6': '٦',
        '7': '٧',
        '8': '٨',
        '9': '٩',
        '0': '٠'
    }, ar__numberMap = {
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',
        '٠': '0'
    }, pluralForm = function (n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
        m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
        h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
        d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
        M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
        y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
    }, pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, ar__months = [
        'كانون الثاني يناير',
        'شباط فبراير',
        'آذار مارس',
        'نيسان أبريل',
        'أيار مايو',
        'حزيران يونيو',
        'تموز يوليو',
        'آب أغسطس',
        'أيلول سبتمبر',
        'تشرين الأول أكتوبر',
        'تشرين الثاني نوفمبر',
        'كانون الأول ديسمبر'
    ];

    var ar = moment__default.defineLocale('ar', {
        months : ar__months,
        monthsShort : ar__months,
        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/\u200FM/\u200FYYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /ص|م/,
        isPM : function (input) {
            return 'م' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar : {
            sameDay: '[اليوم عند الساعة] LT',
            nextDay: '[غدًا عند الساعة] LT',
            nextWeek: 'dddd [عند الساعة] LT',
            lastDay: '[أمس عند الساعة] LT',
            lastWeek: 'dddd [عند الساعة] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'بعد %s',
            past : 'منذ %s',
            s : pluralize('s'),
            m : pluralize('m'),
            mm : pluralize('m'),
            h : pluralize('h'),
            hh : pluralize('h'),
            d : pluralize('d'),
            dd : pluralize('d'),
            M : pluralize('M'),
            MM : pluralize('M'),
            y : pluralize('y'),
            yy : pluralize('y')
        },
        preparse: function (string) {
            return string.replace(/\u200f/g, '').replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                return ar__numberMap[match];
            }).replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return ar__symbolMap[match];
            }).replace(/,/g, '،');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var az__suffixes = {
        1: '-inci',
        5: '-inci',
        8: '-inci',
        70: '-inci',
        80: '-inci',
        2: '-nci',
        7: '-nci',
        20: '-nci',
        50: '-nci',
        3: '-üncü',
        4: '-üncü',
        100: '-üncü',
        6: '-ncı',
        9: '-uncu',
        10: '-uncu',
        30: '-uncu',
        60: '-ıncı',
        90: '-ıncı'
    };

    var az = moment__default.defineLocale('az', {
        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
        weekdays : 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split('_'),
        weekdaysShort : 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
        weekdaysMin : 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugün saat] LT',
            nextDay : '[sabah saat] LT',
            nextWeek : '[gələn həftə] dddd [saat] LT',
            lastDay : '[dünən] LT',
            lastWeek : '[keçən həftə] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s əvvəl',
            s : 'birneçə saniyyə',
            m : 'bir dəqiqə',
            mm : '%d dəqiqə',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gün',
            dd : '%d gün',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir il',
            yy : '%d il'
        },
        meridiemParse: /gecə|səhər|gündüz|axşam/,
        isPM : function (input) {
            return /^(gündüz|axşam)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'gecə';
            } else if (hour < 12) {
                return 'səhər';
            } else if (hour < 17) {
                return 'gündüz';
            } else {
                return 'axşam';
            }
        },
        ordinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '-ıncı';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (az__suffixes[a] || az__suffixes[b] || az__suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    function be__plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function be__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
            'hh': withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
            'dd': 'дзень_дні_дзён',
            'MM': 'месяц_месяцы_месяцаў',
            'yy': 'год_гады_гадоў'
        };
        if (key === 'm') {
            return withoutSuffix ? 'хвіліна' : 'хвіліну';
        }
        else if (key === 'h') {
            return withoutSuffix ? 'гадзіна' : 'гадзіну';
        }
        else {
            return number + ' ' + be__plural(format[key], +number);
        }
    }

    var be = moment__default.defineLocale('be', {
        months : {
            format: 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split('_'),
            standalone: 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split('_')
        },
        monthsShort : 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split('_'),
        weekdays : {
            format: 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split('_'),
            standalone: 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split('_'),
            isFormat: /\[ ?[Вв] ?(?:мінулую|наступную)? ?\] ?dddd/
        },
        weekdaysShort : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
        weekdaysMin : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY г.',
            LLL : 'D MMMM YYYY г., HH:mm',
            LLLL : 'dddd, D MMMM YYYY г., HH:mm'
        },
        calendar : {
            sameDay: '[Сёння ў] LT',
            nextDay: '[Заўтра ў] LT',
            lastDay: '[Учора ў] LT',
            nextWeek: function () {
                return '[У] dddd [ў] LT';
            },
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 5:
                    case 6:
                        return '[У мінулую] dddd [ў] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[У мінулы] dddd [ў] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'праз %s',
            past : '%s таму',
            s : 'некалькі секунд',
            m : be__relativeTimeWithPlural,
            mm : be__relativeTimeWithPlural,
            h : be__relativeTimeWithPlural,
            hh : be__relativeTimeWithPlural,
            d : 'дзень',
            dd : be__relativeTimeWithPlural,
            M : 'месяц',
            MM : be__relativeTimeWithPlural,
            y : 'год',
            yy : be__relativeTimeWithPlural
        },
        meridiemParse: /ночы|раніцы|дня|вечара/,
        isPM : function (input) {
            return /^(дня|вечара)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночы';
            } else if (hour < 12) {
                return 'раніцы';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечара';
            }
        },
        ordinalParse: /\d{1,2}-(і|ы|га)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                case 'w':
                case 'W':
                    return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-і' : number + '-ы';
                case 'D':
                    return number + '-га';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var bg = moment__default.defineLocale('bg', {
        months : 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
        monthsShort : 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
        weekdays : 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
        weekdaysShort : 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : '[Днес в] LT',
            nextDay : '[Утре в] LT',
            nextWeek : 'dddd [в] LT',
            lastDay : '[Вчера в] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 6:
                        return '[В изминалата] dddd [в] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[В изминалия] dddd [в] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'след %s',
            past : 'преди %s',
            s : 'няколко секунди',
            m : 'минута',
            mm : '%d минути',
            h : 'час',
            hh : '%d часа',
            d : 'ден',
            dd : '%d дни',
            M : 'месец',
            MM : '%d месеца',
            y : 'година',
            yy : '%d години'
        },
        ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-ев';
            } else if (last2Digits === 0) {
                return number + '-ен';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-ти';
            } else if (lastDigit === 1) {
                return number + '-ви';
            } else if (lastDigit === 2) {
                return number + '-ри';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-ми';
            } else {
                return number + '-ти';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var bn__symbolMap = {
        '1': '১',
        '2': '২',
        '3': '৩',
        '4': '৪',
        '5': '৫',
        '6': '৬',
        '7': '৭',
        '8': '৮',
        '9': '৯',
        '0': '০'
    },
    bn__numberMap = {
        '১': '1',
        '২': '2',
        '৩': '3',
        '৪': '4',
        '৫': '5',
        '৬': '6',
        '৭': '7',
        '৮': '8',
        '৯': '9',
        '০': '0'
    };

    var bn = moment__default.defineLocale('bn', {
        months : 'জানুয়ারী_ফেবুয়ারী_মার্চ_এপ্রিল_মে_জুন_জুলাই_অগাস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split('_'),
        monthsShort : 'জানু_ফেব_মার্চ_এপর_মে_জুন_জুল_অগ_সেপ্ট_অক্টো_নভ_ডিসেম্'.split('_'),
        weekdays : 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পত্তিবার_শুক্রবার_শনিবার'.split('_'),
        weekdaysShort : 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পত্তি_শুক্র_শনি'.split('_'),
        weekdaysMin : 'রব_সম_মঙ্গ_বু_ব্রিহ_শু_শনি'.split('_'),
        longDateFormat : {
            LT : 'A h:mm সময়',
            LTS : 'A h:mm:ss সময়',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm সময়',
            LLLL : 'dddd, D MMMM YYYY, A h:mm সময়'
        },
        calendar : {
            sameDay : '[আজ] LT',
            nextDay : '[আগামীকাল] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[গতকাল] LT',
            lastWeek : '[গত] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s পরে',
            past : '%s আগে',
            s : 'কয়েক সেকেন্ড',
            m : 'এক মিনিট',
            mm : '%d মিনিট',
            h : 'এক ঘন্টা',
            hh : '%d ঘন্টা',
            d : 'এক দিন',
            dd : '%d দিন',
            M : 'এক মাস',
            MM : '%d মাস',
            y : 'এক বছর',
            yy : '%d বছর'
        },
        preparse: function (string) {
            return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
                return bn__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return bn__symbolMap[match];
            });
        },
        meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === 'রাত' && hour >= 4) ||
                    (meridiem === 'দুপুর' && hour < 5) ||
                    meridiem === 'বিকাল') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'রাত';
            } else if (hour < 10) {
                return 'সকাল';
            } else if (hour < 17) {
                return 'দুপুর';
            } else if (hour < 20) {
                return 'বিকাল';
            } else {
                return 'রাত';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var bo__symbolMap = {
        '1': '༡',
        '2': '༢',
        '3': '༣',
        '4': '༤',
        '5': '༥',
        '6': '༦',
        '7': '༧',
        '8': '༨',
        '9': '༩',
        '0': '༠'
    },
    bo__numberMap = {
        '༡': '1',
        '༢': '2',
        '༣': '3',
        '༤': '4',
        '༥': '5',
        '༦': '6',
        '༧': '7',
        '༨': '8',
        '༩': '9',
        '༠': '0'
    };

    var bo = moment__default.defineLocale('bo', {
        months : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
        monthsShort : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
        weekdays : 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split('_'),
        weekdaysShort : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
        weekdaysMin : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[དི་རིང] LT',
            nextDay : '[སང་ཉིན] LT',
            nextWeek : '[བདུན་ཕྲག་རྗེས་མ], LT',
            lastDay : '[ཁ་སང] LT',
            lastWeek : '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ལ་',
            past : '%s སྔན་ལ',
            s : 'ལམ་སང',
            m : 'སྐར་མ་གཅིག',
            mm : '%d སྐར་མ',
            h : 'ཆུ་ཚོད་གཅིག',
            hh : '%d ཆུ་ཚོད',
            d : 'ཉིན་གཅིག',
            dd : '%d ཉིན་',
            M : 'ཟླ་བ་གཅིག',
            MM : '%d ཟླ་བ',
            y : 'ལོ་གཅིག',
            yy : '%d ལོ'
        },
        preparse: function (string) {
            return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
                return bo__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return bo__symbolMap[match];
            });
        },
        meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === 'མཚན་མོ' && hour >= 4) ||
                    (meridiem === 'ཉིན་གུང' && hour < 5) ||
                    meridiem === 'དགོང་དག') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'མཚན་མོ';
            } else if (hour < 10) {
                return 'ཞོགས་ཀས';
            } else if (hour < 17) {
                return 'ཉིན་གུང';
            } else if (hour < 20) {
                return 'དགོང་དག';
            } else {
                return 'མཚན་མོ';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });


    function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
            'mm': 'munutenn',
            'MM': 'miz',
            'dd': 'devezh'
        };
        return number + ' ' + mutation(format[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
            case 1:
            case 3:
            case 4:
            case 5:
            case 9:
                return number + ' bloaz';
            default:
                return number + ' vloaz';
        }
    }
    function lastNumber(number) {
        if (number > 9) {
            return lastNumber(number % 10);
        }
        return number;
    }
    function mutation(text, number) {
        if (number === 2) {
            return softMutation(text);
        }
        return text;
    }
    function softMutation(text) {
        var mutationTable = {
            'm': 'v',
            'b': 'v',
            'd': 'z'
        };
        if (mutationTable[text.charAt(0)] === undefined) {
            return text;
        }
        return mutationTable[text.charAt(0)] + text.substring(1);
    }

    var br = moment__default.defineLocale('br', {
        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h[e]mm A',
            LTS : 'h[e]mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D [a viz] MMMM YYYY',
            LLL : 'D [a viz] MMMM YYYY h[e]mm A',
            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
        },
        calendar : {
            sameDay : '[Hiziv da] LT',
            nextDay : '[Warc\'hoazh da] LT',
            nextWeek : 'dddd [da] LT',
            lastDay : '[Dec\'h da] LT',
            lastWeek : 'dddd [paset da] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'a-benn %s',
            past : '%s \'zo',
            s : 'un nebeud segondennoù',
            m : 'ur vunutenn',
            mm : relativeTimeWithMutation,
            h : 'un eur',
            hh : '%d eur',
            d : 'un devezh',
            dd : relativeTimeWithMutation,
            M : 'ur miz',
            MM : relativeTimeWithMutation,
            y : 'ur bloaz',
            yy : specialMutationForYears
        },
        ordinalParse: /\d{1,2}(añ|vet)/,
        ordinal : function (number) {
            var output = (number === 1) ? 'añ' : 'vet';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    function bs__translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'm':
                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
            case 'mm':
                if (number === 1) {
                    result += 'minuta';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'minute';
                } else {
                    result += 'minuta';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'jedan sat' : 'jednog sata';
            case 'hh':
                if (number === 1) {
                    result += 'sat';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sata';
                } else {
                    result += 'sati';
                }
                return result;
            case 'dd':
                if (number === 1) {
                    result += 'dan';
                } else {
                    result += 'dana';
                }
                return result;
            case 'MM':
                if (number === 1) {
                    result += 'mjesec';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'mjeseca';
                } else {
                    result += 'mjeseci';
                }
                return result;
            case 'yy':
                if (number === 1) {
                    result += 'godina';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'godine';
                } else {
                    result += 'godina';
                }
                return result;
        }
    }

    var bs = moment__default.defineLocale('bs', {
        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jučer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                        return '[prošlu] dddd [u] LT';
                    case 6:
                        return '[prošle] [subote] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prošli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            m      : bs__translate,
            mm     : bs__translate,
            h      : bs__translate,
            hh     : bs__translate,
            d      : 'dan',
            dd     : bs__translate,
            M      : 'mjesec',
            MM     : bs__translate,
            y      : 'godinu',
            yy     : bs__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var ca = moment__default.defineLocale('ca', {
        months : 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
        monthsParseExact : true,
        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextDay : function () {
                return '[demà a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastDay : function () {
                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'fa %s',
            s : 'uns segons',
            m : 'un minut',
            mm : '%d minuts',
            h : 'una hora',
            hh : '%d hores',
            d : 'un dia',
            dd : '%d dies',
            M : 'un mes',
            MM : '%d mesos',
            y : 'un any',
            yy : '%d anys'
        },
        ordinalParse: /\d{1,2}(r|n|t|è|a)/,
        ordinal : function (number, period) {
            var output = (number === 1) ? 'r' :
                (number === 2) ? 'n' :
                (number === 3) ? 'r' :
                (number === 4) ? 't' : 'è';
            if (period === 'w' || period === 'W') {
                output = 'a';
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var cs__months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_'),
        cs__monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_');
    function cs__plural(n) {
        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
    }
    function cs__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':  // a few seconds / in a few seconds / a few seconds ago
                return (withoutSuffix || isFuture) ? 'pár sekund' : 'pár sekundami';
            case 'm':  // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (cs__plural(number) ? 'minuty' : 'minut');
                } else {
                    return result + 'minutami';
                }
                break;
            case 'h':  // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
            case 'hh': // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (cs__plural(number) ? 'hodiny' : 'hodin');
                } else {
                    return result + 'hodinami';
                }
                break;
            case 'd':  // a day / in a day / a day ago
                return (withoutSuffix || isFuture) ? 'den' : 'dnem';
            case 'dd': // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (cs__plural(number) ? 'dny' : 'dní');
                } else {
                    return result + 'dny';
                }
                break;
            case 'M':  // a month / in a month / a month ago
                return (withoutSuffix || isFuture) ? 'měsíc' : 'měsícem';
            case 'MM': // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (cs__plural(number) ? 'měsíce' : 'měsíců');
                } else {
                    return result + 'měsíci';
                }
                break;
            case 'y':  // a year / in a year / a year ago
                return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
            case 'yy': // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (cs__plural(number) ? 'roky' : 'let');
                } else {
                    return result + 'lety';
                }
                break;
        }
    }

    var cs = moment__default.defineLocale('cs', {
        months : cs__months,
        monthsShort : cs__monthsShort,
        monthsParse : (function (months, monthsShort) {
            var i, _monthsParse = [];
            for (i = 0; i < 12; i++) {
                // use custom parser to solve problem with July (červenec)
                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
            }
            return _monthsParse;
        }(cs__months, cs__monthsShort)),
        shortMonthsParse : (function (monthsShort) {
            var i, _shortMonthsParse = [];
            for (i = 0; i < 12; i++) {
                _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
            }
            return _shortMonthsParse;
        }(cs__monthsShort)),
        longMonthsParse : (function (months) {
            var i, _longMonthsParse = [];
            for (i = 0; i < 12; i++) {
                _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
            }
            return _longMonthsParse;
        }(cs__months)),
        weekdays : 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
        weekdaysShort : 'ne_po_út_st_čt_pá_so'.split('_'),
        weekdaysMin : 'ne_po_út_st_čt_pá_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm',
            l : 'D. M. YYYY'
        },
        calendar : {
            sameDay: '[dnes v] LT',
            nextDay: '[zítra v] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v neděli v] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [v] LT';
                    case 3:
                        return '[ve středu v] LT';
                    case 4:
                        return '[ve čtvrtek v] LT';
                    case 5:
                        return '[v pátek v] LT';
                    case 6:
                        return '[v sobotu v] LT';
                }
            },
            lastDay: '[včera v] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[minulou neděli v] LT';
                    case 1:
                    case 2:
                        return '[minulé] dddd [v] LT';
                    case 3:
                        return '[minulou středu v] LT';
                    case 4:
                    case 5:
                        return '[minulý] dddd [v] LT';
                    case 6:
                        return '[minulou sobotu v] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'před %s',
            s : cs__translate,
            m : cs__translate,
            mm : cs__translate,
            h : cs__translate,
            hh : cs__translate,
            d : cs__translate,
            dd : cs__translate,
            M : cs__translate,
            MM : cs__translate,
            y : cs__translate,
            yy : cs__translate
        },
        ordinalParse : /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var cv = moment__default.defineLocale('cv', {
        months : 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split('_'),
        monthsShort : 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
        weekdays : 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split('_'),
        weekdaysShort : 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
        weekdaysMin : 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
            LLL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
            LLLL : 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm'
        },
        calendar : {
            sameDay: '[Паян] LT [сехетре]',
            nextDay: '[Ыран] LT [сехетре]',
            lastDay: '[Ӗнер] LT [сехетре]',
            nextWeek: '[Ҫитес] dddd LT [сехетре]',
            lastWeek: '[Иртнӗ] dddd LT [сехетре]',
            sameElse: 'L'
        },
        relativeTime : {
            future : function (output) {
                var affix = /сехет$/i.exec(output) ? 'рен' : /ҫул$/i.exec(output) ? 'тан' : 'ран';
                return output + affix;
            },
            past : '%s каялла',
            s : 'пӗр-ик ҫеккунт',
            m : 'пӗр минут',
            mm : '%d минут',
            h : 'пӗр сехет',
            hh : '%d сехет',
            d : 'пӗр кун',
            dd : '%d кун',
            M : 'пӗр уйӑх',
            MM : '%d уйӑх',
            y : 'пӗр ҫул',
            yy : '%d ҫул'
        },
        ordinalParse: /\d{1,2}-мӗш/,
        ordinal : '%d-мӗш',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var cy = moment__default.defineLocale('cy', {
        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
        weekdaysParseExact : true,
        // time formats are the same as en-gb
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Heddiw am] LT',
            nextDay: '[Yfory am] LT',
            nextWeek: 'dddd [am] LT',
            lastDay: '[Ddoe am] LT',
            lastWeek: 'dddd [diwethaf am] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'mewn %s',
            past: '%s yn ôl',
            s: 'ychydig eiliadau',
            m: 'munud',
            mm: '%d munud',
            h: 'awr',
            hh: '%d awr',
            d: 'diwrnod',
            dd: '%d diwrnod',
            M: 'mis',
            MM: '%d mis',
            y: 'blwyddyn',
            yy: '%d flynedd'
        },
        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
        ordinal: function (number) {
            var b = number,
                output = '',
                lookup = [
                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
                ];
            if (b > 20) {
                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                    output = 'fed'; // not 30ain, 70ain or 90ain
                } else {
                    output = 'ain';
                }
            } else if (b > 0) {
                output = lookup[b];
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var da = moment__default.defineLocale('da', {
        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
        weekdaysShort : 'søn_man_tir_ons_tor_fre_lør'.split('_'),
        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[I dag kl.] LT',
            nextDay : '[I morgen kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[I går kl.] LT',
            lastWeek : '[sidste] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'få sekunder',
            m : 'et minut',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dage',
            M : 'en måned',
            MM : '%d måneder',
            y : 'et år',
            yy : '%d år'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    function de_at__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de_at = moment__default.defineLocale('de-at', {
        months : 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jän._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            m : de_at__processRelativeTime,
            mm : '%d Minuten',
            h : de_at__processRelativeTime,
            hh : '%d Stunden',
            d : de_at__processRelativeTime,
            dd : de_at__processRelativeTime,
            M : de_at__processRelativeTime,
            MM : de_at__processRelativeTime,
            y : de_at__processRelativeTime,
            yy : de_at__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    function de__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de = moment__default.defineLocale('de', {
        months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            m : de__processRelativeTime,
            mm : '%d Minuten',
            h : de__processRelativeTime,
            hh : '%d Stunden',
            d : de__processRelativeTime,
            dd : de__processRelativeTime,
            M : de__processRelativeTime,
            MM : de__processRelativeTime,
            y : de__processRelativeTime,
            yy : de__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var dv__months = [
        'ޖެނުއަރީ',
        'ފެބްރުއަރީ',
        'މާރިޗު',
        'އޭޕްރީލު',
        'މޭ',
        'ޖޫން',
        'ޖުލައި',
        'އޯގަސްޓު',
        'ސެޕްޓެމްބަރު',
        'އޮކްޓޯބަރު',
        'ނޮވެމްބަރު',
        'ޑިސެމްބަރު'
    ], dv__weekdays = [
        'އާދިއްތަ',
        'ހޯމަ',
        'އަންގާރަ',
        'ބުދަ',
        'ބުރާސްފަތި',
        'ހުކުރު',
        'ހޮނިހިރު'
    ];

    var dv = moment__default.defineLocale('dv', {
        months : dv__months,
        monthsShort : dv__months,
        weekdays : dv__weekdays,
        weekdaysShort : dv__weekdays,
        weekdaysMin : 'އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި'.split('_'),
        longDateFormat : {

            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/M/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /މކ|މފ/,
        isPM : function (input) {
            return 'މފ' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'މކ';
            } else {
                return 'މފ';
            }
        },
        calendar : {
            sameDay : '[މިއަދު] LT',
            nextDay : '[މާދަމާ] LT',
            nextWeek : 'dddd LT',
            lastDay : '[އިއްޔެ] LT',
            lastWeek : '[ފާއިތުވި] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ތެރޭގައި %s',
            past : 'ކުރިން %s',
            s : 'ސިކުންތުކޮޅެއް',
            m : 'މިނިޓެއް',
            mm : 'މިނިޓު %d',
            h : 'ގަޑިއިރެއް',
            hh : 'ގަޑިއިރު %d',
            d : 'ދުވަހެއް',
            dd : 'ދުވަސް %d',
            M : 'މަހެއް',
            MM : 'މަސް %d',
            y : 'އަހަރެއް',
            yy : 'އަހަރު %d'
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '،');
        },
        week : {
            dow : 7,  // Sunday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var el = moment__default.defineLocale('el', {
        monthsNominativeEl : 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
        monthsGenitiveEl : 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split('_'),
        months : function (momentToFormat, format) {
            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort : 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
        weekdays : 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
        weekdaysShort : 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
        weekdaysMin : 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'μμ' : 'ΜΜ';
            } else {
                return isLower ? 'πμ' : 'ΠΜ';
            }
        },
        isPM : function (input) {
            return ((input + '').toLowerCase()[0] === 'μ');
        },
        meridiemParse : /[ΠΜ]\.?Μ?\.?/i,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendarEl : {
            sameDay : '[Σήμερα {}] LT',
            nextDay : '[Αύριο {}] LT',
            nextWeek : 'dddd [{}] LT',
            lastDay : '[Χθες {}] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 6:
                        return '[το προηγούμενο] dddd [{}] LT';
                    default:
                        return '[την προηγούμενη] dddd [{}] LT';
                }
            },
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendarEl[key],
                hours = mom && mom.hours();
            if (isFunction(output)) {
                output = output.apply(mom);
            }
            return output.replace('{}', (hours % 12 === 1 ? 'στη' : 'στις'));
        },
        relativeTime : {
            future : 'σε %s',
            past : '%s πριν',
            s : 'λίγα δευτερόλεπτα',
            m : 'ένα λεπτό',
            mm : '%d λεπτά',
            h : 'μία ώρα',
            hh : '%d ώρες',
            d : 'μία μέρα',
            dd : '%d μέρες',
            M : 'ένας μήνας',
            MM : '%d μήνες',
            y : 'ένας χρόνος',
            yy : '%d χρόνια'
        },
        ordinalParse: /\d{1,2}η/,
        ordinal: '%dη',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4st is the first week of the year.
        }
    });


    var en_au = moment__default.defineLocale('en-au', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var en_ca = moment__default.defineLocale('en-ca', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'YYYY-MM-DD',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY h:mm A',
            LLLL : 'dddd, MMMM D, YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });


    var en_gb = moment__default.defineLocale('en-gb', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var en_ie = moment__default.defineLocale('en-ie', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var en_nz = moment__default.defineLocale('en-nz', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var eo = moment__default.defineLocale('eo', {
        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec'.split('_'),
        weekdays : 'Dimanĉo_Lundo_Mardo_Merkredo_Ĵaŭdo_Vendredo_Sabato'.split('_'),
        weekdaysShort : 'Dim_Lun_Mard_Merk_Ĵaŭ_Ven_Sab'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Ĵa_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D[-an de] MMMM, YYYY',
            LLL : 'D[-an de] MMMM, YYYY HH:mm',
            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function (input) {
            return input.charAt(0).toLowerCase() === 'p';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'p.t.m.' : 'P.T.M.';
            } else {
                return isLower ? 'a.t.m.' : 'A.T.M.';
            }
        },
        calendar : {
            sameDay : '[Hodiaŭ je] LT',
            nextDay : '[Morgaŭ je] LT',
            nextWeek : 'dddd [je] LT',
            lastDay : '[Hieraŭ je] LT',
            lastWeek : '[pasinta] dddd [je] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'je %s',
            past : 'antaŭ %s',
            s : 'sekundoj',
            m : 'minuto',
            mm : '%d minutoj',
            h : 'horo',
            hh : '%d horoj',
            d : 'tago',//ne 'diurno', ĉar estas uzita por proksimumo
            dd : '%d tagoj',
            M : 'monato',
            MM : '%d monatoj',
            y : 'jaro',
            yy : '%d jaroj'
        },
        ordinalParse: /\d{1,2}a/,
        ordinal : '%da',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var es_do__monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        es_do__monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var es_do = moment__default.defineLocale('es-do', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return es_do__monthsShort[m.month()];
            } else {
                return es_do__monthsShortDot[m.month()];
            }
        },
        monthsParseExact : true,
        weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY h:mm A',
            LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un día',
            dd : '%d días',
            M : 'un mes',
            MM : '%d meses',
            y : 'un año',
            yy : '%d años'
        },
        ordinalParse : /\d{1,2}º/,
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var es__monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        es__monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var es = moment__default.defineLocale('es', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return es__monthsShort[m.month()];
            } else {
                return es__monthsShortDot[m.month()];
            }
        },
        monthsParseExact : true,
        weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY H:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un día',
            dd : '%d días',
            M : 'un mes',
            MM : '%d meses',
            y : 'un año',
            yy : '%d años'
        },
        ordinalParse : /\d{1,2}º/,
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    function et__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's' : ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
            'm' : ['ühe minuti', 'üks minut'],
            'mm': [number + ' minuti', number + ' minutit'],
            'h' : ['ühe tunni', 'tund aega', 'üks tund'],
            'hh': [number + ' tunni', number + ' tundi'],
            'd' : ['ühe päeva', 'üks päev'],
            'M' : ['kuu aja', 'kuu aega', 'üks kuu'],
            'MM': [number + ' kuu', number + ' kuud'],
            'y' : ['ühe aasta', 'aasta', 'üks aasta'],
            'yy': [number + ' aasta', number + ' aastat']
        };
        if (withoutSuffix) {
            return format[key][2] ? format[key][2] : format[key][1];
        }
        return isFuture ? format[key][0] : format[key][1];
    }

    var et = moment__default.defineLocale('et', {
        months        : 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
        monthsShort   : 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
        weekdays      : 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
        longDateFormat : {
            LT   : 'H:mm',
            LTS : 'H:mm:ss',
            L    : 'DD.MM.YYYY',
            LL   : 'D. MMMM YYYY',
            LLL  : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[Täna,] LT',
            nextDay  : '[Homme,] LT',
            nextWeek : '[Järgmine] dddd LT',
            lastDay  : '[Eile,] LT',
            lastWeek : '[Eelmine] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s pärast',
            past   : '%s tagasi',
            s      : et__processRelativeTime,
            m      : et__processRelativeTime,
            mm     : et__processRelativeTime,
            h      : et__processRelativeTime,
            hh     : et__processRelativeTime,
            d      : et__processRelativeTime,
            dd     : '%d päeva',
            M      : et__processRelativeTime,
            MM     : et__processRelativeTime,
            y      : et__processRelativeTime,
            yy     : et__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var eu = moment__default.defineLocale('eu', {
        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
        monthsParseExact : true,
        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY[ko] MMMM[ren] D[a]',
            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
            l : 'YYYY-M-D',
            ll : 'YYYY[ko] MMM D[a]',
            lll : 'YYYY[ko] MMM D[a] HH:mm',
            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
        },
        calendar : {
            sameDay : '[gaur] LT[etan]',
            nextDay : '[bihar] LT[etan]',
            nextWeek : 'dddd LT[etan]',
            lastDay : '[atzo] LT[etan]',
            lastWeek : '[aurreko] dddd LT[etan]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s barru',
            past : 'duela %s',
            s : 'segundo batzuk',
            m : 'minutu bat',
            mm : '%d minutu',
            h : 'ordu bat',
            hh : '%d ordu',
            d : 'egun bat',
            dd : '%d egun',
            M : 'hilabete bat',
            MM : '%d hilabete',
            y : 'urte bat',
            yy : '%d urte'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var fa__symbolMap = {
        '1': '۱',
        '2': '۲',
        '3': '۳',
        '4': '۴',
        '5': '۵',
        '6': '۶',
        '7': '۷',
        '8': '۸',
        '9': '۹',
        '0': '۰'
    }, fa__numberMap = {
        '۱': '1',
        '۲': '2',
        '۳': '3',
        '۴': '4',
        '۵': '5',
        '۶': '6',
        '۷': '7',
        '۸': '8',
        '۹': '9',
        '۰': '0'
    };

    var fa = moment__default.defineLocale('fa', {
        months : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
        monthsShort : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
        weekdays : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
        weekdaysShort : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
        weekdaysMin : 'ی_د_س_چ_پ_ج_ش'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /قبل از ظهر|بعد از ظهر/,
        isPM: function (input) {
            return /بعد از ظهر/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'قبل از ظهر';
            } else {
                return 'بعد از ظهر';
            }
        },
        calendar : {
            sameDay : '[امروز ساعت] LT',
            nextDay : '[فردا ساعت] LT',
            nextWeek : 'dddd [ساعت] LT',
            lastDay : '[دیروز ساعت] LT',
            lastWeek : 'dddd [پیش] [ساعت] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'در %s',
            past : '%s پیش',
            s : 'چندین ثانیه',
            m : 'یک دقیقه',
            mm : '%d دقیقه',
            h : 'یک ساعت',
            hh : '%d ساعت',
            d : 'یک روز',
            dd : '%d روز',
            M : 'یک ماه',
            MM : '%d ماه',
            y : 'یک سال',
            yy : '%d سال'
        },
        preparse: function (string) {
            return string.replace(/[۰-۹]/g, function (match) {
                return fa__numberMap[match];
            }).replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return fa__symbolMap[match];
            }).replace(/,/g, '،');
        },
        ordinalParse: /\d{1,2}م/,
        ordinal : '%dم',
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12 // The week that contains Jan 1st is the first week of the year.
        }
    });


    var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' '),
        numbersFuture = [
            'nolla', 'yhden', 'kahden', 'kolmen', 'neljän', 'viiden', 'kuuden',
            numbersPast[7], numbersPast[8], numbersPast[9]
        ];
    function fi__translate(number, withoutSuffix, key, isFuture) {
        var result = '';
        switch (key) {
            case 's':
                return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
            case 'm':
                return isFuture ? 'minuutin' : 'minuutti';
            case 'mm':
                result = isFuture ? 'minuutin' : 'minuuttia';
                break;
            case 'h':
                return isFuture ? 'tunnin' : 'tunti';
            case 'hh':
                result = isFuture ? 'tunnin' : 'tuntia';
                break;
            case 'd':
                return isFuture ? 'päivän' : 'päivä';
            case 'dd':
                result = isFuture ? 'päivän' : 'päivää';
                break;
            case 'M':
                return isFuture ? 'kuukauden' : 'kuukausi';
            case 'MM':
                result = isFuture ? 'kuukauden' : 'kuukautta';
                break;
            case 'y':
                return isFuture ? 'vuoden' : 'vuosi';
            case 'yy':
                result = isFuture ? 'vuoden' : 'vuotta';
                break;
        }
        result = verbalNumber(number, isFuture) + ' ' + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
    }

    var fi = moment__default.defineLocale('fi', {
        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
        monthsShort : 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'Do MMMM[ta] YYYY',
            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
            l : 'D.M.YYYY',
            ll : 'Do MMM YYYY',
            lll : 'Do MMM YYYY, [klo] HH.mm',
            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
        },
        calendar : {
            sameDay : '[tänään] [klo] LT',
            nextDay : '[huomenna] [klo] LT',
            nextWeek : 'dddd [klo] LT',
            lastDay : '[eilen] [klo] LT',
            lastWeek : '[viime] dddd[na] [klo] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s päästä',
            past : '%s sitten',
            s : fi__translate,
            m : fi__translate,
            mm : fi__translate,
            h : fi__translate,
            hh : fi__translate,
            d : fi__translate,
            dd : fi__translate,
            M : fi__translate,
            MM : fi__translate,
            y : fi__translate,
            yy : fi__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var fo = moment__default.defineLocale('fo', {
        months : 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split('_'),
        weekdaysShort : 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
        weekdaysMin : 'su_má_tý_mi_hó_fr_le'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D. MMMM, YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Í dag kl.] LT',
            nextDay : '[Í morgin kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[Í gjár kl.] LT',
            lastWeek : '[síðstu] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'um %s',
            past : '%s síðani',
            s : 'fá sekund',
            m : 'ein minutt',
            mm : '%d minuttir',
            h : 'ein tími',
            hh : '%d tímar',
            d : 'ein dagur',
            dd : '%d dagar',
            M : 'ein mánaði',
            MM : '%d mánaðir',
            y : 'eitt ár',
            yy : '%d ár'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var fr_ca = moment__default.defineLocale('fr-ca', {
        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Aujourd\'hui à] LT',
            nextDay: '[Demain à] LT',
            nextWeek: 'dddd [à] LT',
            lastDay: '[Hier à] LT',
            lastWeek: 'dddd [dernier à] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|e)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : 'e');
        }
    });


    var fr_ch = moment__default.defineLocale('fr-ch', {
        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Aujourd\'hui à] LT',
            nextDay: '[Demain à] LT',
            nextWeek: 'dddd [à] LT',
            lastDay: '[Hier à] LT',
            lastWeek: 'dddd [dernier à] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|e)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : 'e');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var fr = moment__default.defineLocale('fr', {
        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Aujourd\'hui à] LT',
            nextDay: '[Demain à] LT',
            nextWeek: 'dddd [à] LT',
            lastDay: '[Hier à] LT',
            lastWeek: 'dddd [dernier à] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : '');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var fy__monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
        fy__monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

    var fy = moment__default.defineLocale('fy', {
        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return fy__monthsShortWithoutDots[m.month()];
            } else {
                return fy__monthsShortWithDots[m.month()];
            }
        },
        monthsParseExact : true,
        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[hjoed om] LT',
            nextDay: '[moarn om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[juster om] LT',
            lastWeek: '[ôfrûne] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'oer %s',
            past : '%s lyn',
            s : 'in pear sekonden',
            m : 'ien minút',
            mm : '%d minuten',
            h : 'ien oere',
            hh : '%d oeren',
            d : 'ien dei',
            dd : '%d dagen',
            M : 'ien moanne',
            MM : '%d moannen',
            y : 'ien jier',
            yy : '%d jierren'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var gd__months = [
        'Am Faoilleach', 'An Gearran', 'Am Màrt', 'An Giblean', 'An Cèitean', 'An t-Ògmhios', 'An t-Iuchar', 'An Lùnastal', 'An t-Sultain', 'An Dàmhair', 'An t-Samhain', 'An Dùbhlachd'
    ];

    var gd__monthsShort = ['Faoi', 'Gear', 'Màrt', 'Gibl', 'Cèit', 'Ògmh', 'Iuch', 'Lùn', 'Sult', 'Dàmh', 'Samh', 'Dùbh'];

    var gd__weekdays = ['Didòmhnaich', 'Diluain', 'Dimàirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

    var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

    var weekdaysMin = ['Dò', 'Lu', 'Mà', 'Ci', 'Ar', 'Ha', 'Sa'];

    var gd = moment__default.defineLocale('gd', {
        months : gd__months,
        monthsShort : gd__monthsShort,
        monthsParseExact : true,
        weekdays : gd__weekdays,
        weekdaysShort : weekdaysShort,
        weekdaysMin : weekdaysMin,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[An-diugh aig] LT',
            nextDay : '[A-màireach aig] LT',
            nextWeek : 'dddd [aig] LT',
            lastDay : '[An-dè aig] LT',
            lastWeek : 'dddd [seo chaidh] [aig] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ann an %s',
            past : 'bho chionn %s',
            s : 'beagan diogan',
            m : 'mionaid',
            mm : '%d mionaidean',
            h : 'uair',
            hh : '%d uairean',
            d : 'latha',
            dd : '%d latha',
            M : 'mìos',
            MM : '%d mìosan',
            y : 'bliadhna',
            yy : '%d bliadhna'
        },
        ordinalParse : /\d{1,2}(d|na|mh)/,
        ordinal : function (number) {
            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var gl = moment__default.defineLocale('gl', {
        months : 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xuño_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),
        monthsShort : 'Xan._Feb._Mar._Abr._Mai._Xuñ._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'Domingo_Luns_Martes_Mércores_Xoves_Venres_Sábado'.split('_'),
        weekdaysShort : 'Dom._Lun._Mar._Mér._Xov._Ven._Sáb.'.split('_'),
        weekdaysMin : 'Do_Lu_Ma_Mé_Xo_Ve_Sá'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoxe ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
            },
            nextDay : function () {
                return '[mañá ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
            },
            lastDay : function () {
                return '[onte ' + ((this.hours() !== 1) ? 'á' : 'a') + '] LT';
            },
            lastWeek : function () {
                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : function (str) {
                if (str === 'uns segundos') {
                    return 'nuns segundos';
                }
                return 'en ' + str;
            },
            past : 'hai %s',
            s : 'uns segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'unha hora',
            hh : '%d horas',
            d : 'un día',
            dd : '%d días',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ano',
            yy : '%d anos'
        },
        ordinalParse : /\d{1,2}º/,
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var he = moment__default.defineLocale('he', {
        months : 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
        monthsShort : 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split('_'),
        weekdays : 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
        weekdaysShort : 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
        weekdaysMin : 'א_ב_ג_ד_ה_ו_ש'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [ב]MMMM YYYY',
            LLL : 'D [ב]MMMM YYYY HH:mm',
            LLLL : 'dddd, D [ב]MMMM YYYY HH:mm',
            l : 'D/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[היום ב־]LT',
            nextDay : '[מחר ב־]LT',
            nextWeek : 'dddd [בשעה] LT',
            lastDay : '[אתמול ב־]LT',
            lastWeek : '[ביום] dddd [האחרון בשעה] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'בעוד %s',
            past : 'לפני %s',
            s : 'מספר שניות',
            m : 'דקה',
            mm : '%d דקות',
            h : 'שעה',
            hh : function (number) {
                if (number === 2) {
                    return 'שעתיים';
                }
                return number + ' שעות';
            },
            d : 'יום',
            dd : function (number) {
                if (number === 2) {
                    return 'יומיים';
                }
                return number + ' ימים';
            },
            M : 'חודש',
            MM : function (number) {
                if (number === 2) {
                    return 'חודשיים';
                }
                return number + ' חודשים';
            },
            y : 'שנה',
            yy : function (number) {
                if (number === 2) {
                    return 'שנתיים';
                } else if (number % 10 === 0 && number !== 10) {
                    return number + ' שנה';
                }
                return number + ' שנים';
            }
        },
        meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
        isPM : function (input) {
            return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 5) {
                return 'לפנות בוקר';
            } else if (hour < 10) {
                return 'בבוקר';
            } else if (hour < 12) {
                return isLower ? 'לפנה"צ' : 'לפני הצהריים';
            } else if (hour < 18) {
                return isLower ? 'אחה"צ' : 'אחרי הצהריים';
            } else {
                return 'בערב';
            }
        }
    });


    var hi__symbolMap = {
        '1': '१',
        '2': '२',
        '3': '३',
        '4': '४',
        '5': '५',
        '6': '६',
        '7': '७',
        '8': '८',
        '9': '९',
        '0': '०'
    },
    hi__numberMap = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0'
    };

    var hi = moment__default.defineLocale('hi', {
        months : 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
        monthsShort : 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
        monthsParseExact: true,
        weekdays : 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
        weekdaysShort : 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
        longDateFormat : {
            LT : 'A h:mm बजे',
            LTS : 'A h:mm:ss बजे',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm बजे',
            LLLL : 'dddd, D MMMM YYYY, A h:mm बजे'
        },
        calendar : {
            sameDay : '[आज] LT',
            nextDay : '[कल] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[कल] LT',
            lastWeek : '[पिछले] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s में',
            past : '%s पहले',
            s : 'कुछ ही क्षण',
            m : 'एक मिनट',
            mm : '%d मिनट',
            h : 'एक घंटा',
            hh : '%d घंटे',
            d : 'एक दिन',
            dd : '%d दिन',
            M : 'एक महीने',
            MM : '%d महीने',
            y : 'एक वर्ष',
            yy : '%d वर्ष'
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return hi__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return hi__symbolMap[match];
            });
        },
        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
        meridiemParse: /रात|सुबह|दोपहर|शाम/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'रात') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'सुबह') {
                return hour;
            } else if (meridiem === 'दोपहर') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'शाम') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'रात';
            } else if (hour < 10) {
                return 'सुबह';
            } else if (hour < 17) {
                return 'दोपहर';
            } else if (hour < 20) {
                return 'शाम';
            } else {
                return 'रात';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });


    function hr__translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'm':
                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
            case 'mm':
                if (number === 1) {
                    result += 'minuta';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'minute';
                } else {
                    result += 'minuta';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'jedan sat' : 'jednog sata';
            case 'hh':
                if (number === 1) {
                    result += 'sat';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sata';
                } else {
                    result += 'sati';
                }
                return result;
            case 'dd':
                if (number === 1) {
                    result += 'dan';
                } else {
                    result += 'dana';
                }
                return result;
            case 'MM':
                if (number === 1) {
                    result += 'mjesec';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'mjeseca';
                } else {
                    result += 'mjeseci';
                }
                return result;
            case 'yy':
                if (number === 1) {
                    result += 'godina';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'godine';
                } else {
                    result += 'godina';
                }
                return result;
        }
    }

    var hr = moment__default.defineLocale('hr', {
        months : {
            format: 'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
            standalone: 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
        },
        monthsShort : 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jučer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                        return '[prošlu] dddd [u] LT';
                    case 6:
                        return '[prošle] [subote] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prošli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            m      : hr__translate,
            mm     : hr__translate,
            h      : hr__translate,
            hh     : hr__translate,
            d      : 'dan',
            dd     : hr__translate,
            M      : 'mjesec',
            MM     : hr__translate,
            y      : 'godinu',
            yy     : hr__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ');
    function hu__translate(number, withoutSuffix, key, isFuture) {
        var num = number,
            suffix;
        switch (key) {
            case 's':
                return (isFuture || withoutSuffix) ? 'néhány másodperc' : 'néhány másodperce';
            case 'm':
                return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'mm':
                return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'h':
                return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
            case 'hh':
                return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
            case 'd':
                return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'dd':
                return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'M':
                return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
            case 'MM':
                return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
            case 'y':
                return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
            case 'yy':
                return num + (isFuture || withoutSuffix ? ' év' : ' éve');
        }
        return '';
    }
    function week(isFuture) {
        return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
    }

    var hu = moment__default.defineLocale('hu', {
        months : 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
        monthsShort : 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
        weekdays : 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
        weekdaysShort : 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'YYYY.MM.DD.',
            LL : 'YYYY. MMMM D.',
            LLL : 'YYYY. MMMM D. H:mm',
            LLLL : 'YYYY. MMMM D., dddd H:mm'
        },
        meridiemParse: /de|du/i,
        isPM: function (input) {
            return input.charAt(1).toLowerCase() === 'u';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? 'de' : 'DE';
            } else {
                return isLower === true ? 'du' : 'DU';
            }
        },
        calendar : {
            sameDay : '[ma] LT[-kor]',
            nextDay : '[holnap] LT[-kor]',
            nextWeek : function () {
                return week.call(this, true);
            },
            lastDay : '[tegnap] LT[-kor]',
            lastWeek : function () {
                return week.call(this, false);
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s múlva',
            past : '%s',
            s : hu__translate,
            m : hu__translate,
            mm : hu__translate,
            h : hu__translate,
            hh : hu__translate,
            d : hu__translate,
            dd : hu__translate,
            M : hu__translate,
            MM : hu__translate,
            y : hu__translate,
            yy : hu__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var hy_am = moment__default.defineLocale('hy-am', {
        months : {
            format: 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split('_'),
            standalone: 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split('_')
        },
        monthsShort : 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_'),
        weekdays : 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split('_'),
        weekdaysShort : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
        weekdaysMin : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY թ.',
            LLL : 'D MMMM YYYY թ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY թ., HH:mm'
        },
        calendar : {
            sameDay: '[այսօր] LT',
            nextDay: '[վաղը] LT',
            lastDay: '[երեկ] LT',
            nextWeek: function () {
                return 'dddd [օրը ժամը] LT';
            },
            lastWeek: function () {
                return '[անցած] dddd [օրը ժամը] LT';
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s հետո',
            past : '%s առաջ',
            s : 'մի քանի վայրկյան',
            m : 'րոպե',
            mm : '%d րոպե',
            h : 'ժամ',
            hh : '%d ժամ',
            d : 'օր',
            dd : '%d օր',
            M : 'ամիս',
            MM : '%d ամիս',
            y : 'տարի',
            yy : '%d տարի'
        },
        meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
        isPM: function (input) {
            return /^(ցերեկվա|երեկոյան)$/.test(input);
        },
        meridiem : function (hour) {
            if (hour < 4) {
                return 'գիշերվա';
            } else if (hour < 12) {
                return 'առավոտվա';
            } else if (hour < 17) {
                return 'ցերեկվա';
            } else {
                return 'երեկոյան';
            }
        },
        ordinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'DDD':
                case 'w':
                case 'W':
                case 'DDDo':
                    if (number === 1) {
                        return number + '-ին';
                    }
                    return number + '-րդ';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var id = moment__default.defineLocale('id', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'siang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sore' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'siang';
            } else if (hours < 19) {
                return 'sore';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Besok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kemarin pukul] LT',
            lastWeek : 'dddd [lalu pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lalu',
            s : 'beberapa detik',
            m : 'semenit',
            mm : '%d menit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    function is__plural(n) {
        if (n % 100 === 11) {
            return true;
        } else if (n % 10 === 1) {
            return false;
        }
        return true;
    }
    function is__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                return withoutSuffix || isFuture ? 'nokkrar sekúndur' : 'nokkrum sekúndum';
            case 'm':
                return withoutSuffix ? 'mínúta' : 'mínútu';
            case 'mm':
                if (is__plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum');
                } else if (withoutSuffix) {
                    return result + 'mínúta';
                }
                return result + 'mínútu';
            case 'hh':
                if (is__plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
                }
                return result + 'klukkustund';
            case 'd':
                if (withoutSuffix) {
                    return 'dagur';
                }
                return isFuture ? 'dag' : 'degi';
            case 'dd':
                if (is__plural(number)) {
                    if (withoutSuffix) {
                        return result + 'dagar';
                    }
                    return result + (isFuture ? 'daga' : 'dögum');
                } else if (withoutSuffix) {
                    return result + 'dagur';
                }
                return result + (isFuture ? 'dag' : 'degi');
            case 'M':
                if (withoutSuffix) {
                    return 'mánuður';
                }
                return isFuture ? 'mánuð' : 'mánuði';
            case 'MM':
                if (is__plural(number)) {
                    if (withoutSuffix) {
                        return result + 'mánuðir';
                    }
                    return result + (isFuture ? 'mánuði' : 'mánuðum');
                } else if (withoutSuffix) {
                    return result + 'mánuður';
                }
                return result + (isFuture ? 'mánuð' : 'mánuði');
            case 'y':
                return withoutSuffix || isFuture ? 'ár' : 'ári';
            case 'yy':
                if (is__plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
                }
                return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
        }
    }

    var is = moment__default.defineLocale('is', {
        months : 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
        weekdays : 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split('_'),
        weekdaysShort : 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
        weekdaysMin : 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] H:mm',
            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
        },
        calendar : {
            sameDay : '[í dag kl.] LT',
            nextDay : '[á morgun kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[í gær kl.] LT',
            lastWeek : '[síðasta] dddd [kl.] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'eftir %s',
            past : 'fyrir %s síðan',
            s : is__translate,
            m : is__translate,
            mm : is__translate,
            h : 'klukkustund',
            hh : is__translate,
            d : is__translate,
            dd : is__translate,
            M : is__translate,
            MM : is__translate,
            y : is__translate,
            yy : is__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var it = moment__default.defineLocale('it', {
        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays : 'Domenica_Lunedì_Martedì_Mercoledì_Giovedì_Venerdì_Sabato'.split('_'),
        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
        weekdaysMin : 'Do_Lu_Ma_Me_Gi_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : function (s) {
                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past : '%s fa',
            s : 'alcuni secondi',
            m : 'un minuto',
            mm : '%d minuti',
            h : 'un\'ora',
            hh : '%d ore',
            d : 'un giorno',
            dd : '%d giorni',
            M : 'un mese',
            MM : '%d mesi',
            y : 'un anno',
            yy : '%d anni'
        },
        ordinalParse : /\d{1,2}º/,
        ordinal: '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var ja = moment__default.defineLocale('ja', {
        months : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
        weekdaysShort : '日_月_火_水_木_金_土'.split('_'),
        weekdaysMin : '日_月_火_水_木_金_土'.split('_'),
        longDateFormat : {
            LT : 'Ah時m分',
            LTS : 'Ah時m分s秒',
            L : 'YYYY/MM/DD',
            LL : 'YYYY年M月D日',
            LLL : 'YYYY年M月D日Ah時m分',
            LLLL : 'YYYY年M月D日Ah時m分 dddd'
        },
        meridiemParse: /午前|午後/i,
        isPM : function (input) {
            return input === '午後';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '午前';
            } else {
                return '午後';
            }
        },
        calendar : {
            sameDay : '[今日] LT',
            nextDay : '[明日] LT',
            nextWeek : '[来週]dddd LT',
            lastDay : '[昨日] LT',
            lastWeek : '[前週]dddd LT',
            sameElse : 'L'
        },
        ordinalParse : /\d{1,2}日/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                default:
                    return number;
            }
        },
        relativeTime : {
            future : '%s後',
            past : '%s前',
            s : '数秒',
            m : '1分',
            mm : '%d分',
            h : '1時間',
            hh : '%d時間',
            d : '1日',
            dd : '%d日',
            M : '1ヶ月',
            MM : '%dヶ月',
            y : '1年',
            yy : '%d年'
        }
    });


    var jv = moment__default.defineLocale('jv', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'enjing') {
                return hour;
            } else if (meridiem === 'siyang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'enjing';
            } else if (hours < 15) {
                return 'siyang';
            } else if (hours < 19) {
                return 'sonten';
            } else {
                return 'ndalu';
            }
        },
        calendar : {
            sameDay : '[Dinten puniko pukul] LT',
            nextDay : '[Mbenjang pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kala wingi pukul] LT',
            lastWeek : 'dddd [kepengker pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'wonten ing %s',
            past : '%s ingkang kepengker',
            s : 'sawetawis detik',
            m : 'setunggal menit',
            mm : '%d menit',
            h : 'setunggal jam',
            hh : '%d jam',
            d : 'sedinten',
            dd : '%d dinten',
            M : 'sewulan',
            MM : '%d wulan',
            y : 'setaun',
            yy : '%d taun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var ka = moment__default.defineLocale('ka', {
        months : {
            standalone: 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split('_'),
            format: 'იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს'.split('_')
        },
        monthsShort : 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
        weekdays : {
            standalone: 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split('_'),
            format: 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split('_'),
            isFormat: /(წინა|შემდეგ)/
        },
        weekdaysShort : 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
        weekdaysMin : 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[დღეს] LT[-ზე]',
            nextDay : '[ხვალ] LT[-ზე]',
            lastDay : '[გუშინ] LT[-ზე]',
            nextWeek : '[შემდეგ] dddd LT[-ზე]',
            lastWeek : '[წინა] dddd LT-ზე',
            sameElse : 'L'
        },
        relativeTime : {
            future : function (s) {
                return (/(წამი|წუთი|საათი|წელი)/).test(s) ?
                    s.replace(/ი$/, 'ში') :
                    s + 'ში';
            },
            past : function (s) {
                if ((/(წამი|წუთი|საათი|დღე|თვე)/).test(s)) {
                    return s.replace(/(ი|ე)$/, 'ის წინ');
                }
                if ((/წელი/).test(s)) {
                    return s.replace(/წელი$/, 'წლის წინ');
                }
            },
            s : 'რამდენიმე წამი',
            m : 'წუთი',
            mm : '%d წუთი',
            h : 'საათი',
            hh : '%d საათი',
            d : 'დღე',
            dd : '%d დღე',
            M : 'თვე',
            MM : '%d თვე',
            y : 'წელი',
            yy : '%d წელი'
        },
        ordinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
        ordinal : function (number) {
            if (number === 0) {
                return number;
            }
            if (number === 1) {
                return number + '-ლი';
            }
            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
                return 'მე-' + number;
            }
            return number + '-ე';
        },
        week : {
            dow : 1,
            doy : 7
        }
    });


    var kk__suffixes = {
        0: '-ші',
        1: '-ші',
        2: '-ші',
        3: '-ші',
        4: '-ші',
        5: '-ші',
        6: '-шы',
        7: '-ші',
        8: '-ші',
        9: '-шы',
        10: '-шы',
        20: '-шы',
        30: '-шы',
        40: '-шы',
        50: '-ші',
        60: '-шы',
        70: '-ші',
        80: '-ші',
        90: '-шы',
        100: '-ші'
    };

    var kk = moment__default.defineLocale('kk', {
        months : 'қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан'.split('_'),
        monthsShort : 'қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел'.split('_'),
        weekdays : 'жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі'.split('_'),
        weekdaysShort : 'жек_дүй_сей_сәр_бей_жұм_сен'.split('_'),
        weekdaysMin : 'жк_дй_сй_ср_бй_жм_сн'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Бүгін сағат] LT',
            nextDay : '[Ертең сағат] LT',
            nextWeek : 'dddd [сағат] LT',
            lastDay : '[Кеше сағат] LT',
            lastWeek : '[Өткен аптаның] dddd [сағат] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ішінде',
            past : '%s бұрын',
            s : 'бірнеше секунд',
            m : 'бір минут',
            mm : '%d минут',
            h : 'бір сағат',
            hh : '%d сағат',
            d : 'бір күн',
            dd : '%d күн',
            M : 'бір ай',
            MM : '%d ай',
            y : 'бір жыл',
            yy : '%d жыл'
        },
        ordinalParse: /\d{1,2}-(ші|шы)/,
        ordinal : function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (kk__suffixes[number] || kk__suffixes[a] || kk__suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var km = moment__default.defineLocale('km', {
        months: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
        monthsShort: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
        weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
        weekdaysShort: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
        weekdaysMin: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[ថ្ងៃនេះ ម៉ោង] LT',
            nextDay: '[ស្អែក ម៉ោង] LT',
            nextWeek: 'dddd [ម៉ោង] LT',
            lastDay: '[ម្សិលមិញ ម៉ោង] LT',
            lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%sទៀត',
            past: '%sមុន',
            s: 'ប៉ុន្មានវិនាទី',
            m: 'មួយនាទី',
            mm: '%d នាទី',
            h: 'មួយម៉ោង',
            hh: '%d ម៉ោង',
            d: 'មួយថ្ងៃ',
            dd: '%d ថ្ងៃ',
            M: 'មួយខែ',
            MM: '%d ខែ',
            y: 'មួយឆ្នាំ',
            yy: '%d ឆ្នាំ'
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });


    var ko = moment__default.defineLocale('ko', {
        months : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
        monthsShort : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
        weekdays : '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
        weekdaysShort : '일_월_화_수_목_금_토'.split('_'),
        weekdaysMin : '일_월_화_수_목_금_토'.split('_'),
        longDateFormat : {
            LT : 'A h시 m분',
            LTS : 'A h시 m분 s초',
            L : 'YYYY.MM.DD',
            LL : 'YYYY년 MMMM D일',
            LLL : 'YYYY년 MMMM D일 A h시 m분',
            LLLL : 'YYYY년 MMMM D일 dddd A h시 m분'
        },
        calendar : {
            sameDay : '오늘 LT',
            nextDay : '내일 LT',
            nextWeek : 'dddd LT',
            lastDay : '어제 LT',
            lastWeek : '지난주 dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s 후',
            past : '%s 전',
            s : '몇 초',
            ss : '%d초',
            m : '일분',
            mm : '%d분',
            h : '한 시간',
            hh : '%d시간',
            d : '하루',
            dd : '%d일',
            M : '한 달',
            MM : '%d달',
            y : '일 년',
            yy : '%d년'
        },
        ordinalParse : /\d{1,2}일/,
        ordinal : '%d일',
        meridiemParse : /오전|오후/,
        isPM : function (token) {
            return token === '오후';
        },
        meridiem : function (hour, minute, isUpper) {
            return hour < 12 ? '오전' : '오후';
        }
    });



    var ky__suffixes = {
        0: '-чү',
        1: '-чи',
        2: '-чи',
        3: '-чү',
        4: '-чү',
        5: '-чи',
        6: '-чы',
        7: '-чи',
        8: '-чи',
        9: '-чу',
        10: '-чу',
        20: '-чы',
        30: '-чу',
        40: '-чы',
        50: '-чү',
        60: '-чы',
        70: '-чи',
        80: '-чи',
        90: '-чу',
        100: '-чү'
    };

    var ky = moment__default.defineLocale('ky', {
        months : 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
        monthsShort : 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_'),
        weekdays : 'Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби'.split('_'),
        weekdaysShort : 'Жек_Дүй_Шей_Шар_Бей_Жум_Ише'.split('_'),
        weekdaysMin : 'Жк_Дй_Шй_Шр_Бй_Жм_Иш'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Бүгүн саат] LT',
            nextDay : '[Эртең саат] LT',
            nextWeek : 'dddd [саат] LT',
            lastDay : '[Кече саат] LT',
            lastWeek : '[Өткен аптанын] dddd [күнү] [саат] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ичинде',
            past : '%s мурун',
            s : 'бирнече секунд',
            m : 'бир мүнөт',
            mm : '%d мүнөт',
            h : 'бир саат',
            hh : '%d саат',
            d : 'бир күн',
            dd : '%d күн',
            M : 'бир ай',
            MM : '%d ай',
            y : 'бир жыл',
            yy : '%d жыл'
        },
        ordinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
        ordinal : function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (ky__suffixes[number] || ky__suffixes[a] || ky__suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    function lb__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eng Minutt', 'enger Minutt'],
            'h': ['eng Stonn', 'enger Stonn'],
            'd': ['een Dag', 'engem Dag'],
            'M': ['ee Mount', 'engem Mount'],
            'y': ['ee Joer', 'engem Joer']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'a ' + string;
        }
        return 'an ' + string;
    }
    function processPastTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'viru ' + string;
        }
        return 'virun ' + string;
    }
    /**
     * Returns true if the word before the given number loses the '-n' ending.
     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
     *
     * @param number {integer}
     * @returns {boolean}
     */
    function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);
        if (isNaN(number)) {
            return false;
        }
        if (number < 0) {
            // Negative Number --> always true
            return true;
        } else if (number < 10) {
            // Only 1 digit
            if (4 <= number && number <= 7) {
                return true;
            }
            return false;
        } else if (number < 100) {
            // 2 digits
            var lastDigit = number % 10, firstDigit = number / 10;
            if (lastDigit === 0) {
                return eifelerRegelAppliesToNumber(firstDigit);
            }
            return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 10000) {
            // 3 or 4 digits --> recursively check first digit
            while (number >= 10) {
                number = number / 10;
            }
            return eifelerRegelAppliesToNumber(number);
        } else {
            // Anything larger than 4 digits: recursively check first n-3 digits
            number = number / 1000;
            return eifelerRegelAppliesToNumber(number);
        }
    }

    var lb = moment__default.defineLocale('lb', {
        months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
        weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm [Auer]',
            LTS: 'H:mm:ss [Auer]',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm [Auer]',
            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
        },
        calendar: {
            sameDay: '[Haut um] LT',
            sameElse: 'L',
            nextDay: '[Muer um] LT',
            nextWeek: 'dddd [um] LT',
            lastDay: '[Gëschter um] LT',
            lastWeek: function () {
                // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                switch (this.day()) {
                    case 2:
                    case 4:
                        return '[Leschten] dddd [um] LT';
                    default:
                        return '[Leschte] dddd [um] LT';
                }
            }
        },
        relativeTime : {
            future : processFutureTime,
            past : processPastTime,
            s : 'e puer Sekonnen',
            m : lb__processRelativeTime,
            mm : '%d Minutten',
            h : lb__processRelativeTime,
            hh : '%d Stonnen',
            d : lb__processRelativeTime,
            dd : '%d Deeg',
            M : lb__processRelativeTime,
            MM : '%d Méint',
            y : lb__processRelativeTime,
            yy : '%d Joer'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var lo = moment__default.defineLocale('lo', {
        months : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
        monthsShort : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
        weekdays : 'ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
        weekdaysShort : 'ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
        weekdaysMin : 'ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'ວັນdddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
        isPM: function (input) {
            return input === 'ຕອນແລງ';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ຕອນເຊົ້າ';
            } else {
                return 'ຕອນແລງ';
            }
        },
        calendar : {
            sameDay : '[ມື້ນີ້ເວລາ] LT',
            nextDay : '[ມື້ອື່ນເວລາ] LT',
            nextWeek : '[ວັນ]dddd[ໜ້າເວລາ] LT',
            lastDay : '[ມື້ວານນີ້ເວລາ] LT',
            lastWeek : '[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ອີກ %s',
            past : '%sຜ່ານມາ',
            s : 'ບໍ່ເທົ່າໃດວິນາທີ',
            m : '1 ນາທີ',
            mm : '%d ນາທີ',
            h : '1 ຊົ່ວໂມງ',
            hh : '%d ຊົ່ວໂມງ',
            d : '1 ມື້',
            dd : '%d ມື້',
            M : '1 ເດືອນ',
            MM : '%d ເດືອນ',
            y : '1 ປີ',
            yy : '%d ປີ'
        },
        ordinalParse: /(ທີ່)\d{1,2}/,
        ordinal : function (number) {
            return 'ທີ່' + number;
        }
    });


    var lt__units = {
        'm' : 'minutė_minutės_minutę',
        'mm': 'minutės_minučių_minutes',
        'h' : 'valanda_valandos_valandą',
        'hh': 'valandos_valandų_valandas',
        'd' : 'diena_dienos_dieną',
        'dd': 'dienos_dienų_dienas',
        'M' : 'mėnuo_mėnesio_mėnesį',
        'MM': 'mėnesiai_mėnesių_mėnesius',
        'y' : 'metai_metų_metus',
        'yy': 'metai_metų_metus'
    };
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
            return 'kelios sekundės';
        } else {
            return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
        }
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
    }
    function special(number) {
        return number % 10 === 0 || (number > 10 && number < 20);
    }
    function forms(key) {
        return lt__units[key].split('_');
    }
    function lt__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        if (number === 1) {
            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
        } else if (withoutSuffix) {
            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
            if (isFuture) {
                return result + forms(key)[1];
            } else {
                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
            }
        }
    }
    var lt = moment__default.defineLocale('lt', {
        months : {
            format: 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split('_'),
            standalone: 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split('_'),
            isFormat: /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?|MMMM?(\[[^\[\]]*\]|\s+)+D[oD]?/
        },
        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
        weekdays : {
            format: 'sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį'.split('_'),
            standalone: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split('_'),
            isFormat: /dddd HH:mm/
        },
        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
        weekdaysMin : 'S_P_A_T_K_Pn_Š'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY [m.] MMMM D [d.]',
            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
            l : 'YYYY-MM-DD',
            ll : 'YYYY [m.] MMMM D [d.]',
            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
        },
        calendar : {
            sameDay : '[Šiandien] LT',
            nextDay : '[Rytoj] LT',
            nextWeek : 'dddd LT',
            lastDay : '[Vakar] LT',
            lastWeek : '[Praėjusį] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'po %s',
            past : 'prieš %s',
            s : translateSeconds,
            m : translateSingular,
            mm : lt__translate,
            h : translateSingular,
            hh : lt__translate,
            d : translateSingular,
            dd : lt__translate,
            M : translateSingular,
            MM : lt__translate,
            y : translateSingular,
            yy : lt__translate
        },
        ordinalParse: /\d{1,2}-oji/,
        ordinal : function (number) {
            return number + '-oji';
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var lv__units = {
        'm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
        'mm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
        'h': 'stundas_stundām_stunda_stundas'.split('_'),
        'hh': 'stundas_stundām_stunda_stundas'.split('_'),
        'd': 'dienas_dienām_diena_dienas'.split('_'),
        'dd': 'dienas_dienām_diena_dienas'.split('_'),
        'M': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
        'MM': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
        'y': 'gada_gadiem_gads_gadi'.split('_'),
        'yy': 'gada_gadiem_gads_gadi'.split('_')
    };
    /**
     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
     */
    function lv__format(forms, number, withoutSuffix) {
        if (withoutSuffix) {
            // E.g. "21 minūte", "3 minūtes".
            return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
        } else {
            // E.g. "21 minūtes" as in "pēc 21 minūtes".
            // E.g. "3 minūtēm" as in "pēc 3 minūtēm".
            return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
        }
    }
    function lv__relativeTimeWithPlural(number, withoutSuffix, key) {
        return number + ' ' + lv__format(lv__units[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
        return lv__format(lv__units[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm';
    }

    var lv = moment__default.defineLocale('lv', {
        months : 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY.',
            LL : 'YYYY. [gada] D. MMMM',
            LLL : 'YYYY. [gada] D. MMMM, HH:mm',
            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
        },
        calendar : {
            sameDay : '[Šodien pulksten] LT',
            nextDay : '[Rīt pulksten] LT',
            nextWeek : 'dddd [pulksten] LT',
            lastDay : '[Vakar pulksten] LT',
            lastWeek : '[Pagājušā] dddd [pulksten] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'pēc %s',
            past : 'pirms %s',
            s : relativeSeconds,
            m : relativeTimeWithSingular,
            mm : lv__relativeTimeWithPlural,
            h : relativeTimeWithSingular,
            hh : lv__relativeTimeWithPlural,
            d : relativeTimeWithSingular,
            dd : lv__relativeTimeWithPlural,
            M : relativeTimeWithSingular,
            MM : lv__relativeTimeWithPlural,
            y : relativeTimeWithSingular,
            yy : lv__relativeTimeWithPlural
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var me__translator = {
        words: { //Different grammatical cases
            m: ['jedan minut', 'jednog minuta'],
            mm: ['minut', 'minuta', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mjesec', 'mjeseca', 'mjeseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = me__translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + me__translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var me = moment__default.defineLocale('me', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact : true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sjutra u] LT',

            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juče u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prošle] [nedjelje] [u] LT',
                    '[prošlog] [ponedjeljka] [u] LT',
                    '[prošlog] [utorka] [u] LT',
                    '[prošle] [srijede] [u] LT',
                    '[prošlog] [četvrtka] [u] LT',
                    '[prošlog] [petka] [u] LT',
                    '[prošle] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'nekoliko sekundi',
            m      : me__translator.translate,
            mm     : me__translator.translate,
            h      : me__translator.translate,
            hh     : me__translator.translate,
            d      : 'dan',
            dd     : me__translator.translate,
            M      : 'mjesec',
            MM     : me__translator.translate,
            y      : 'godinu',
            yy     : me__translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var mk = moment__default.defineLocale('mk', {
        months : 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
        monthsShort : 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
        weekdays : 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
        weekdaysShort : 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
        weekdaysMin : 'нe_пo_вт_ср_че_пе_сa'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : '[Денес во] LT',
            nextDay : '[Утре во] LT',
            nextWeek : '[Во] dddd [во] LT',
            lastDay : '[Вчера во] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 6:
                        return '[Изминатата] dddd [во] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[Изминатиот] dddd [во] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'после %s',
            past : 'пред %s',
            s : 'неколку секунди',
            m : 'минута',
            mm : '%d минути',
            h : 'час',
            hh : '%d часа',
            d : 'ден',
            dd : '%d дена',
            M : 'месец',
            MM : '%d месеци',
            y : 'година',
            yy : '%d години'
        },
        ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-ев';
            } else if (last2Digits === 0) {
                return number + '-ен';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-ти';
            } else if (lastDigit === 1) {
                return number + '-ви';
            } else if (lastDigit === 2) {
                return number + '-ри';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-ми';
            } else {
                return number + '-ти';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var ml = moment__default.defineLocale('ml', {
        months : 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split('_'),
        monthsShort : 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split('_'),
        monthsParseExact : true,
        weekdays : 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split('_'),
        weekdaysShort : 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
        weekdaysMin : 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
        longDateFormat : {
            LT : 'A h:mm -നു',
            LTS : 'A h:mm:ss -നു',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm -നു',
            LLLL : 'dddd, D MMMM YYYY, A h:mm -നു'
        },
        calendar : {
            sameDay : '[ഇന്ന്] LT',
            nextDay : '[നാളെ] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[ഇന്നലെ] LT',
            lastWeek : '[കഴിഞ്ഞ] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s കഴിഞ്ഞ്',
            past : '%s മുൻപ്',
            s : 'അൽപ നിമിഷങ്ങൾ',
            m : 'ഒരു മിനിറ്റ്',
            mm : '%d മിനിറ്റ്',
            h : 'ഒരു മണിക്കൂർ',
            hh : '%d മണിക്കൂർ',
            d : 'ഒരു ദിവസം',
            dd : '%d ദിവസം',
            M : 'ഒരു മാസം',
            MM : '%d മാസം',
            y : 'ഒരു വർഷം',
            yy : '%d വർഷം'
        },
        meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === 'രാത്രി' && hour >= 4) ||
                    meridiem === 'ഉച്ച കഴിഞ്ഞ്' ||
                    meridiem === 'വൈകുന്നേരം') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'രാത്രി';
            } else if (hour < 12) {
                return 'രാവിലെ';
            } else if (hour < 17) {
                return 'ഉച്ച കഴിഞ്ഞ്';
            } else if (hour < 20) {
                return 'വൈകുന്നേരം';
            } else {
                return 'രാത്രി';
            }
        }
    });


    var mr__symbolMap = {
        '1': '१',
        '2': '२',
        '3': '३',
        '4': '४',
        '5': '५',
        '6': '६',
        '7': '७',
        '8': '८',
        '9': '९',
        '0': '०'
    },
    mr__numberMap = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0'
    };

    function relativeTimeMr(number, withoutSuffix, string, isFuture)
    {
        var output = '';
        if (withoutSuffix) {
            switch (string) {
                case 's': output = 'काही सेकंद'; break;
                case 'm': output = 'एक मिनिट'; break;
                case 'mm': output = '%d मिनिटे'; break;
                case 'h': output = 'एक तास'; break;
                case 'hh': output = '%d तास'; break;
                case 'd': output = 'एक दिवस'; break;
                case 'dd': output = '%d दिवस'; break;
                case 'M': output = 'एक महिना'; break;
                case 'MM': output = '%d महिने'; break;
                case 'y': output = 'एक वर्ष'; break;
                case 'yy': output = '%d वर्षे'; break;
            }
        }
        else {
            switch (string) {
                case 's': output = 'काही सेकंदां'; break;
                case 'm': output = 'एका मिनिटा'; break;
                case 'mm': output = '%d मिनिटां'; break;
                case 'h': output = 'एका तासा'; break;
                case 'hh': output = '%d तासां'; break;
                case 'd': output = 'एका दिवसा'; break;
                case 'dd': output = '%d दिवसां'; break;
                case 'M': output = 'एका महिन्या'; break;
                case 'MM': output = '%d महिन्यां'; break;
                case 'y': output = 'एका वर्षा'; break;
                case 'yy': output = '%d वर्षां'; break;
            }
        }
        return output.replace(/%d/i, number);
    }

    var mr = moment__default.defineLocale('mr', {
        months : 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split('_'),
        monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split('_'),
        monthsParseExact : true,
        weekdays : 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
        weekdaysShort : 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
        longDateFormat : {
            LT : 'A h:mm वाजता',
            LTS : 'A h:mm:ss वाजता',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm वाजता',
            LLLL : 'dddd, D MMMM YYYY, A h:mm वाजता'
        },
        calendar : {
            sameDay : '[आज] LT',
            nextDay : '[उद्या] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[काल] LT',
            lastWeek: '[मागील] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future: '%sमध्ये',
            past: '%sपूर्वी',
            s: relativeTimeMr,
            m: relativeTimeMr,
            mm: relativeTimeMr,
            h: relativeTimeMr,
            hh: relativeTimeMr,
            d: relativeTimeMr,
            dd: relativeTimeMr,
            M: relativeTimeMr,
            MM: relativeTimeMr,
            y: relativeTimeMr,
            yy: relativeTimeMr
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return mr__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return mr__symbolMap[match];
            });
        },
        meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'रात्री') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'सकाळी') {
                return hour;
            } else if (meridiem === 'दुपारी') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'सायंकाळी') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'रात्री';
            } else if (hour < 10) {
                return 'सकाळी';
            } else if (hour < 17) {
                return 'दुपारी';
            } else if (hour < 20) {
                return 'सायंकाळी';
            } else {
                return 'रात्री';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var ms_my = moment__default.defineLocale('ms-my', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var locale_ms = moment__default.defineLocale('ms', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var my__symbolMap = {
        '1': '၁',
        '2': '၂',
        '3': '၃',
        '4': '၄',
        '5': '၅',
        '6': '၆',
        '7': '၇',
        '8': '၈',
        '9': '၉',
        '0': '၀'
    }, my__numberMap = {
        '၁': '1',
        '၂': '2',
        '၃': '3',
        '၄': '4',
        '၅': '5',
        '၆': '6',
        '၇': '7',
        '၈': '8',
        '၉': '9',
        '၀': '0'
    };

    var my = moment__default.defineLocale('my', {
        months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split('_'),
        monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
        weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split('_'),
        weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
        weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),

        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[ယနေ.] LT [မှာ]',
            nextDay: '[မနက်ဖြန်] LT [မှာ]',
            nextWeek: 'dddd LT [မှာ]',
            lastDay: '[မနေ.က] LT [မှာ]',
            lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'လာမည့် %s မှာ',
            past: 'လွန်ခဲ့သော %s က',
            s: 'စက္ကန်.အနည်းငယ်',
            m: 'တစ်မိနစ်',
            mm: '%d မိနစ်',
            h: 'တစ်နာရီ',
            hh: '%d နာရီ',
            d: 'တစ်ရက်',
            dd: '%d ရက်',
            M: 'တစ်လ',
            MM: '%d လ',
            y: 'တစ်နှစ်',
            yy: '%d နှစ်'
        },
        preparse: function (string) {
            return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
                return my__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return my__symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 1st is the first week of the year.
        }
    });


    var nb = moment__default.defineLocale('nb', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
        monthsParseExact : true,
        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
        weekdaysShort : 'sø._ma._ti._on._to._fr._lø.'.split('_'),
        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] HH:mm',
            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[i går kl.] LT',
            lastWeek: '[forrige] dddd [kl.] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'noen sekunder',
            m : 'ett minutt',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dager',
            M : 'en måned',
            MM : '%d måneder',
            y : 'ett år',
            yy : '%d år'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var ne__symbolMap = {
        '1': '१',
        '2': '२',
        '3': '३',
        '4': '४',
        '5': '५',
        '6': '६',
        '7': '७',
        '8': '८',
        '9': '९',
        '0': '०'
    },
    ne__numberMap = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0'
    };

    var ne = moment__default.defineLocale('ne', {
        months : 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split('_'),
        monthsShort : 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split('_'),
        monthsParseExact : true,
        weekdays : 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split('_'),
        weekdaysShort : 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
        weekdaysMin : 'आ._सो._मं._बु._बि._शु._श.'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'Aको h:mm बजे',
            LTS : 'Aको h:mm:ss बजे',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, Aको h:mm बजे',
            LLLL : 'dddd, D MMMM YYYY, Aको h:mm बजे'
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return ne__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return ne__symbolMap[match];
            });
        },
        meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'राति') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'बिहान') {
                return hour;
            } else if (meridiem === 'दिउँसो') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'साँझ') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 3) {
                return 'राति';
            } else if (hour < 12) {
                return 'बिहान';
            } else if (hour < 16) {
                return 'दिउँसो';
            } else if (hour < 20) {
                return 'साँझ';
            } else {
                return 'राति';
            }
        },
        calendar : {
            sameDay : '[आज] LT',
            nextDay : '[भोलि] LT',
            nextWeek : '[आउँदो] dddd[,] LT',
            lastDay : '[हिजो] LT',
            lastWeek : '[गएको] dddd[,] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%sमा',
            past : '%s अगाडि',
            s : 'केही क्षण',
            m : 'एक मिनेट',
            mm : '%d मिनेट',
            h : 'एक घण्टा',
            hh : '%d घण्टा',
            d : 'एक दिन',
            dd : '%d दिन',
            M : 'एक महिना',
            MM : '%d महिना',
            y : 'एक बर्ष',
            yy : '%d बर्ष'
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var nl__monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        nl__monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var nl = moment__default.defineLocale('nl', {
        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return nl__monthsShortWithoutDots[m.month()];
            } else {
                return nl__monthsShortWithDots[m.month()];
            }
        },
        monthsParseExact : true,
        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'over %s',
            past : '%s geleden',
            s : 'een paar seconden',
            m : 'één minuut',
            mm : '%d minuten',
            h : 'één uur',
            hh : '%d uur',
            d : 'één dag',
            dd : '%d dagen',
            M : 'één maand',
            MM : '%d maanden',
            y : 'één jaar',
            yy : '%d jaar'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var nn = moment__default.defineLocale('nn', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
        weekdaysShort : 'sun_mån_tys_ons_tor_fre_lau'.split('_'),
        weekdaysMin : 'su_må_ty_on_to_fr_lø'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] H:mm',
            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay: '[I dag klokka] LT',
            nextDay: '[I morgon klokka] LT',
            nextWeek: 'dddd [klokka] LT',
            lastDay: '[I går klokka] LT',
            lastWeek: '[Føregåande] dddd [klokka] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s sidan',
            s : 'nokre sekund',
            m : 'eit minutt',
            mm : '%d minutt',
            h : 'ein time',
            hh : '%d timar',
            d : 'ein dag',
            dd : '%d dagar',
            M : 'ein månad',
            MM : '%d månader',
            y : 'eit år',
            yy : '%d år'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var pa_in__symbolMap = {
        '1': '੧',
        '2': '੨',
        '3': '੩',
        '4': '੪',
        '5': '੫',
        '6': '੬',
        '7': '੭',
        '8': '੮',
        '9': '੯',
        '0': '੦'
    },
    pa_in__numberMap = {
        '੧': '1',
        '੨': '2',
        '੩': '3',
        '੪': '4',
        '੫': '5',
        '੬': '6',
        '੭': '7',
        '੮': '8',
        '੯': '9',
        '੦': '0'
    };

    var pa_in = moment__default.defineLocale('pa-in', {
        // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
        months : 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
        monthsShort : 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
        weekdays : 'ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ'.split('_'),
        weekdaysShort : 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
        weekdaysMin : 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ਵਜੇ',
            LTS : 'A h:mm:ss ਵਜੇ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ਵਜੇ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm ਵਜੇ'
        },
        calendar : {
            sameDay : '[ਅਜ] LT',
            nextDay : '[ਕਲ] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[ਕਲ] LT',
            lastWeek : '[ਪਿਛਲੇ] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ਵਿੱਚ',
            past : '%s ਪਿਛਲੇ',
            s : 'ਕੁਝ ਸਕਿੰਟ',
            m : 'ਇਕ ਮਿੰਟ',
            mm : '%d ਮਿੰਟ',
            h : 'ਇੱਕ ਘੰਟਾ',
            hh : '%d ਘੰਟੇ',
            d : 'ਇੱਕ ਦਿਨ',
            dd : '%d ਦਿਨ',
            M : 'ਇੱਕ ਮਹੀਨਾ',
            MM : '%d ਮਹੀਨੇ',
            y : 'ਇੱਕ ਸਾਲ',
            yy : '%d ਸਾਲ'
        },
        preparse: function (string) {
            return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
                return pa_in__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return pa_in__symbolMap[match];
            });
        },
        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
        meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ਰਾਤ') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'ਸਵੇਰ') {
                return hour;
            } else if (meridiem === 'ਦੁਪਹਿਰ') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'ਸ਼ਾਮ') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ਰਾਤ';
            } else if (hour < 10) {
                return 'ਸਵੇਰ';
            } else if (hour < 17) {
                return 'ਦੁਪਹਿਰ';
            } else if (hour < 20) {
                return 'ਸ਼ਾਮ';
            } else {
                return 'ਰਾਤ';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_'),
        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');
    function pl__plural(n) {
        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
    }
    function pl__translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'm':
                return withoutSuffix ? 'minuta' : 'minutę';
            case 'mm':
                return result + (pl__plural(number) ? 'minuty' : 'minut');
            case 'h':
                return withoutSuffix  ? 'godzina'  : 'godzinę';
            case 'hh':
                return result + (pl__plural(number) ? 'godziny' : 'godzin');
            case 'MM':
                return result + (pl__plural(number) ? 'miesiące' : 'miesięcy');
            case 'yy':
                return result + (pl__plural(number) ? 'lata' : 'lat');
        }
    }

    var pl = moment__default.defineLocale('pl', {
        months : function (momentToFormat, format) {
            if (format === '') {
                // Hack: if format empty we know this is used to generate
                // RegExp by moment. Give then back both valid forms of months
                // in RegExp ready format.
                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
            } else if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
        weekdays : 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
        weekdaysShort : 'nie_pon_wt_śr_czw_pt_sb'.split('_'),
        weekdaysMin : 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Dziś o] LT',
            nextDay: '[Jutro o] LT',
            nextWeek: '[W] dddd [o] LT',
            lastDay: '[Wczoraj o] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[W zeszłą niedzielę o] LT';
                    case 3:
                        return '[W zeszłą środę o] LT';
                    case 6:
                        return '[W zeszłą sobotę o] LT';
                    default:
                        return '[W zeszły] dddd [o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : '%s temu',
            s : 'kilka sekund',
            m : pl__translate,
            mm : pl__translate,
            h : pl__translate,
            hh : pl__translate,
            d : '1 dzień',
            dd : '%d dni',
            M : 'miesiąc',
            MM : pl__translate,
            y : 'rok',
            yy : pl__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var pt_br = moment__default.defineLocale('pt-br', {
        months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
        weekdaysMin : 'Dom_2ª_3ª_4ª_5ª_6ª_Sáb'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY [às] HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY [às] HH:mm'
        },
        calendar : {
            sameDay: '[Hoje às] LT',
            nextDay: '[Amanhã às] LT',
            nextWeek: 'dddd [às] LT',
            lastDay: '[Ontem às] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[Último] dddd [às] LT' : // Saturday + Sunday
                    '[Última] dddd [às] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : '%s atrás',
            s : 'poucos segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um mês',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        ordinalParse: /\d{1,2}º/,
        ordinal : '%dº'
    });


    var pt = moment__default.defineLocale('pt', {
        months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-Feira_Terça-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sábado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
        weekdaysMin : 'Dom_2ª_3ª_4ª_5ª_6ª_Sáb'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hoje às] LT',
            nextDay: '[Amanhã às] LT',
            nextWeek: 'dddd [às] LT',
            lastDay: '[Ontem às] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[Último] dddd [às] LT' : // Saturday + Sunday
                    '[Última] dddd [às] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : 'há %s',
            s : 'segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um mês',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        ordinalParse: /\d{1,2}º/,
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    function ro__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
                'mm': 'minute',
                'hh': 'ore',
                'dd': 'zile',
                'MM': 'luni',
                'yy': 'ani'
            },
            separator = ' ';
        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
            separator = ' de ';
        }
        return number + separator + format[key];
    }

    var ro = moment__default.defineLocale('ro', {
        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[azi la] LT',
            nextDay: '[mâine la] LT',
            nextWeek: 'dddd [la] LT',
            lastDay: '[ieri la] LT',
            lastWeek: '[fosta] dddd [la] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'peste %s',
            past : '%s în urmă',
            s : 'câteva secunde',
            m : 'un minut',
            mm : ro__relativeTimeWithPlural,
            h : 'o oră',
            hh : ro__relativeTimeWithPlural,
            d : 'o zi',
            dd : ro__relativeTimeWithPlural,
            M : 'o lună',
            MM : ro__relativeTimeWithPlural,
            y : 'un an',
            yy : ro__relativeTimeWithPlural
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    function ru__plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function ru__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
            'hh': 'час_часа_часов',
            'dd': 'день_дня_дней',
            'MM': 'месяц_месяца_месяцев',
            'yy': 'год_года_лет'
        };
        if (key === 'm') {
            return withoutSuffix ? 'минута' : 'минуту';
        }
        else {
            return number + ' ' + ru__plural(format[key], +number);
        }
    }
    var monthsParse = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i];

    // http://new.gramota.ru/spravka/rules/139-prop : § 103
    // Сокращения месяцев: http://new.gramota.ru/spravka/buro/search-answer?s=242637
    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
    var ru = moment__default.defineLocale('ru', {
        months : {
            format: 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_'),
            standalone: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_')
        },
        monthsShort : {
            // по CLDR именно "июл." и "июн.", но какой смысл менять букву на точку ?
            format: 'янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.'.split('_'),
            standalone: 'янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.'.split('_')
        },
        weekdays : {
            standalone: 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
            format: 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split('_'),
            isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/
        },
        weekdaysShort : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
        weekdaysMin : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,

        // полные названия с падежами, по три буквы, для некоторых, по 4 буквы, сокращения с точкой и без точки
        monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

        // копия предыдущего
        monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

        // полные названия с падежами
        monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,

        // Выражение, которое соотвествует только сокращённым формам
        monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY г.',
            LLL : 'D MMMM YYYY г., HH:mm',
            LLLL : 'dddd, D MMMM YYYY г., HH:mm'
        },
        calendar : {
            sameDay: '[Сегодня в] LT',
            nextDay: '[Завтра в] LT',
            lastDay: '[Вчера в] LT',
            nextWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                        case 0:
                            return '[В следующее] dddd [в] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[В следующий] dddd [в] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[В следующую] dddd [в] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[Во] dddd [в] LT';
                    } else {
                        return '[В] dddd [в] LT';
                    }
                }
            },
            lastWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                        case 0:
                            return '[В прошлое] dddd [в] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[В прошлый] dddd [в] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[В прошлую] dddd [в] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[Во] dddd [в] LT';
                    } else {
                        return '[В] dddd [в] LT';
                    }
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'через %s',
            past : '%s назад',
            s : 'несколько секунд',
            m : ru__relativeTimeWithPlural,
            mm : ru__relativeTimeWithPlural,
            h : 'час',
            hh : ru__relativeTimeWithPlural,
            d : 'день',
            dd : ru__relativeTimeWithPlural,
            M : 'месяц',
            MM : ru__relativeTimeWithPlural,
            y : 'год',
            yy : ru__relativeTimeWithPlural
        },
        meridiemParse: /ночи|утра|дня|вечера/i,
        isPM : function (input) {
            return /^(дня|вечера)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночи';
            } else if (hour < 12) {
                return 'утра';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечера';
            }
        },
        ordinalParse: /\d{1,2}-(й|го|я)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                    return number + '-й';
                case 'D':
                    return number + '-го';
                case 'w':
                case 'W':
                    return number + '-я';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });



    var se = moment__default.defineLocale('se', {
        months : 'ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu'.split('_'),
        monthsShort : 'ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov'.split('_'),
        weekdays : 'sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat'.split('_'),
        weekdaysShort : 'sotn_vuos_maŋ_gask_duor_bear_láv'.split('_'),
        weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'MMMM D. [b.] YYYY',
            LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
            LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
        },
        calendar : {
            sameDay: '[otne ti] LT',
            nextDay: '[ihttin ti] LT',
            nextWeek: 'dddd [ti] LT',
            lastDay: '[ikte ti] LT',
            lastWeek: '[ovddit] dddd [ti] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s geažes',
            past : 'maŋit %s',
            s : 'moadde sekunddat',
            m : 'okta minuhta',
            mm : '%d minuhtat',
            h : 'okta diimmu',
            hh : '%d diimmut',
            d : 'okta beaivi',
            dd : '%d beaivvit',
            M : 'okta mánnu',
            MM : '%d mánut',
            y : 'okta jahki',
            yy : '%d jagit'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    /*jshint -W100*/
    var si = moment__default.defineLocale('si', {
        months : 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split('_'),
        monthsShort : 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split('_'),
        weekdays : 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split('_'),
        weekdaysShort : 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
        weekdaysMin : 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'a h:mm',
            LTS : 'a h:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYY MMMM D',
            LLL : 'YYYY MMMM D, a h:mm',
            LLLL : 'YYYY MMMM D [වැනි] dddd, a h:mm:ss'
        },
        calendar : {
            sameDay : '[අද] LT[ට]',
            nextDay : '[හෙට] LT[ට]',
            nextWeek : 'dddd LT[ට]',
            lastDay : '[ඊයේ] LT[ට]',
            lastWeek : '[පසුගිය] dddd LT[ට]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%sකින්',
            past : '%sකට පෙර',
            s : 'තත්පර කිහිපය',
            m : 'මිනිත්තුව',
            mm : 'මිනිත්තු %d',
            h : 'පැය',
            hh : 'පැය %d',
            d : 'දිනය',
            dd : 'දින %d',
            M : 'මාසය',
            MM : 'මාස %d',
            y : 'වසර',
            yy : 'වසර %d'
        },
        ordinalParse: /\d{1,2} වැනි/,
        ordinal : function (number) {
            return number + ' වැනි';
        },
        meridiemParse : /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
        isPM : function (input) {
            return input === 'ප.ව.' || input === 'පස් වරු';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'ප.ව.' : 'පස් වරු';
            } else {
                return isLower ? 'පෙ.ව.' : 'පෙර වරු';
            }
        }
    });


    var sk__months = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_'),
        sk__monthsShort = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');
    function sk__plural(n) {
        return (n > 1) && (n < 5);
    }
    function sk__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':  // a few seconds / in a few seconds / a few seconds ago
                return (withoutSuffix || isFuture) ? 'pár sekúnd' : 'pár sekundami';
            case 'm':  // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minúta' : (isFuture ? 'minútu' : 'minútou');
            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (sk__plural(number) ? 'minúty' : 'minút');
                } else {
                    return result + 'minútami';
                }
                break;
            case 'h':  // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
            case 'hh': // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (sk__plural(number) ? 'hodiny' : 'hodín');
                } else {
                    return result + 'hodinami';
                }
                break;
            case 'd':  // a day / in a day / a day ago
                return (withoutSuffix || isFuture) ? 'deň' : 'dňom';
            case 'dd': // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (sk__plural(number) ? 'dni' : 'dní');
                } else {
                    return result + 'dňami';
                }
                break;
            case 'M':  // a month / in a month / a month ago
                return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
            case 'MM': // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (sk__plural(number) ? 'mesiace' : 'mesiacov');
                } else {
                    return result + 'mesiacmi';
                }
                break;
            case 'y':  // a year / in a year / a year ago
                return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
            case 'yy': // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (sk__plural(number) ? 'roky' : 'rokov');
                } else {
                    return result + 'rokmi';
                }
                break;
        }
    }

    var sk = moment__default.defineLocale('sk', {
        months : sk__months,
        monthsShort : sk__monthsShort,
        weekdays : 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
        weekdaysShort : 'ne_po_ut_st_št_pi_so'.split('_'),
        weekdaysMin : 'ne_po_ut_st_št_pi_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[dnes o] LT',
            nextDay: '[zajtra o] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v nedeľu o] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [o] LT';
                    case 3:
                        return '[v stredu o] LT';
                    case 4:
                        return '[vo štvrtok o] LT';
                    case 5:
                        return '[v piatok o] LT';
                    case 6:
                        return '[v sobotu o] LT';
                }
            },
            lastDay: '[včera o] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[minulú nedeľu o] LT';
                    case 1:
                    case 2:
                        return '[minulý] dddd [o] LT';
                    case 3:
                        return '[minulú stredu o] LT';
                    case 4:
                    case 5:
                        return '[minulý] dddd [o] LT';
                    case 6:
                        return '[minulú sobotu o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'pred %s',
            s : sk__translate,
            m : sk__translate,
            mm : sk__translate,
            h : sk__translate,
            hh : sk__translate,
            d : sk__translate,
            dd : sk__translate,
            M : sk__translate,
            MM : sk__translate,
            y : sk__translate,
            yy : sk__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    function sl__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
            case 'm':
                return withoutSuffix ? 'ena minuta' : 'eno minuto';
            case 'mm':
                if (number === 1) {
                    result += withoutSuffix ? 'minuta' : 'minuto';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'minute' : 'minutami';
                } else {
                    result += withoutSuffix || isFuture ? 'minut' : 'minutami';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'ena ura' : 'eno uro';
            case 'hh':
                if (number === 1) {
                    result += withoutSuffix ? 'ura' : 'uro';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'uri' : 'urama';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'ure' : 'urami';
                } else {
                    result += withoutSuffix || isFuture ? 'ur' : 'urami';
                }
                return result;
            case 'd':
                return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
            case 'dd':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'dan' : 'dnem';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
                } else {
                    result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
                }
                return result;
            case 'M':
                return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
            case 'MM':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
                } else {
                    result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
                }
                return result;
            case 'y':
                return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
            case 'yy':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'leto' : 'letom';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'leti' : 'letoma';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'leta' : 'leti';
                } else {
                    result += withoutSuffix || isFuture ? 'let' : 'leti';
                }
                return result;
        }
    }

    var sl = moment__default.defineLocale('sl', {
        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
        weekdaysShort : 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
        weekdaysMin : 'ne_po_to_sr_če_pe_so'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danes ob] LT',
            nextDay  : '[jutri ob] LT',

            nextWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[v] [nedeljo] [ob] LT';
                    case 3:
                        return '[v] [sredo] [ob] LT';
                    case 6:
                        return '[v] [soboto] [ob] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[v] dddd [ob] LT';
                }
            },
            lastDay  : '[včeraj ob] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[prejšnjo] [nedeljo] [ob] LT';
                    case 3:
                        return '[prejšnjo] [sredo] [ob] LT';
                    case 6:
                        return '[prejšnjo] [soboto] [ob] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prejšnji] dddd [ob] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'čez %s',
            past   : 'pred %s',
            s      : sl__processRelativeTime,
            m      : sl__processRelativeTime,
            mm     : sl__processRelativeTime,
            h      : sl__processRelativeTime,
            hh     : sl__processRelativeTime,
            d      : sl__processRelativeTime,
            dd     : sl__processRelativeTime,
            M      : sl__processRelativeTime,
            MM     : sl__processRelativeTime,
            y      : sl__processRelativeTime,
            yy     : sl__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var sq = moment__default.defineLocale('sq', {
        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split('_'),
        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
        weekdays : 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split('_'),
        weekdaysShort : 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
        weekdaysMin : 'D_H_Ma_Më_E_P_Sh'.split('_'),
        weekdaysParseExact : true,
        meridiemParse: /PD|MD/,
        isPM: function (input) {
            return input.charAt(0) === 'M';
        },
        meridiem : function (hours, minutes, isLower) {
            return hours < 12 ? 'PD' : 'MD';
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Sot në] LT',
            nextDay : '[Nesër në] LT',
            nextWeek : 'dddd [në] LT',
            lastDay : '[Dje në] LT',
            lastWeek : 'dddd [e kaluar në] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'në %s',
            past : '%s më parë',
            s : 'disa sekonda',
            m : 'një minutë',
            mm : '%d minuta',
            h : 'një orë',
            hh : '%d orë',
            d : 'një ditë',
            dd : '%d ditë',
            M : 'një muaj',
            MM : '%d muaj',
            y : 'një vit',
            yy : '%d vite'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var sr_cyrl__translator = {
        words: { //Different grammatical cases
            m: ['један минут', 'једне минуте'],
            mm: ['минут', 'минуте', 'минута'],
            h: ['један сат', 'једног сата'],
            hh: ['сат', 'сата', 'сати'],
            dd: ['дан', 'дана', 'дана'],
            MM: ['месец', 'месеца', 'месеци'],
            yy: ['година', 'године', 'година']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = sr_cyrl__translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + sr_cyrl__translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr_cyrl = moment__default.defineLocale('sr-cyrl', {
        months: 'јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар'.split('_'),
        monthsShort: 'јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.'.split('_'),
        monthsParseExact: true,
        weekdays: 'недеља_понедељак_уторак_среда_четвртак_петак_субота'.split('_'),
        weekdaysShort: 'нед._пон._уто._сре._чет._пет._суб.'.split('_'),
        weekdaysMin: 'не_по_ут_ср_че_пе_су'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[данас у] LT',
            nextDay: '[сутра у] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[у] [недељу] [у] LT';
                    case 3:
                        return '[у] [среду] [у] LT';
                    case 6:
                        return '[у] [суботу] [у] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[у] dddd [у] LT';
                }
            },
            lastDay  : '[јуче у] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[прошле] [недеље] [у] LT',
                    '[прошлог] [понедељка] [у] LT',
                    '[прошлог] [уторка] [у] LT',
                    '[прошле] [среде] [у] LT',
                    '[прошлог] [четвртка] [у] LT',
                    '[прошлог] [петка] [у] LT',
                    '[прошле] [суботе] [у] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'за %s',
            past   : 'пре %s',
            s      : 'неколико секунди',
            m      : sr_cyrl__translator.translate,
            mm     : sr_cyrl__translator.translate,
            h      : sr_cyrl__translator.translate,
            hh     : sr_cyrl__translator.translate,
            d      : 'дан',
            dd     : sr_cyrl__translator.translate,
            M      : 'месец',
            MM     : sr_cyrl__translator.translate,
            y      : 'годину',
            yy     : sr_cyrl__translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var sr__translator = {
        words: { //Different grammatical cases
            m: ['jedan minut', 'jedne minute'],
            mm: ['minut', 'minute', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mesec', 'meseca', 'meseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = sr__translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + sr__translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr = moment__default.defineLocale('sr', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sre._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedelju] [u] LT';
                    case 3:
                        return '[u] [sredu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juče u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prošle] [nedelje] [u] LT',
                    '[prošlog] [ponedeljka] [u] LT',
                    '[prošlog] [utorka] [u] LT',
                    '[prošle] [srede] [u] LT',
                    '[prošlog] [četvrtka] [u] LT',
                    '[prošlog] [petka] [u] LT',
                    '[prošle] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'pre %s',
            s      : 'nekoliko sekundi',
            m      : sr__translator.translate,
            mm     : sr__translator.translate,
            h      : sr__translator.translate,
            hh     : sr__translator.translate,
            d      : 'dan',
            dd     : sr__translator.translate,
            M      : 'mesec',
            MM     : sr__translator.translate,
            y      : 'godinu',
            yy     : sr__translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });



    var ss = moment__default.defineLocale('ss', {
        months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
        monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
        weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
        weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
        weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Namuhla nga] LT',
            nextDay : '[Kusasa nga] LT',
            nextWeek : 'dddd [nga] LT',
            lastDay : '[Itolo nga] LT',
            lastWeek : 'dddd [leliphelile] [nga] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'nga %s',
            past : 'wenteka nga %s',
            s : 'emizuzwana lomcane',
            m : 'umzuzu',
            mm : '%d emizuzu',
            h : 'lihora',
            hh : '%d emahora',
            d : 'lilanga',
            dd : '%d emalanga',
            M : 'inyanga',
            MM : '%d tinyanga',
            y : 'umnyaka',
            yy : '%d iminyaka'
        },
        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'ekuseni';
            } else if (hours < 15) {
                return 'emini';
            } else if (hours < 19) {
                return 'entsambama';
            } else {
                return 'ebusuku';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ekuseni') {
                return hour;
            } else if (meridiem === 'emini') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
                if (hour === 0) {
                    return 0;
                }
                return hour + 12;
            }
        },
        ordinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var sv = moment__default.defineLocale('sv', {
        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
        weekdaysShort : 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
        weekdaysMin : 'sö_må_ti_on_to_fr_lö'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [kl.] HH:mm',
            LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Idag] LT',
            nextDay: '[Imorgon] LT',
            lastDay: '[Igår] LT',
            nextWeek: '[På] dddd LT',
            lastWeek: '[I] dddd[s] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'för %s sedan',
            s : 'några sekunder',
            m : 'en minut',
            mm : '%d minuter',
            h : 'en timme',
            hh : '%d timmar',
            d : 'en dag',
            dd : '%d dagar',
            M : 'en månad',
            MM : '%d månader',
            y : 'ett år',
            yy : '%d år'
        },
        ordinalParse: /\d{1,2}(e|a)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'e' :
                (b === 1) ? 'a' :
                (b === 2) ? 'a' :
                (b === 3) ? 'e' : 'e';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var sw = moment__default.defineLocale('sw', {
        months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
        weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
        weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[leo saa] LT',
            nextDay : '[kesho saa] LT',
            nextWeek : '[wiki ijayo] dddd [saat] LT',
            lastDay : '[jana] LT',
            lastWeek : '[wiki iliyopita] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s baadaye',
            past : 'tokea %s',
            s : 'hivi punde',
            m : 'dakika moja',
            mm : 'dakika %d',
            h : 'saa limoja',
            hh : 'masaa %d',
            d : 'siku moja',
            dd : 'masiku %d',
            M : 'mwezi mmoja',
            MM : 'miezi %d',
            y : 'mwaka mmoja',
            yy : 'miaka %d'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var ta__symbolMap = {
        '1': '௧',
        '2': '௨',
        '3': '௩',
        '4': '௪',
        '5': '௫',
        '6': '௬',
        '7': '௭',
        '8': '௮',
        '9': '௯',
        '0': '௦'
    }, ta__numberMap = {
        '௧': '1',
        '௨': '2',
        '௩': '3',
        '௪': '4',
        '௫': '5',
        '௬': '6',
        '௭': '7',
        '௮': '8',
        '௯': '9',
        '௦': '0'
    };

    var ta = moment__default.defineLocale('ta', {
        months : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
        monthsShort : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
        weekdays : 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split('_'),
        weekdaysShort : 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split('_'),
        weekdaysMin : 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, HH:mm',
            LLLL : 'dddd, D MMMM YYYY, HH:mm'
        },
        calendar : {
            sameDay : '[இன்று] LT',
            nextDay : '[நாளை] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[நேற்று] LT',
            lastWeek : '[கடந்த வாரம்] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s இல்',
            past : '%s முன்',
            s : 'ஒரு சில விநாடிகள்',
            m : 'ஒரு நிமிடம்',
            mm : '%d நிமிடங்கள்',
            h : 'ஒரு மணி நேரம்',
            hh : '%d மணி நேரம்',
            d : 'ஒரு நாள்',
            dd : '%d நாட்கள்',
            M : 'ஒரு மாதம்',
            MM : '%d மாதங்கள்',
            y : 'ஒரு வருடம்',
            yy : '%d ஆண்டுகள்'
        },
        ordinalParse: /\d{1,2}வது/,
        ordinal : function (number) {
            return number + 'வது';
        },
        preparse: function (string) {
            return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
                return ta__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return ta__symbolMap[match];
            });
        },
        // refer http://ta.wikipedia.org/s/1er1
        meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
        meridiem : function (hour, minute, isLower) {
            if (hour < 2) {
                return ' யாமம்';
            } else if (hour < 6) {
                return ' வைகறை';  // வைகறை
            } else if (hour < 10) {
                return ' காலை'; // காலை
            } else if (hour < 14) {
                return ' நண்பகல்'; // நண்பகல்
            } else if (hour < 18) {
                return ' எற்பாடு'; // எற்பாடு
            } else if (hour < 22) {
                return ' மாலை'; // மாலை
            } else {
                return ' யாமம்';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'யாமம்') {
                return hour < 2 ? hour : hour + 12;
            } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
                return hour;
            } else if (meridiem === 'நண்பகல்') {
                return hour >= 10 ? hour : hour + 12;
            } else {
                return hour + 12;
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var te = moment__default.defineLocale('te', {
        months : 'జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జూలై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్'.split('_'),
        monthsShort : 'జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జూలై_ఆగ._సెప్._అక్టో._నవ._డిసె.'.split('_'),
        monthsParseExact : true,
        weekdays : 'ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం'.split('_'),
        weekdaysShort : 'ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని'.split('_'),
        weekdaysMin : 'ఆ_సో_మం_బు_గు_శు_శ'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[నేడు] LT',
            nextDay : '[రేపు] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[నిన్న] LT',
            lastWeek : '[గత] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s లో',
            past : '%s క్రితం',
            s : 'కొన్ని క్షణాలు',
            m : 'ఒక నిమిషం',
            mm : '%d నిమిషాలు',
            h : 'ఒక గంట',
            hh : '%d గంటలు',
            d : 'ఒక రోజు',
            dd : '%d రోజులు',
            M : 'ఒక నెల',
            MM : '%d నెలలు',
            y : 'ఒక సంవత్సరం',
            yy : '%d సంవత్సరాలు'
        },
        ordinalParse : /\d{1,2}వ/,
        ordinal : '%dవ',
        meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'రాత్రి') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'ఉదయం') {
                return hour;
            } else if (meridiem === 'మధ్యాహ్నం') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'సాయంత్రం') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'రాత్రి';
            } else if (hour < 10) {
                return 'ఉదయం';
            } else if (hour < 17) {
                return 'మధ్యాహ్నం';
            } else if (hour < 20) {
                return 'సాయంత్రం';
            } else {
                return 'రాత్రి';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var th = moment__default.defineLocale('th', {
        months : 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
        monthsShort : 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split('_'),
        monthsParseExact: true,
        weekdays : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
        weekdaysShort : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
        weekdaysMin : 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H นาฬิกา m นาที',
            LTS : 'H นาฬิกา m นาที s วินาที',
            L : 'YYYY/MM/DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY เวลา H นาฬิกา m นาที',
            LLLL : 'วันddddที่ D MMMM YYYY เวลา H นาฬิกา m นาที'
        },
        meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
        isPM: function (input) {
            return input === 'หลังเที่ยง';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ก่อนเที่ยง';
            } else {
                return 'หลังเที่ยง';
            }
        },
        calendar : {
            sameDay : '[วันนี้ เวลา] LT',
            nextDay : '[พรุ่งนี้ เวลา] LT',
            nextWeek : 'dddd[หน้า เวลา] LT',
            lastDay : '[เมื่อวานนี้ เวลา] LT',
            lastWeek : '[วัน]dddd[ที่แล้ว เวลา] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'อีก %s',
            past : '%sที่แล้ว',
            s : 'ไม่กี่วินาที',
            m : '1 นาที',
            mm : '%d นาที',
            h : '1 ชั่วโมง',
            hh : '%d ชั่วโมง',
            d : '1 วัน',
            dd : '%d วัน',
            M : '1 เดือน',
            MM : '%d เดือน',
            y : '1 ปี',
            yy : '%d ปี'
        }
    });


    var tl_ph = moment__default.defineLocale('tl-ph', {
        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'MM/D/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY HH:mm',
            LLLL : 'dddd, MMMM DD, YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Ngayon sa] LT',
            nextDay: '[Bukas sa] LT',
            nextWeek: 'dddd [sa] LT',
            lastDay: '[Kahapon sa] LT',
            lastWeek: 'dddd [huling linggo] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'sa loob ng %s',
            past : '%s ang nakalipas',
            s : 'ilang segundo',
            m : 'isang minuto',
            mm : '%d minuto',
            h : 'isang oras',
            hh : '%d oras',
            d : 'isang araw',
            dd : '%d araw',
            M : 'isang buwan',
            MM : '%d buwan',
            y : 'isang taon',
            yy : '%d taon'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var numbersNouns = 'pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

    function translateFuture(output) {
        var time = output;
        time = (output.indexOf('jaj') !== -1) ?
        time.slice(0, -3) + 'leS' :
        (output.indexOf('jar') !== -1) ?
        time.slice(0, -3) + 'waQ' :
        (output.indexOf('DIS') !== -1) ?
        time.slice(0, -3) + 'nem' :
        time + ' pIq';
        return time;
    }

    function translatePast(output) {
        var time = output;
        time = (output.indexOf('jaj') !== -1) ?
        time.slice(0, -3) + 'Hu’' :
        (output.indexOf('jar') !== -1) ?
        time.slice(0, -3) + 'wen' :
        (output.indexOf('DIS') !== -1) ?
        time.slice(0, -3) + 'ben' :
        time + ' ret';
        return time;
    }

    function tlh__translate(number, withoutSuffix, string, isFuture) {
        var numberNoun = numberAsNoun(number);
        switch (string) {
            case 'mm':
                return numberNoun + ' tup';
            case 'hh':
                return numberNoun + ' rep';
            case 'dd':
                return numberNoun + ' jaj';
            case 'MM':
                return numberNoun + ' jar';
            case 'yy':
                return numberNoun + ' DIS';
        }
    }

    function numberAsNoun(number) {
        var hundred = Math.floor((number % 1000) / 100),
        ten = Math.floor((number % 100) / 10),
        one = number % 10,
        word = '';
        if (hundred > 0) {
            word += numbersNouns[hundred] + 'vatlh';
        }
        if (ten > 0) {
            word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
        }
        if (one > 0) {
            word += ((word !== '') ? ' ' : '') + numbersNouns[one];
        }
        return (word === '') ? 'pagh' : word;
    }

    var tlh = moment__default.defineLocale('tlh', {
        months : 'tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’'.split('_'),
        monthsShort : 'jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’'.split('_'),
        monthsParseExact : true,
        weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[DaHjaj] LT',
            nextDay: '[wa’leS] LT',
            nextWeek: 'LLL',
            lastDay: '[wa’Hu’] LT',
            lastWeek: 'LLL',
            sameElse: 'L'
        },
        relativeTime : {
            future : translateFuture,
            past : translatePast,
            s : 'puS lup',
            m : 'wa’ tup',
            mm : tlh__translate,
            h : 'wa’ rep',
            hh : tlh__translate,
            d : 'wa’ jaj',
            dd : tlh__translate,
            M : 'wa’ jar',
            MM : tlh__translate,
            y : 'wa’ DIS',
            yy : tlh__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var tr__suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',
        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',
        3: '\'üncü',
        4: '\'üncü',
        100: '\'üncü',
        6: '\'ncı',
        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',
        60: '\'ıncı',
        90: '\'ıncı'
    };

    var tr = moment__default.defineLocale('tr', {
        months : 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
        monthsShort : 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
        weekdays : 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
        weekdaysShort : 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
        weekdaysMin : 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugün saat] LT',
            nextDay : '[yarın saat] LT',
            nextWeek : '[haftaya] dddd [saat] LT',
            lastDay : '[dün] LT',
            lastWeek : '[geçen hafta] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s önce',
            s : 'birkaç saniye',
            m : 'bir dakika',
            mm : '%d dakika',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gün',
            dd : '%d gün',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir yıl',
            yy : '%d yıl'
        },
        ordinalParse: /\d{1,2}'(inci|nci|üncü|ncı|uncu|ıncı)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '\'ıncı';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (tr__suffixes[a] || tr__suffixes[b] || tr__suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });



    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
    // This is currently too difficult (maybe even impossible) to add.
    var tzl = moment__default.defineLocale('tzl', {
        months : 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
        weekdays : 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
        weekdaysShort : 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
        weekdaysMin : 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM [dallas] YYYY',
            LLL : 'D. MMMM [dallas] YYYY HH.mm',
            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
        },
        meridiemParse: /d\'o|d\'a/i,
        isPM : function (input) {
            return 'd\'o' === input.toLowerCase();
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'd\'o' : 'D\'O';
            } else {
                return isLower ? 'd\'a' : 'D\'A';
            }
        },
        calendar : {
            sameDay : '[oxhi à] LT',
            nextDay : '[demà à] LT',
            nextWeek : 'dddd [à] LT',
            lastDay : '[ieiri à] LT',
            lastWeek : '[sür el] dddd [lasteu à] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'osprei %s',
            past : 'ja%s',
            s : tzl__processRelativeTime,
            m : tzl__processRelativeTime,
            mm : tzl__processRelativeTime,
            h : tzl__processRelativeTime,
            hh : tzl__processRelativeTime,
            d : tzl__processRelativeTime,
            dd : tzl__processRelativeTime,
            M : tzl__processRelativeTime,
            MM : tzl__processRelativeTime,
            y : tzl__processRelativeTime,
            yy : tzl__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    function tzl__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's': ['viensas secunds', '\'iensas secunds'],
            'm': ['\'n míut', '\'iens míut'],
            'mm': [number + ' míuts', '' + number + ' míuts'],
            'h': ['\'n þora', '\'iensa þora'],
            'hh': [number + ' þoras', '' + number + ' þoras'],
            'd': ['\'n ziua', '\'iensa ziua'],
            'dd': [number + ' ziuas', '' + number + ' ziuas'],
            'M': ['\'n mes', '\'iens mes'],
            'MM': [number + ' mesen', '' + number + ' mesen'],
            'y': ['\'n ar', '\'iens ar'],
            'yy': [number + ' ars', '' + number + ' ars']
        };
        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
    }


    var tzm_latn = moment__default.defineLocale('tzm-latn', {
        months : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
        monthsShort : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[asdkh g] LT',
            nextDay: '[aska g] LT',
            nextWeek: 'dddd [g] LT',
            lastDay: '[assant g] LT',
            lastWeek: 'dddd [g] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dadkh s yan %s',
            past : 'yan %s',
            s : 'imik',
            m : 'minuḍ',
            mm : '%d minuḍ',
            h : 'saɛa',
            hh : '%d tassaɛin',
            d : 'ass',
            dd : '%d ossan',
            M : 'ayowr',
            MM : '%d iyyirn',
            y : 'asgas',
            yy : '%d isgasn'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var tzm = moment__default.defineLocale('tzm', {
        months : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
        monthsShort : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
        weekdays : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        weekdaysShort : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        weekdaysMin : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
            nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
            nextWeek: 'dddd [ⴴ] LT',
            lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
            lastWeek: 'dddd [ⴴ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
            past : 'ⵢⴰⵏ %s',
            s : 'ⵉⵎⵉⴽ',
            m : 'ⵎⵉⵏⵓⴺ',
            mm : '%d ⵎⵉⵏⵓⴺ',
            h : 'ⵙⴰⵄⴰ',
            hh : '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
            d : 'ⴰⵙⵙ',
            dd : '%d oⵙⵙⴰⵏ',
            M : 'ⴰⵢoⵓⵔ',
            MM : '%d ⵉⵢⵢⵉⵔⵏ',
            y : 'ⴰⵙⴳⴰⵙ',
            yy : '%d ⵉⵙⴳⴰⵙⵏ'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });


    function uk__plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function uk__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
            'hh': withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
            'dd': 'день_дні_днів',
            'MM': 'місяць_місяці_місяців',
            'yy': 'рік_роки_років'
        };
        if (key === 'm') {
            return withoutSuffix ? 'хвилина' : 'хвилину';
        }
        else if (key === 'h') {
            return withoutSuffix ? 'година' : 'годину';
        }
        else {
            return number + ' ' + uk__plural(format[key], +number);
        }
    }
    function weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
            'accusative': 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split('_'),
            'genitive': 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split('_')
        },
        nounCase = (/(\[[ВвУу]\]) ?dddd/).test(format) ?
            'accusative' :
            ((/\[?(?:минулої|наступної)? ?\] ?dddd/).test(format) ?
                'genitive' :
                'nominative');
        return weekdays[nounCase][m.day()];
    }
    function processHoursFunction(str) {
        return function () {
            return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
        };
    }

    var uk = moment__default.defineLocale('uk', {
        months : {
            'format': 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_'),
            'standalone': 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_')
        },
        monthsShort : 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
        weekdays : weekdaysCaseReplace,
        weekdaysShort : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY р.',
            LLL : 'D MMMM YYYY р., HH:mm',
            LLLL : 'dddd, D MMMM YYYY р., HH:mm'
        },
        calendar : {
            sameDay: processHoursFunction('[Сьогодні '),
            nextDay: processHoursFunction('[Завтра '),
            lastDay: processHoursFunction('[Вчора '),
            nextWeek: processHoursFunction('[У] dddd ['),
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 5:
                    case 6:
                        return processHoursFunction('[Минулої] dddd [').call(this);
                    case 1:
                    case 2:
                    case 4:
                        return processHoursFunction('[Минулого] dddd [').call(this);
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'за %s',
            past : '%s тому',
            s : 'декілька секунд',
            m : uk__relativeTimeWithPlural,
            mm : uk__relativeTimeWithPlural,
            h : 'годину',
            hh : uk__relativeTimeWithPlural,
            d : 'день',
            dd : uk__relativeTimeWithPlural,
            M : 'місяць',
            MM : uk__relativeTimeWithPlural,
            y : 'рік',
            yy : uk__relativeTimeWithPlural
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /ночі|ранку|дня|вечора/,
        isPM: function (input) {
            return /^(дня|вечора)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночі';
            } else if (hour < 12) {
                return 'ранку';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечора';
            }
        },
        ordinalParse: /\d{1,2}-(й|го)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                case 'w':
                case 'W':
                    return number + '-й';
                case 'D':
                    return number + '-го';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });


    var uz = moment__default.defineLocale('uz', {
        months : 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split('_'),
        monthsShort : 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
        weekdays : 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
        weekdaysShort : 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
        weekdaysMin : 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'D MMMM YYYY, dddd HH:mm'
        },
        calendar : {
            sameDay : '[Бугун соат] LT [да]',
            nextDay : '[Эртага] LT [да]',
            nextWeek : 'dddd [куни соат] LT [да]',
            lastDay : '[Кеча соат] LT [да]',
            lastWeek : '[Утган] dddd [куни соат] LT [да]',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'Якин %s ичида',
            past : 'Бир неча %s олдин',
            s : 'фурсат',
            m : 'бир дакика',
            mm : '%d дакика',
            h : 'бир соат',
            hh : '%d соат',
            d : 'бир кун',
            dd : '%d кун',
            M : 'бир ой',
            MM : '%d ой',
            y : 'бир йил',
            yy : '%d йил'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var vi = moment__default.defineLocale('vi', {
        months : 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
        monthsParseExact : true,
        weekdays : 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysParseExact : true,
        meridiemParse: /sa|ch/i,
        isPM : function (input) {
            return /^ch$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'sa' : 'SA';
            } else {
                return isLower ? 'ch' : 'CH';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM [năm] YYYY',
            LLL : 'D MMMM [năm] YYYY HH:mm',
            LLLL : 'dddd, D MMMM [năm] YYYY HH:mm',
            l : 'DD/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hôm nay lúc] LT',
            nextDay: '[Ngày mai lúc] LT',
            nextWeek: 'dddd [tuần tới lúc] LT',
            lastDay: '[Hôm qua lúc] LT',
            lastWeek: 'dddd [tuần rồi lúc] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s tới',
            past : '%s trước',
            s : 'vài giây',
            m : 'một phút',
            mm : '%d phút',
            h : 'một giờ',
            hh : '%d giờ',
            d : 'một ngày',
            dd : '%d ngày',
            M : 'một tháng',
            MM : '%d tháng',
            y : 'một năm',
            yy : '%d năm'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var x_pseudo = moment__default.defineLocale('x-pseudo', {
        months : 'J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér'.split('_'),
        monthsShort : 'J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc'.split('_'),
        monthsParseExact : true,
        weekdays : 'S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý'.split('_'),
        weekdaysShort : 'S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát'.split('_'),
        weekdaysMin : 'S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[T~ódá~ý át] LT',
            nextDay : '[T~ómó~rró~w át] LT',
            nextWeek : 'dddd [át] LT',
            lastDay : '[Ý~ést~érdá~ý át] LT',
            lastWeek : '[L~ást] dddd [át] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'í~ñ %s',
            past : '%s á~gó',
            s : 'á ~féw ~sécó~ñds',
            m : 'á ~míñ~úté',
            mm : '%d m~íñú~tés',
            h : 'á~ñ hó~úr',
            hh : '%d h~óúrs',
            d : 'á ~dáý',
            dd : '%d d~áýs',
            M : 'á ~móñ~th',
            MM : '%d m~óñt~hs',
            y : 'á ~ýéár',
            yy : '%d ý~éárs'
        },
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var zh_cn = moment__default.defineLocale('zh-cn', {
        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort : '周日_周一_周二_周三_周四_周五_周六'.split('_'),
        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
        longDateFormat : {
            LT : 'Ah点mm分',
            LTS : 'Ah点m分s秒',
            L : 'YYYY-MM-DD',
            LL : 'YYYY年MMMD日',
            LLL : 'YYYY年MMMD日Ah点mm分',
            LLLL : 'YYYY年MMMD日ddddAh点mm分',
            l : 'YYYY-MM-DD',
            ll : 'YYYY年MMMD日',
            lll : 'YYYY年MMMD日Ah点mm分',
            llll : 'YYYY年MMMD日ddddAh点mm分'
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' ||
                    meridiem === '上午') {
                return hour;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            } else {
                // '中午'
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar : {
            sameDay : function () {
                return this.minutes() === 0 ? '[今天]Ah[点整]' : '[今天]LT';
            },
            nextDay : function () {
                return this.minutes() === 0 ? '[明天]Ah[点整]' : '[明天]LT';
            },
            lastDay : function () {
                return this.minutes() === 0 ? '[昨天]Ah[点整]' : '[昨天]LT';
            },
            nextWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = moment__default().startOf('week');
                prefix = this.diff(startOfWeek, 'days') >= 7 ? '[下]' : '[本]';
                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
            },
            lastWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = moment__default().startOf('week');
                prefix = this.unix() < startOfWeek.unix()  ? '[上]' : '[本]';
                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
            },
            sameElse : 'LL'
        },
        ordinalParse: /\d{1,2}(日|月|周)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                case 'M':
                    return number + '月';
                case 'w':
                case 'W':
                    return number + '周';
                default:
                    return number;
            }
        },
        relativeTime : {
            future : '%s内',
            past : '%s前',
            s : '几秒',
            m : '1 分钟',
            mm : '%d 分钟',
            h : '1 小时',
            hh : '%d 小时',
            d : '1 天',
            dd : '%d 天',
            M : '1 个月',
            MM : '%d 个月',
            y : '1 年',
            yy : '%d 年'
        },
        week : {
            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });


    var zh_tw = moment__default.defineLocale('zh-tw', {
        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
        longDateFormat : {
            LT : 'Ah點mm分',
            LTS : 'Ah點m分s秒',
            L : 'YYYY年MMMD日',
            LL : 'YYYY年MMMD日',
            LLL : 'YYYY年MMMD日Ah點mm分',
            LLLL : 'YYYY年MMMD日ddddAh點mm分',
            l : 'YYYY年MMMD日',
            ll : 'YYYY年MMMD日',
            lll : 'YYYY年MMMD日Ah點mm分',
            llll : 'YYYY年MMMD日ddddAh點mm分'
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                return hour;
            } else if (meridiem === '中午') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar : {
            sameDay : '[今天]LT',
            nextDay : '[明天]LT',
            nextWeek : '[下]ddddLT',
            lastDay : '[昨天]LT',
            lastWeek : '[上]ddddLT',
            sameElse : 'L'
        },
        ordinalParse: /\d{1,2}(日|月|週)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd' :
                case 'D' :
                case 'DDD' :
                    return number + '日';
                case 'M' :
                    return number + '月';
                case 'w' :
                case 'W' :
                    return number + '週';
                default :
                    return number;
            }
        },
        relativeTime : {
            future : '%s內',
            past : '%s前',
            s : '幾秒',
            m : '1 分鐘',
            mm : '%d 分鐘',
            h : '1 小時',
            hh : '%d 小時',
            d : '1 天',
            dd : '%d 天',
            M : '1 個月',
            MM : '%d 個月',
            y : '1 年',
            yy : '%d 年'
        }
    });

    var moment_with_locales = moment__default;
    moment_with_locales.locale('en');

    return moment_with_locales;

}));;
/*!
 * FullCalendar v3.0.1
 * Docs & License: http://fullcalendar.io/
 * (c) 2016 Adam Shaw
 */
(function(n){typeof define=="function"&&define.amd?define(["jquery","moment"],n):typeof exports=="object"?module.exports=n(require("jquery"),require("moment")):n(jQuery,moment)})(function(n,t){function nt(n){return ri(n,bi)}function ki(n,t){t.left&&n.css({"border-left-width":1,"margin-left":t.left-1});t.right&&n.css({"border-right-width":1,"margin-right":t.right-1})}function di(n){n.css({"margin-left":"","margin-right":"","border-left-width":"","border-right-width":""})}function ut(){n("body").addClass("fc-not-allowed")}function ft(){n("body").removeClass("fc-not-allowed")}function gi(t,i,r){var u=Math.floor(i/t.length),e=Math.floor(i-u*(t.length-1)),f=[],o=[],s=[],h=0;nr(t);t.each(function(i,r){var l=i===t.length-1?e:u,c=n(r).outerHeight(!0);c<l?(f.push(r),o.push(c),s.push(n(r).height())):h+=c});r&&(i-=h,u=Math.floor(i/f.length),e=Math.floor(i-u*(f.length-1)));n(f).each(function(t,i){var r=t===f.length-1?e:u,h=o[t],c=s[t],l=r-(h-c);h<r&&n(i).height(l)})}function nr(n){n.height("")}function tr(t){var i=0;return t.find("> *").each(function(t,r){var u=n(r).outerWidth();u>i&&(i=u)}),i++,t.width(i),i}function bt(n,t){var i=n.add(t),r;return i.css({position:"relative",left:-1}),r=n.outerHeight()-t.outerHeight(),i.css({position:"",left:""}),r}function kt(t){var r=t.css("position"),i=t.parents().filter(function(){var t=n(this);return/(auto|scroll)/.test(t.css("overflow")+t.css("overflow-y")+t.css("overflow-x"))}).eq(0);return r==="fixed"||!i.length?n(t[0].ownerDocument||document):i}function dt(n,t){var i=n.offset(),r=i.left-(t?t.left:0),u=i.top-(t?t.top:0);return{left:r,right:r+n.outerWidth(),top:u,bottom:u+n.outerHeight()}}function ir(n,t){var i=n.offset(),r=gt(n),u=i.left+g(n,"border-left-width")+r.left-(t?t.left:0),f=i.top+g(n,"border-top-width")+r.top-(t?t.top:0);return{left:u,right:u+n[0].clientWidth,top:f,bottom:f+n[0].clientHeight}}function du(n,t){var i=n.offset(),r=i.left+g(n,"border-left-width")+g(n,"padding-left")-(t?t.left:0),u=i.top+g(n,"border-top-width")+g(n,"padding-top")-(t?t.top:0);return{left:r,right:r+n.width(),top:u,bottom:u+n.height()}}function gt(n){var i=n.innerWidth()-n[0].clientWidth,t={left:0,right:0,top:0,bottom:n.innerHeight()-n[0].clientHeight};return gu()&&n.css("direction")=="rtl"?t.left=i:t.right=i,t}function gu(){return et===null&&(et=nf()),et}function nf(){var t=n("<div><div/><\/div>").css({position:"absolute",top:-1e3,left:0,border:0,padding:0,overflow:"scroll",direction:"rtl"}).appendTo("body"),i=t.children(),r=i.offset().left>t.offset().left;return t.remove(),r}function g(n,t){return parseFloat(n.css(t))||0}function rr(n){return n.which==1&&!n.ctrlKey}function l(n){if(n.pageX!==undefined)return n.pageX;var t=n.originalEvent.touches;if(t)return t[0].pageX}function a(n){if(n.pageY!==undefined)return n.pageY;var t=n.originalEvent.touches;if(t)return t[0].pageY}function ur(n){return/^touch/.test(n.type)}function tf(n){n.addClass("fc-unselectable").on("selectstart",ot)}function ot(n){n.preventDefault()}function rf(n){return window.addEventListener?(window.addEventListener("scroll",n,!0),!0):!1}function uf(n){return window.removeEventListener?(window.removeEventListener("scroll",n,!0),!0):!1}function fr(n,t){var i={left:Math.max(n.left,t.left),right:Math.min(n.right,t.right),top:Math.max(n.top,t.top),bottom:Math.min(n.bottom,t.bottom)};return i.left<i.right&&i.top<i.bottom?i:!1}function ff(n,t){return{left:Math.min(Math.max(n.left,t.left),t.right),top:Math.min(Math.max(n.top,t.top),t.bottom)}}function ef(n){return{left:(n.left+n.right)/2,top:(n.top+n.bottom)/2}}function of(n,t){return{left:n.left-t.left,top:n.top-t.top}}function er(t){var f=[],r=[],u,i;for(typeof t=="string"?r=t.split(/\s*,\s*/):typeof t=="function"?r=[t]:n.isArray(t)&&(r=t),u=0;u<r.length;u++)i=r[u],typeof i=="string"?f.push(i.charAt(0)=="-"?{field:i.substring(1),order:-1}:{field:i,order:1}):typeof i=="function"&&f.push({func:i});return f}function or(n,t,i){for(var u,r=0;r<i.length;r++)if(u=sr(n,t,i[r]),u)return u;return 0}function sr(n,t,i){return i.func?i.func(n,t):hr(n[i.field],t[i.field])*(i.order||1)}function hr(t,i){return!t&&!i?0:i==null?-1:t==null?1:n.type(t)==="string"||n.type(i)==="string"?String(t).localeCompare(String(i)):t-i}function st(n,t){var i=n.start,r=n.end,u=t.start,f=t.end,e,o,s,h;if(r>u&&i<f)return i>=u?(e=i.clone(),s=!0):(e=u.clone(),s=!1),r<=f?(o=r.clone(),h=!0):(o=f.clone(),h=!1),{start:e,end:o,isStart:s,isEnd:h}}function cr(n,i){return t.duration({days:n.clone().stripTime().diff(i.clone().stripTime(),"days"),ms:n.time()-i.time()})}function sf(n,i){return t.duration({days:n.clone().stripTime().diff(i.clone().stripTime(),"days")})}function lr(n,i,r){return t.duration(Math.round(n.diff(i,r,!0)),r)}function ti(n,t){for(var r,u,i=0;i<ht.length;i++)if(r=ht[i],u=hf(r,n,t),u>=1&&y(u))break;return r}function hf(n,i,r){return r!=null?r.diff(i,n,!0):t.isDuration(i)?i.as(n):i.end.diff(i.start,n,!0)}function cf(n,t,i){var r;return k(i)?(t-n)/i:(r=i.asMonths(),Math.abs(r)>=1&&y(r))?t.diff(n,"months",!0)/r:t.diff(n,"days",!0)/i.asDays()}function ii(n,t){var i,r;return k(n)||k(t)?n/t:(i=n.asMonths(),r=t.asMonths(),Math.abs(i)>=1&&y(i)&&Math.abs(r)>=1&&y(r))?i/r:n.asDays()/t.asDays()}function lf(n,i){var r;return k(n)?t.duration(n*i):(r=n.asMonths(),Math.abs(r)>=1&&y(r))?t.duration({months:r*i}):t.duration({days:n.asDays()*i})}function k(n){return Boolean(n.hours()||n.minutes()||n.seconds()||n.milliseconds())}function af(n){return Object.prototype.toString.call(n)==="[object Date]"||n instanceof Date}function ar(n){return/^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(n)}function ri(n,t){var u={},i,r,e,o,f,s;if(t)for(i=0;i<t.length;i++){for(r=t[i],e=[],o=n.length-1;o>=0;o--)if(f=n[o][r],typeof f=="object")e.unshift(f);else if(f!==undefined){u[r]=f;break}e.length&&(u[r]=ri(e))}for(i=n.length-1;i>=0;i--){s=n[i];for(r in s)r in u||(u[r]=s[r])}return u}function ct(n){var t=function(){};return t.prototype=n,new t}function ui(n,t){for(var i in n)yr(n,i)&&(t[i]=n[i])}function yr(n,t){return vr.call(n,t)}function vf(t){return/undefined|null|boolean|number|string/.test(n.type(t))}function lt(t,i,r){if(n.isFunction(t)&&(t=[t]),t){for(var f,u=0;u<t.length;u++)f=t[u].apply(i,r)||f;return f}}function f(){for(var n=0;n<arguments.length;n++)if(arguments[n]!==undefined)return arguments[n]}function r(n){return(n+"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/'/g,"&#039;").replace(/"/g,"&quot;").replace(/\n/g,"<br />")}function fi(n){return n.replace(/&.*?;/g,"")}function at(t){var i=[];return n.each(t,function(n,t){t!=null&&i.push(n+":"+t)}),i.join(";")}function yf(t){var i=[];return n.each(t,function(n,t){t!=null&&i.push(n+'="'+r(t)+'"')}),i.join(" ")}function pr(n){return n.charAt(0).toUpperCase()+n.slice(1)}function pf(n,t){return n-t}function y(n){return n%1==0}function d(n,t){var i=n[t];return function(){return i.apply(n,arguments)}}function vt(n,t,i){var r,u,f,o,e,s=function(){var h=+new Date-o;h<t?r=setTimeout(s,t-h):(r=null,i||(e=n.apply(f,u),f=u=null))};return function(){f=this;u=arguments;o=+new Date;var h=i&&!r;return r||(r=setTimeout(s,t)),h&&(e=n.apply(f,u),f=u=null),e}}function ei(t,i){if(t&&t.then&&t.state()!=="resolved"){if(i)return t.then(i)}else return n.when(i())}function si(i,r,u){var f=i[0],h=i.length==1&&typeof f=="string",o,s,c,e;return t.isMoment(f)||af(f)||f===undefined?e=t.apply(null,i):(o=!1,s=!1,h?wf.test(f)?(f+="-01",i=[f],o=!0,s=!0):(c=bf.exec(f))&&(o=!c[5],s=!0):n.isArray(f)&&(s=!0),e=r||o?t.utc.apply(t,i):t.apply(null,i),o?(e._ambigTime=!0,e._ambigZone=!0):u&&(s?e._ambigZone=!0:h&&e.utcOffset(f))),e._fullCalendar=!0,e}function p(n,t){return v.format.call(n,t)}function kf(n,t){return wr(n,li(t))}function wr(n,t){for(var r="",i=0;i<t.length;i++)r+=ci(n,t[i]);return r}function ci(n,t){var i,r;return typeof t=="string"?t:(i=t.token)?hi[i]?hi[i](n):p(n,i):t.maybe&&(r=wr(n,t.maybe),r.match(/[1-9]/))?r:""}function br(n,t,r,u,f){var e;return n=i.moment.parseZone(n),t=i.moment.parseZone(t),e=n.localeData(),r=e.longDateFormat(r)||r,u=u||" - ",df(n,t,li(r),u,f)}function df(n,t,i,r,u){for(var a=n.clone().stripZone(),v=t.clone().stripZone(),f,y="",o,l="",s,h="",c="",p="",e=0;e<i.length;e++){if(f=dr(n,t,a,v,i[e]),f===!1)break;y+=f}for(o=i.length-1;o>e;o--){if(f=dr(n,t,a,v,i[o]),f===!1)break;l=f+l}for(s=e;s<=o;s++)h+=ci(n,i[s]),c+=ci(t,i[s]);return(h||c)&&(p=u?c+r+h:h+r+c),y+p+l}function dr(n,t,i,r,u){var f,e;return typeof u=="string"?u:(f=u.token)&&(e=kr[f.charAt(0)],e&&i.isSame(r,e))?p(n,f):!1}function li(n){return n in yt?yt[n]:yt[n]=gr(n)}function gr(n){for(var i=[],r=/\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g,t;t=r.exec(n);)t[1]?i.push(t[1]):t[2]?i.push({maybe:gr(t[2])}):t[3]?i.push({token:t[3]}):t[5]&&i.push(t[5]);return i}function s(){}function gf(n,t){var i;return yr(t,"constructor")&&(i=t.constructor),typeof i!="function"&&(i=t.constructor=function(){n.apply(this,arguments)}),i.prototype=ct(n.prototype),ui(t,i.prototype),ui(n,i),i}function tu(n,t){ui(t,n.prototype)}function uu(n,t){return!n&&!t?!0:n&&t?n.component===t.component&&fu(n,t)&&fu(t,n):!1}function fu(n,t){for(var i in n)if(!/^(component|left|right|top|bottom)$/.test(i)&&n[i]!==t[i])return!1;return!0}function ou(n){return{start:n.start.clone(),end:n.end?n.end.clone():null,allDay:n.allDay}}function su(n){var t=hu(n);return t==="background"||t==="inverse-background"}function te(n){return hu(n)==="inverse-background"}function hu(n){return f((n.source||{}).rendering,n.rendering)}function ie(n){for(var r={},i,t=0;t<n.length;t++)i=n[t],(r[i._id]||(r[i._id]=[])).push(i);return r}function re(n,t){return n.start-t.start}function ue(r){var e=i.dataAttrPrefix,u,f,o,s;return e&&(e+="-"),u=r.data(e+"event")||null,u&&(u=typeof u=="object"?n.extend({},u):{},f=u.start,f==null&&(f=u.time),o=u.duration,s=u.stick,delete u.start,delete u.time,delete u.duration,delete u.stick),f==null&&(f=r.data(e+"start")),f==null&&(f=r.data(e+"time")),o==null&&(o=r.data(e+"duration")),s==null&&(s=r.data(e+"stick")),f=f!=null?t.duration(f):null,o=o!=null?t.duration(o):null,s=Boolean(s),{eventProps:u,startTime:f,duration:o,stick:s}}function fe(n,t){for(var r,i=0;i<t.length;i++)if(r=t[i],r.leftCol<=n.rightCol&&r.rightCol>=n.leftCol)return!0;return!1}function ee(n,t){return n.leftCol-t.leftCol}function oe(n){for(var i=[],u,t,r=0;r<n.length;r++){for(u=n[r],t=0;t<i.length;t++)if(!lu(u,i[t]).length)break;u.level=t;(i[t]||(i[t]=[])).push(u)}return i}function se(n){for(var f,i,r,u,t=0;t<n.length;t++)for(f=n[t],i=0;i<f.length;i++)for(r=f[i],r.forwardSegs=[],u=t+1;u<n.length;u++)lu(r,n[u],r.forwardSegs)}function cu(n){var u=n.forwardSegs,i=0,t,r;if(n.forwardPressure===undefined){for(t=0;t<u.length;t++)r=u[t],cu(r),i=Math.max(i,1+r.forwardPressure);n.forwardPressure=i}}function lu(n,t,i){i=i||[];for(var r=0;r<t.length;r++)he(n,t[r])&&i.push(t[r]);return i}function he(n,t){return n.bottom>t.top&&n.top<t.bottom}function ce(r,u){function d(n){n._locale=c}function kt(){l?y()&&(et(),h()):dt()}function dt(){r.addClass("fc");r.on("click.fc","a[data-goto]",function(t){var s=n(this),u=s.data("goto"),o=f.moment(u.date),r=u.type,i=e.opt("navLink"+pr(r)+"Click");typeof i=="function"?i(o,t):(typeof i=="string"&&(r=i),lt(o,r))});f.bindOption("theme",function(n){bt=n?"ui":"fc";r.toggleClass("ui-widget",n);r.toggleClass("fc-unthemed",!n)});f.bindOptions(["isRTL","locale"],function(n){r.toggleClass("fc-ltr",!n);r.toggleClass("fc-rtl",n)});l=n("<div class='fc-view-container'/>").prependTo(r);s=f.header=new ye(f);rt();h(f.options.defaultView);f.options.handleWindowResize&&(w=vt(ti,f.options.windowResizeDelay),n(window).resize(w))}function rt(){s.render();s.el&&r.prepend(s.el)}function gt(){e&&e.removeElement();s.removeElement();l.remove();r.removeClass("fc fc-ltr fc-rtl fc-unthemed ui-widget");r.off(".fc");w&&n(window).unbind("resize",w)}function y(){return r.is(":visible")}function h(t,i){v++;e&&t&&e.type!==t&&(k(),ut());!e&&t&&(e=f.view=g[t]||(g[t]=f.instantiateView(t)),e.setElement(n("<div class='fc-view fc-"+t+"-view' />").appendTo(l)),s.activateButton(t));e&&(o=e.massageCurrentDate(o),e.displaying&&o>=e.intervalStart&&o<e.intervalEnd||y()&&(e.display(o,i),p(),ei(),oi(),ri()));p();v--}function ut(){s.deactivateButton(e.type);e.removeElement();e=f.view=null}function ni(){v++;k();var n=e.type,t=e.queryScroll();ut();h(n,t);p();v--}function ft(n){if(y())return n&&ot(),v++,e.updateSize(!0),v--,!0}function et(){y()&&ot()}function ot(){var t=f.options.contentHeight,n=f.options.height;a=typeof t=="number"?t:typeof t=="function"?t():typeof n=="number"?n-nt():typeof n=="function"?n()-nt():n==="parent"?r.parent().height()-nt():Math.round(l.width()/Math.max(f.options.aspectRatio,.5))}function nt(){return s.el?s.el.outerHeight(!0):0}function ti(n){!v&&n.target===window&&e.start&&ft(!0)&&e.trigger("windowResize",tt)}function st(){ht()}function ii(n){wt(f.getEventSourcesByMatchArray(n))}function b(){y()&&(k(),e.displayEvents(it),p())}function ri(){!f.options.lazyFetching||yt(e.start,e.end)?ht():b()}function ht(){pt(e.start,e.end)}function ui(n){it=n;b()}function fi(){b()}function ei(){s.updateTitle(e.title)}function oi(){var n=f.getNow();n>=e.intervalStart&&n<e.intervalEnd?s.disableButton("today"):s.enableButton("today")}function si(){e.select(f.buildSelectSpan.apply(f,arguments))}function hi(){e&&e.unselect()}function ci(){o=e.computePrevDate(o);h()}function li(){o=e.computeNextDate(o);h()}function ai(){o.add(-1,"years");h()}function vi(){o.add(1,"years");h()}function yi(){o=f.getNow();h()}function pi(n){o=f.moment(n).stripZone();h()}function wi(n){o.add(t.duration(n));h()}function lt(n,t){var i;t=t||"day";i=f.getViewSpec(t)||f.getUnitViewSpec(t);o=n.clone();h(i?i.type:null)}function bi(){return f.applyTimezone(o)}function k(){l.css({width:"100%",height:l.height(),overflow:"hidden"})}function p(){l.css({width:"",height:"",overflow:""})}function ki(){return f}function di(){return e}function gi(n,t){var i;if(typeof n=="string"){if(t===undefined)return f.options[n];i={};i[n]=t;at(i)}else typeof n=="object"&&at(n)}function at(n){var i=0;for(var t in n)f.dynamicOverrides[t]=n[t];f.viewSpecCache={};f.populateOptionsHash();for(t in n)f.triggerOptionHandlers(t),i++;if(i===1){if(t==="height"||t==="contentHeight"||t==="aspectRatio"){ft(!0);return}if(t==="defaultDate")return;if(t==="businessHours"){e&&(e.unrenderBusinessHours(),e.renderBusinessHours());return}if(t==="timezone"){f.rezoneArrayEventSources();st();return}}rt();g={};ni()}function nr(n,t){var i=Array.prototype.slice.call(arguments,2);return t=t||tt,this.triggerWith(n,t,i),f.options[n]?f.options[n].apply(t,i):void 0}var f=this,c;f.render=kt;f.destroy=gt;f.refetchEvents=st;f.refetchEventSources=ii;f.reportEvents=ui;f.reportEventChange=fi;f.rerenderEvents=b;f.changeView=h;f.select=si;f.unselect=hi;f.prev=ci;f.next=li;f.prevYear=ai;f.nextYear=vi;f.today=yi;f.gotoDate=pi;f.incrementDate=wi;f.zoomTo=lt;f.getDate=bi;f.getCalendar=ki;f.getView=di;f.option=gi;f.trigger=nr;f.dynamicOverrides={};f.viewSpecCache={};f.optionHandlers={};f.overrides=n.extend({},u);f.populateOptionsHash();f.bindOptions(["locale","monthNames","monthNamesShort","dayNames","dayNamesShort","firstDay","weekNumberCalculation"],function(n,t,i,r,u,f,e){if(e==="iso"&&(e="ISO"),c=ct(vu(n)),t&&(c._months=t),i&&(c._monthsShort=i),r&&(c._weekdays=r),u&&(c._weekdaysShort=u),f==null&&e==="ISO"&&(f=1),f!=null){var s=ct(c._week);s.dow=f;c._week=s}(e==="ISO"||e==="local"||typeof e=="function")&&(c._fullCalendar_weekCalc=e);o&&d(o)});f.defaultAllDayEventDuration=t.duration(f.options.defaultAllDayEventDuration);f.defaultTimedEventDuration=t.duration(f.options.defaultTimedEventDuration);f.moment=function(){var n;return f.options.timezone==="local"?(n=i.moment.apply(null,arguments),n.hasTime()&&n.local()):n=f.options.timezone==="UTC"?i.moment.utc.apply(null,arguments):i.moment.parseZone.apply(null,arguments),d(n),n};f.localizeMoment=d;f.getIsAmbigTimezone=function(){return f.options.timezone!=="local"&&f.options.timezone!=="UTC"};f.applyTimezone=function(n){if(!n.hasTime())return n.clone();var t=f.moment(n.toArray()),r=n.time()-t.time(),i;return r&&(i=t.clone().add(r),n.time()-i.time()==0&&(t=i)),t};f.getNow=function(){var n=f.options.now;return typeof n=="function"&&(n=n()),f.moment(n).stripZone()};f.getEventEnd=function(n){return n.end?n.end.clone():f.getDefaultEventEnd(n.allDay,n.start)};f.getDefaultEventEnd=function(n,t){var i=t.clone();return n?i.stripTime().add(f.defaultAllDayEventDuration):i.add(f.defaultTimedEventDuration),f.getIsAmbigTimezone()&&i.stripZone(),i};f.humanizeDuration=function(n){return n.locale(f.options.locale).humanize()};pe.call(f);var yt=f.isFetchNeeded,pt=f.fetchEvents,wt=f.fetchEventSources,tt=r[0],s,l,bt,e,g={},a,w,v=0,it=[],o;o=f.options.defaultDate!=null?f.moment(f.options.defaultDate).stripZone():f.getNow();f.getSuggestedViewHeight=function(){return a===undefined&&et(),a};f.isHeightAuto=function(){return f.options.contentHeight==="auto"||f.options.height==="auto"};f.freezeContentHeight=k;f.unfreezeContentHeight=p;f.initialize()}function au(t){n.each(ve,function(n,i){t[n]==null&&(t[n]=i(t))})}function vu(n){return t.localeData(n)||t.localeData("en")}function ye(t){function h(){var r=t.options,f=r.header;i=r.theme?"ui":"fc";f?(u?u.empty():u=this.el=n("<div class='fc-toolbar'/>"),u.append(o("left")).append(o("right")).append(o("center")).append('<div class="fc-clear"/>')):s()}function s(){u&&(u.remove(),u=f.el=null)}function o(u){var o=n('<div class="fc-'+u+'"/>'),f=t.options,s=f.header[u];return s&&n.each(s.split(" "),function(){var u=n(),h=!0,s;n.each(this.split(","),function(o,s){var l,p,a,v,y,w,b,k,d,c;s=="title"?(u=u.add(n("<h2>&nbsp;<\/h2>")),h=!1):((l=(f.customButtons||{})[s])?(a=function(n){l.click&&l.click.call(c[0],n)},v="",y=l.text):(p=t.getViewSpec(s))?(a=function(){t.changeView(s)},e.push(s),v=p.buttonTextOverride,y=p.buttonTextDefault):t[s]&&(a=function(){t[s]()},v=(t.overrides.buttonText||{})[s],y=f.buttonText[s]),a&&(w=l?l.themeIcon:f.themeButtonIcons[s],b=l?l.icon:f.buttonIcons[s],k=v?r(v):w&&f.theme?"<span class='ui-icon ui-icon-"+w+"'><\/span>":b&&!f.theme?"<span class='fc-icon fc-icon-"+b+"'><\/span>":r(y),d=["btn btn-primary fc-"+s+"-button",i+"-button"],c=n('<button type="button" class="'+d.join(" ")+'">'+k+"<\/button>").click(function(n){c.hasClass(i+"-state-disabled")||(a(n),(c.hasClass(i+"-state-active")||c.hasClass(i+"-state-disabled"))&&c.removeClass(i+"-state-hover"))}).mousedown(function(){c.not("."+i+"-state-active").not("."+i+"-state-disabled").addClass(i+"-state-down")}).mouseup(function(){c.removeClass(i+"-state-down")}).hover(function(){c.not("."+i+"-state-active").not("."+i+"-state-disabled").addClass(i+"-state-hover")},function(){c.removeClass(i+"-state-hover").removeClass(i+"-state-down")}),u=u.add(c)))});h&&u.first().addClass(i+"-corner-left").end().last().addClass(i+"-corner-right").end();u.length>1?(s=n("<div/>"),h&&s.addClass("fc-button-group"),s.append(u),o.append(s)):o.append(u)}),o}function c(n){u&&u.find("h2").text(n)}function l(n){u&&u.find(".fc-"+n+"-button").addClass(i+"-state-active")}function a(n){u&&u.find(".fc-"+n+"-button").removeClass(i+"-state-active")}function v(n){u&&u.find(".fc-"+n+"-button").prop("disabled",!0).addClass(i+"-state-disabled")}function y(n){u&&u.find(".fc-"+n+"-button").prop("disabled",!1).removeClass(i+"-state-disabled")}function p(){return e}var f=this,u,e,i;f.render=h;f.removeElement=s;f.updateTitle=c;f.activateButton=l;f.deactivateButton=a;f.disableButton=v;f.enableButton=y;f.getViewsWithButtons=p;f.el=null;e=[]}function pe(){function ht(n,t){return!o||n<o||t>s}function ct(n,t){o=n;s=t;y(e,"reset")}function y(n,t){var i,r;for(t==="reset"?u=[]:t!=="add"&&(u=rt(u,n)),i=0;i<n.length;i++)r=n[i],r._status!=="pending"&&v++,r._fetchId=(r._fetchId||0)+1,r._status="pending";for(i=0;i<n.length;i++)r=n[i],at(r,r._fetchId)}function at(t,i){d(t,function(r){var s=n.isArray(t.events),f,e,o;if(i===t._fetchId&&t._status!=="rejected"){if(t._status="resolved",r)for(f=0;f<r.length;f++)e=r[f],o=s?e:l(e,t),o&&u.push.apply(u,b(o));k()}})}function vt(n){var t=n._status==="pending";n._status="rejected";t&&k()}function k(){v--;v||h(u)}function d(t,u){for(var a=i.sourceFetchers,c,e,v,h=0;h<a.length;h++){if(c=a[h].call(r,t,o.clone(),s.clone(),r.options.timezone,u),c===!0)return;if(typeof c=="object"){d(c,u);return}}if(e=t.events,e)n.isFunction(e)?(r.pushLoading(),e.call(r,o.clone(),s.clone(),r.options.timezone,function(n){u(n);r.popLoading()})):n.isArray(e)?u(e):u();else if(v=t.url,v){var w=t.success,b=t.error,k=t.complete,g=n.isFunction(t.data)?t.data():t.data;var l=n.extend({},g||{}),y=f(t.startParam,r.options.startParam),p=f(t.endParam,r.options.endParam),nt=f(t.timezoneParam,r.options.timezoneParam);y&&(l[y]=o.format());p&&(l[p]=s.format());r.options.timezone&&r.options.timezone!="local"&&(l[nt]=r.options.timezone);r.pushLoading();n.ajax(n.extend({},yu,t,{data:l,success:function(t){t=t||[];var i=lt(w,this,arguments);n.isArray(i)&&(t=i);u(t)},error:function(){lt(b,this,arguments);u()},complete:function(){lt(k,this,arguments);r.popLoading()}}))}else u()}function yt(n){var t=g(n);t&&(e.push(t),y([t],"add"))}function g(t){var e=i.sourceNormalizers,u,f;if(n.isFunction(t)||n.isArray(t)?u={events:t}:typeof t=="string"?u={url:t}:typeof t=="object"&&(u=n.extend({},t)),u){for(u.className?typeof u.className=="string"&&(u.className=u.className.split(/\s+/)):u.className=[],n.isArray(u.events)&&(u.origArray=u.events,u.events=n.map(u.events,function(n){return l(n,u)})),f=0;f<e.length;f++)e[f].call(r,u);return u}}function pt(n){p(w(n))}function bt(n){n==null?p(e,!0):p(tt(n))}function p(t,i){for(var r=0;r<t.length;r++)vt(t[r]);i?(e=[],u=[]):(e=n.grep(e,function(n){for(r=0;r<t.length;r++)if(n===t[r])return!1;return!0}),u=rt(u,t));h(u)}function kt(){return e.slice(1)}function nt(t){return n.grep(e,function(n){return n.id&&n.id===t})[0]}function tt(t){t?n.isArray(t)||(t=[t]):t=[];for(var r=[],i=0;i<t.length;i++)r.push.apply(r,w(t[i]));return r}function w(t){for(var i,r=0;r<e.length;r++)if(i=e[r],i===t)return[i];return(i=nt(t),i)?[i]:n.grep(e,function(n){return dt(t,n)})}function dt(n,t){return n&&t&&it(n)==it(t)}function it(n){return(typeof n=="object"?n.origArray||n.googleCalendarId||n.url||n.events:null)||n}function rt(t,i){return n.grep(t,function(n){for(var t=0;t<i.length;t++)if(n.source===i[t])return!1;return!0})}function gt(n){n.start=r.moment(n.start);n.end=n.end?r.moment(n.end):null;st(n,ni(n));h(u)}function ni(t){var i={};return n.each(t,function(n,t){ut(n)&&t!==undefined&&vf(t)&&(i[n]=t)}),i}function ut(n){return!/^_|^(id|allDay|start|end)$/.test(n)}function ti(n,t){var e=l(n),r,f,i;if(e){for(r=b(e),f=0;f<r.length;f++)i=r[f],i.source||(t&&(a.events.push(i),i.source=a),u.push(i));return h(u),r}return[]}function ii(t){var r,i;for(t==null?t=function(){return!0}:n.isFunction(t)||(r=t+"",t=function(n){return n._id==r}),u=n.grep(u,t,!0),i=0;i<e.length;i++)n.isArray(e[i].events)&&(e[i].events=n.grep(e[i].events,t,!0));h(u)}function ft(t){return n.isFunction(t)?n.grep(u,t):t!=null?(t+="",n.grep(u,function(n){return n._id==t})):u}function ri(n){n.start=r.moment(n.start);n.end&&(n.end=r.moment(n.end));wt(n)}function l(i,u){var s={},o,e,h;if(r.options.eventDataTransform&&(i=r.options.eventDataTransform(i)),u&&u.eventDataTransform&&(i=u.eventDataTransform(i)),n.extend(s,i),u&&(s.source=u),s._id=i._id||(i.id===undefined?"_fc"+pu++:i.id+""),s.className=i.className?typeof i.className=="string"?i.className.split(/\s+/):i.className:[],o=i.start||i.date,e=i.end,ar(o)&&(o=t.duration(o)),ar(e)&&(e=t.duration(e)),i.dow||t.isDuration(o)||t.isDuration(e))s.start=o?t.duration(o):null,s.end=e?t.duration(e):null,s._recurring=!0;else{if(o&&(o=r.moment(o),!o.isValid()))return!1;e&&(e=r.moment(e),e.isValid()||(e=null));h=i.allDay;h===undefined&&(h=f(u?u.allDayDefault:undefined,r.options.allDayDefault));et(o,e,h,s)}return r.normalizeEvent(s),s}function et(n,t,i,r){r.start=n;r.end=t;r.allDay=i;c(r);wt(r)}function c(n){ot(n);n.end&&!n.end.isAfter(n.start)&&(n.end=null);n.end||(n.end=r.options.forceEventDuration?r.getDefaultEventEnd(n.allDay,n.start):null)}function ot(n){n.allDay==null&&(n.allDay=!(n.start.hasTime()||n.end&&n.end.hasTime()));n.allDay?(n.start.stripTime(),n.end&&n.end.stripTime()):(n.start.hasTime()||(n.start=r.applyTimezone(n.start.time(0))),n.end&&!n.end.hasTime()&&(n.end=r.applyTimezone(n.end.time(0))))}function b(t,i,r){var a=[],f,v,e,u,h,c,l,y,p;if(i=i||o,r=r||s,t)if(t._recurring){if(v=t.dow)for(f={},e=0;e<v.length;e++)f[v[e]]=!0;for(u=i.clone().stripTime();u.isBefore(r);)(!f||f[u.day()])&&(h=t.start,c=t.end,l=u.clone(),y=null,h&&(l=l.time(h)),c&&(y=u.clone().time(c)),p=n.extend({},t),et(l,y,!h&&!c,p),a.push(p)),u.add(1,"days")}else a.push(t);return a}function st(t,i,u){function v(n,t){return u?lr(n,t,u):i.allDay?sf(n,t):cr(n,t)}var s={},f,h,e,l,o,a;return i=i||{},i.start||(i.start=t.start.clone()),i.end===undefined&&(i.end=t.end?t.end.clone():null),i.allDay==null&&(i.allDay=t.allDay),c(i),f={start:t._start.clone(),end:t._end?t._end.clone():r.getDefaultEventEnd(t._allDay,t._start),allDay:i.allDay},c(f),h=t._end!==null&&i.end===null,e=v(i.start,f.start),i.end?(l=v(i.end,f.end),o=l.subtract(e)):o=null,n.each(i,function(n,t){ut(n)&&t!==undefined&&(s[n]=t)}),a=ui(ft(t._id),h,i.allDay,e,o,s),{dateDelta:e,durationDelta:o,undo:a}}function ui(t,i,u,f,e,o){var h=r.getIsAmbigTimezone(),s=[];return f&&!f.valueOf()&&(f=null),e&&!e.valueOf()&&(e=null),n.each(t,function(t,l){var v,a;v={start:l.start.clone(),end:l.end?l.end.clone():null,allDay:l.allDay};n.each(o,function(n){v[n]=l[n]});a={start:l._start,end:l._end,allDay:u};c(a);i?a.end=null:e&&!a.end&&(a.end=r.getDefaultEventEnd(a.allDay,a.start));f&&(a.start.add(f),a.end&&a.end.add(f));e&&a.end.add(e);h&&!a.allDay&&(f||e)&&(a.start.stripZone(),a.end&&a.end.stripZone());n.extend(l,o,a);wt(l);s.push(function(){n.extend(l,v);wt(l)})}),function(){for(var n=0;n<s.length;n++)s[n]()}}var r=this;r.isFetchNeeded=ht;r.fetchEvents=ct;r.fetchEventSources=y;r.getEventSources=kt;r.getEventSourceById=nt;r.getEventSourcesByMatchArray=tt;r.getEventSourcesByMatch=w;r.addEventSource=yt;r.removeEventSource=pt;r.removeEventSources=bt;r.updateEvent=gt;r.renderEvent=ti;r.removeEvents=ii;r.clientEvents=ft;r.mutateEvent=st;r.normalizeEventDates=c;r.normalizeEventTimes=ot;var h=r.reportEvents,a={events:[]},e=[a],o,s,v=0,u=[];n.each((r.options.events?[r.options.events]:[]).concat(r.options.eventSources||[]),function(n,t){var i=g(t);i&&e.push(i)});r.rezoneArrayEventSources=function(){for(var i,r,t=0;t<e.length;t++)if(i=e[t].events,n.isArray(i))for(r=0;r<i.length;r++)ri(i[r])};r.buildEventFromInput=l;r.expandEvent=b;r.getEventCache=function(){return u}}function wt(n){n._allDay=n.allDay;n._start=n.start.clone();n._end=n.end?n.end.clone():null}var i=n.fullCalendar={version:"3.0.1",internalApiVersion:6},e=i.views={},bi,et,ni,ht,vr,hi,kr,yt,nu,it,eu,c,ai,rt,vi,b,yu,pu,pi,bu,ku;n.fn.fullCalendar=function(t){var r=Array.prototype.slice.call(arguments,1),i=this;return this.each(function(f,e){var s=n(e),o=s.data("fullCalendar"),h;typeof t=="string"?o&&n.isFunction(o[t])&&(h=o[t].apply(o,r),f||(i=h),t==="destroy"&&s.removeData("fullCalendar")):o||(o=new u(s,t),s.data("fullCalendar",o),o.render())}),i};bi=["header","buttonText","buttonIcons","themeButtonIcons"];i.intersectRanges=st;i.applyAll=lt;i.debounce=vt;i.isInt=y;i.htmlEscape=r;i.cssToStr=at;i.proxy=d;i.capitaliseFirstLetter=pr;i.getOuterRect=dt;i.getClientRect=ir;i.getContentRect=du;i.getScrollbarWidths=gt;et=null;i.preventDefault=ot;i.intersectRects=fr;i.parseFieldSpecs=er;i.compareByFieldSpecs=or;i.compareByFieldSpec=sr;i.flexibleCompare=hr;i.computeIntervalUnit=ti;i.divideRangeByDuration=cf;i.divideDurationByDuration=ii;i.multiplyDuration=lf;i.durationHasTime=k;ni=["sun","mon","tue","wed","thu","fri","sat"];ht=["year","month","week","day","hour","minute","second","millisecond"];i.log=function(){var n=window.console;if(n&&n.log)return n.log.apply(n,arguments)};i.warn=function(){var n=window.console;return n&&n.warn?n.warn.apply(n,arguments):i.log.apply(i,arguments)};vr={}.hasOwnProperty;var wf=/^\s*\d{4}-\d\d$/,bf=/^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/,o=t.fn,v=n.extend({},o),oi=t.momentProperties;oi.push("_fullCalendar");oi.push("_ambigTime");oi.push("_ambigZone");i.moment=function(){return si(arguments)};i.moment.utc=function(){var n=si(arguments,!0);return n.hasTime()&&n.utc(),n};i.moment.parseZone=function(){return si(arguments,!0,!0)};o.week=o.weeks=function(n){var t=this._locale._fullCalendar_weekCalc;return n==null&&typeof t=="function"?t(this):t==="ISO"?v.isoWeek.apply(this,arguments):v.week.apply(this,arguments)};o.time=function(n){if(!this._fullCalendar)return v.time.apply(this,arguments);if(n==null)return t.duration({hours:this.hours(),minutes:this.minutes(),seconds:this.seconds(),milliseconds:this.milliseconds()});this._ambigTime=!1;t.isDuration(n)||t.isMoment(n)||(n=t.duration(n));var i=0;return t.isDuration(n)&&(i=Math.floor(n.asDays())*24),this.hours(i+n.hours()).minutes(n.minutes()).seconds(n.seconds()).milliseconds(n.milliseconds())};o.stripTime=function(){return this._ambigTime||(this.utc(!0),this.set({hours:0,minutes:0,seconds:0,ms:0}),this._ambigTime=!0,this._ambigZone=!0),this};o.hasTime=function(){return!this._ambigTime};o.stripZone=function(){var n;return this._ambigZone||(n=this._ambigTime,this.utc(!0),this._ambigTime=n||!1,this._ambigZone=!0),this};o.hasZone=function(){return!this._ambigZone};o.local=function(n){return v.local.call(this,this._ambigZone||n),this._ambigTime=!1,this._ambigZone=!1,this};o.utc=function(n){return v.utc.call(this,n),this._ambigTime=!1,this._ambigZone=!1,this};o.utcOffset=function(n){return n!=null&&(this._ambigTime=!1,this._ambigZone=!1),v.utcOffset.apply(this,arguments)};o.format=function(){return this._fullCalendar&&arguments[0]?kf(this,arguments[0]):this._ambigTime?p(this,"YYYY-MM-DD"):this._ambigZone?p(this,"YYYY-MM-DD[T]HH:mm:ss"):v.format.apply(this,arguments)};o.toISOString=function(){return this._ambigTime?p(this,"YYYY-MM-DD"):this._ambigZone?p(this,"YYYY-MM-DD[T]HH:mm:ss"):v.toISOString.apply(this,arguments)};hi={t:function(n){return p(n,"a").charAt(0)},T:function(n){return p(n,"A").charAt(0)}};i.formatRange=br;kr={Y:"year",M:"month",D:"day",d:"day",A:"second",a:"second",T:"second",t:"second",H:"second",h:"second",m:"second",s:"second"};yt={};nu={Y:{value:1,unit:"year"},M:{value:2,unit:"month"},W:{value:3,unit:"week"},w:{value:3,unit:"week"},D:{value:4,unit:"day"},d:{value:4,unit:"day"}};i.queryMostGranularFormatUnit=function(n){for(var f=li(n),u,r,t,i=0;i<f.length;i++)u=f[i],u.token&&(r=nu[u.token.charAt(0)],r&&(!t||r.value>t.value)&&(t=r));return t?t.unit:null};i.Class=s;s.extend=function(){for(var i=arguments.length,t,n=0;n<i;n++)t=arguments[n],n<i-1&&tu(this,t);return gf(this,t||{})};s.mixin=function(n){tu(this,n)};var iu=i.EmitterMixin={on:function(t,i){var r=function(n,t){return i.apply(t.context||this,t.args||[])};i.guid||(i.guid=n.guid++);r.guid=i.guid;n(this).on(t,r);return this},off:function(t,i){return n(this).off(t,i),this},trigger:function(t){var i=Array.prototype.slice.call(arguments,1);return n(this).triggerHandler(t,{args:i}),this},triggerWith:function(t,i,r){return n(this).triggerHandler(t,{context:i,args:r}),this}},tt=i.ListenerMixin=function(){var t=0;return{listenerId:null,listenTo:function(t,i,r){if(typeof i=="object")for(var u in i)i.hasOwnProperty(u)&&this.listenTo(t,u,i[u]);else if(typeof i=="string")t.on(i+"."+this.getListenerNamespace(),n.proxy(r,this))},stopListeningTo:function(n,t){n.off((t||"")+"."+this.getListenerNamespace())},getListenerNamespace:function(){return this.listenerId==null&&(this.listenerId=t++),"_listener"+this.listenerId}}}(),ru={isIgnoringMouse:!1,delayUnignoreMouse:null,initMouseIgnoring:function(n){this.delayUnignoreMouse=vt(d(this,"unignoreMouse"),n||1e3)},tempIgnoreMouse:function(){this.isIgnoringMouse=!0;this.delayUnignoreMouse()},unignoreMouse:function(){this.isIgnoringMouse=!1}},ne=s.extend(tt,{isHidden:!0,options:null,el:null,margin:10,constructor:function(n){this.options=n||{}},show:function(){this.isHidden&&(this.el||this.render(),this.el.show(),this.position(),this.isHidden=!1,this.trigger("show"))},hide:function(){this.isHidden||(this.el.hide(),this.isHidden=!0,this.trigger("hide"))},render:function(){var i=this,t=this.options;this.el=n('<div class="fc-popover"/>').addClass(t.className||"").css({top:0,left:0}).append(t.content).appendTo(t.parentEl);this.el.on("click",".fc-close",function(){i.hide()});t.autoHide&&this.listenTo(n(document),"mousedown",this.documentMousedown)},documentMousedown:function(t){this.el&&!n(t.target).closest(this.el).length&&this.hide()},removeElement:function(){this.hide();this.el&&(this.el.remove(),this.el=null);this.stopListeningTo(n(document),"mousedown")},position:function(){var t=this.options,h=this.el.offsetParent().offset(),c=this.el.outerWidth(),l=this.el.outerHeight(),o=n(window),i=kt(this.el),f,e,s,r,u;r=t.top||0;u=t.left!==undefined?t.left:t.right!==undefined?t.right-c:0;i.is(window)||i.is(document)?(i=o,f=0,e=0):(s=i.offset(),f=s.top,e=s.left);f+=o.scrollTop();e+=o.scrollLeft();t.viewportConstrain!==!1&&(r=Math.min(r,f+i.outerHeight()-l-this.margin),r=Math.max(r,f+this.margin),u=Math.min(u,e+i.outerWidth()-c-this.margin),u=Math.max(u,e+this.margin));this.el.css({top:r-h.top,left:u-h.left})},trigger:function(n){this.options[n]&&this.options[n].apply(this,Array.prototype.slice.call(arguments,1))}}),pt=i.CoordCache=s.extend({els:null,forcedOffsetParentEl:null,origin:null,boundingRect:null,isHorizontal:!1,isVertical:!1,lefts:null,rights:null,tops:null,bottoms:null,constructor:function(t){this.els=n(t.els);this.isHorizontal=t.isHorizontal;this.isVertical=t.isVertical;this.forcedOffsetParentEl=t.offsetParent?n(t.offsetParent):null},build:function(){var n=this.forcedOffsetParentEl||this.els.eq(0).offsetParent();this.origin=n.offset();this.boundingRect=this.queryBoundingRect();this.isHorizontal&&this.buildElHorizontals();this.isVertical&&this.buildElVerticals()},clear:function(){this.origin=null;this.boundingRect=null;this.lefts=null;this.rights=null;this.tops=null;this.bottoms=null},ensureBuilt:function(){this.origin||this.build()},buildElHorizontals:function(){var t=[],i=[];this.els.each(function(r,u){var f=n(u),e=f.offset().left,o=f.outerWidth();t.push(e);i.push(e+o)});this.lefts=t;this.rights=i},buildElVerticals:function(){var t=[],i=[];this.els.each(function(r,u){var f=n(u),e=f.offset().top,o=f.outerHeight();t.push(e);i.push(e+o)});this.tops=t;this.bottoms=i},getHorizontalIndex:function(n){this.ensureBuilt();for(var i=this.lefts,r=this.rights,u=i.length,t=0;t<u;t++)if(n>=i[t]&&n<r[t])return t},getVerticalIndex:function(n){this.ensureBuilt();for(var i=this.tops,r=this.bottoms,u=i.length,t=0;t<u;t++)if(n>=i[t]&&n<r[t])return t},getLeftOffset:function(n){return this.ensureBuilt(),this.lefts[n]},getLeftPosition:function(n){return this.ensureBuilt(),this.lefts[n]-this.origin.left},getRightOffset:function(n){return this.ensureBuilt(),this.rights[n]},getRightPosition:function(n){return this.ensureBuilt(),this.rights[n]-this.origin.left},getWidth:function(n){return this.ensureBuilt(),this.rights[n]-this.lefts[n]},getTopOffset:function(n){return this.ensureBuilt(),this.tops[n]},getTopPosition:function(n){return this.ensureBuilt(),this.tops[n]-this.origin.top},getBottomOffset:function(n){return this.ensureBuilt(),this.bottoms[n]},getBottomPosition:function(n){return this.ensureBuilt(),this.bottoms[n]-this.origin.top},getHeight:function(n){return this.ensureBuilt(),this.bottoms[n]-this.tops[n]},queryBoundingRect:function(){var n=kt(this.els.eq(0));if(!n.is(document))return ir(n)},isPointInBounds:function(n,t){return this.isLeftInBounds(n)&&this.isTopInBounds(t)},isLeftInBounds:function(n){return!this.boundingRect||n>=this.boundingRect.left&&n<this.boundingRect.right},isTopInBounds:function(n){return!this.boundingRect||n>=this.boundingRect.top&&n<this.boundingRect.bottom}}),h=i.DragListener=s.extend(tt,ru,{options:null,subjectEl:null,originX:null,originY:null,scrollEl:null,isInteracting:!1,isDistanceSurpassed:!1,isDelayEnded:!1,isDragging:!1,isTouch:!1,delay:null,delayTimeoutId:null,minDistance:null,handleTouchScrollProxy:null,constructor:function(n){this.options=n||{};this.handleTouchScrollProxy=d(this,"handleTouchScroll");this.initMouseIgnoring(500)},startInteraction:function(t,i){var r=ur(t);if(t.type==="mousedown"){if(this.isIgnoringMouse)return;if(rr(t))t.preventDefault();else return}this.isInteracting||(i=i||{},this.delay=f(i.delay,this.options.delay,0),this.minDistance=f(i.distance,this.options.distance,0),this.subjectEl=this.options.subjectEl,this.isInteracting=!0,this.isTouch=r,this.isDelayEnded=!1,this.isDistanceSurpassed=!1,this.originX=l(t),this.originY=a(t),this.scrollEl=kt(n(t.target)),this.bindHandlers(),this.initAutoScroll(),this.handleInteractionStart(t),this.startDelay(t),this.minDistance||this.handleDistanceSurpassed(t))},handleInteractionStart:function(n){this.trigger("interactionStart",n)},endInteraction:function(n,t){this.isInteracting&&(this.endDrag(n),this.delayTimeoutId&&(clearTimeout(this.delayTimeoutId),this.delayTimeoutId=null),this.destroyAutoScroll(),this.unbindHandlers(),this.isInteracting=!1,this.handleInteractionEnd(n,t),this.isTouch&&this.tempIgnoreMouse())},handleInteractionEnd:function(n,t){this.trigger("interactionEnd",n,t||!1)},bindHandlers:function(){var i=this,t=1;this.isTouch?(this.listenTo(n(document),{touchmove:this.handleTouchMove,touchend:this.endInteraction,touchcancel:this.endInteraction,touchstart:function(n){t?t--:i.endInteraction(n,!0)}}),!rf(this.handleTouchScrollProxy)&&this.scrollEl&&this.listenTo(this.scrollEl,"scroll",this.handleTouchScroll)):this.listenTo(n(document),{mousemove:this.handleMouseMove,mouseup:this.endInteraction});this.listenTo(n(document),{selectstart:ot,contextmenu:ot})},unbindHandlers:function(){this.stopListeningTo(n(document));uf(this.handleTouchScrollProxy);this.scrollEl&&this.stopListeningTo(this.scrollEl,"scroll")},startDrag:function(n,t){this.startInteraction(n,t);this.isDragging||(this.isDragging=!0,this.handleDragStart(n))},handleDragStart:function(n){this.trigger("dragStart",n)},handleMove:function(n){var t=l(n)-this.originX,i=a(n)-this.originY,r=this.minDistance,u;this.isDistanceSurpassed||(u=t*t+i*i,u>=r*r&&this.handleDistanceSurpassed(n));this.isDragging&&this.handleDrag(t,i,n)},handleDrag:function(n,t,i){this.trigger("drag",n,t,i);this.updateAutoScroll(i)},endDrag:function(n){this.isDragging&&(this.isDragging=!1,this.handleDragEnd(n))},handleDragEnd:function(n){this.trigger("dragEnd",n)},startDelay:function(n){var t=this;this.delay?this.delayTimeoutId=setTimeout(function(){t.handleDelayEnd(n)},this.delay):this.handleDelayEnd(n)},handleDelayEnd:function(n){this.isDelayEnded=!0;this.isDistanceSurpassed&&this.startDrag(n)},handleDistanceSurpassed:function(n){this.isDistanceSurpassed=!0;this.isDelayEnded&&this.startDrag(n)},handleTouchMove:function(n){this.isDragging&&n.preventDefault();this.handleMove(n)},handleMouseMove:function(n){this.handleMove(n)},handleTouchScroll:function(n){this.isDragging||this.endInteraction(n,!0)},trigger:function(n){this.options[n]&&this.options[n].apply(this,Array.prototype.slice.call(arguments,1));this["_"+n]&&this["_"+n].apply(this,Array.prototype.slice.call(arguments,1))}});h.mixin({isAutoScroll:!1,scrollBounds:null,scrollTopVel:null,scrollLeftVel:null,scrollIntervalId:null,scrollSensitivity:30,scrollSpeed:200,scrollIntervalMs:50,initAutoScroll:function(){var n=this.scrollEl;this.isAutoScroll=this.options.scroll&&n&&!n.is(window)&&!n.is(document);this.isAutoScroll&&this.listenTo(n,"scroll",vt(this.handleDebouncedScroll,100))},destroyAutoScroll:function(){this.endAutoScroll();this.isAutoScroll&&this.stopListeningTo(this.scrollEl,"scroll")},computeScrollBounds:function(){this.isAutoScroll&&(this.scrollBounds=dt(this.scrollEl))},updateAutoScroll:function(n){var t=this.scrollSensitivity,i=this.scrollBounds,r,u,f,e,o=0,s=0;i&&(r=(t-(a(n)-i.top))/t,u=(t-(i.bottom-a(n)))/t,f=(t-(l(n)-i.left))/t,e=(t-(i.right-l(n)))/t,r>=0&&r<=1?o=r*this.scrollSpeed*-1:u>=0&&u<=1&&(o=u*this.scrollSpeed),f>=0&&f<=1?s=f*this.scrollSpeed*-1:e>=0&&e<=1&&(s=e*this.scrollSpeed));this.setScrollVel(o,s)},setScrollVel:function(n,t){this.scrollTopVel=n;this.scrollLeftVel=t;this.constrainScrollVel();(this.scrollTopVel||this.scrollLeftVel)&&!this.scrollIntervalId&&(this.scrollIntervalId=setInterval(d(this,"scrollIntervalFunc"),this.scrollIntervalMs))},constrainScrollVel:function(){var n=this.scrollEl;this.scrollTopVel<0?n.scrollTop()<=0&&(this.scrollTopVel=0):this.scrollTopVel>0&&n.scrollTop()+n[0].clientHeight>=n[0].scrollHeight&&(this.scrollTopVel=0);this.scrollLeftVel<0?n.scrollLeft()<=0&&(this.scrollLeftVel=0):this.scrollLeftVel>0&&n.scrollLeft()+n[0].clientWidth>=n[0].scrollWidth&&(this.scrollLeftVel=0)},scrollIntervalFunc:function(){var n=this.scrollEl,t=this.scrollIntervalMs/1e3;this.scrollTopVel&&n.scrollTop(n.scrollTop()+this.scrollTopVel*t);this.scrollLeftVel&&n.scrollLeft(n.scrollLeft()+this.scrollLeftVel*t);this.constrainScrollVel();this.scrollTopVel||this.scrollLeftVel||this.endAutoScroll()},endAutoScroll:function(){this.scrollIntervalId&&(clearInterval(this.scrollIntervalId),this.scrollIntervalId=null,this.handleScrollEnd())},handleDebouncedScroll:function(){this.scrollIntervalId||this.handleScrollEnd()},handleScrollEnd:function(){}});it=h.extend({component:null,origHit:null,hit:null,coordAdjust:null,constructor:function(n,t){h.call(this,t);this.component=n},handleInteractionStart:function(n){var r=this.subjectEl,i,u,t;this.computeCoords();n?(u={left:l(n),top:a(n)},t=u,r&&(i=dt(r),t=ff(t,i)),this.origHit=this.queryHit(t.left,t.top),r&&this.options.subjectCenter&&(this.origHit&&(i=fr(this.origHit,i)||i),t=ef(i)),this.coordAdjust=of(t,u)):(this.origHit=null,this.coordAdjust=null);h.prototype.handleInteractionStart.apply(this,arguments)},computeCoords:function(){this.component.prepareHits();this.computeScrollBounds()},handleDragStart:function(n){var t;h.prototype.handleDragStart.apply(this,arguments);t=this.queryHit(l(n),a(n));t&&this.handleHitOver(t)},handleDrag:function(n,t,i){var r;h.prototype.handleDrag.apply(this,arguments);r=this.queryHit(l(i),a(i));uu(r,this.hit)||(this.hit&&this.handleHitOut(),r&&this.handleHitOver(r))},handleDragEnd:function(){this.handleHitDone();h.prototype.handleDragEnd.apply(this,arguments)},handleHitOver:function(n){var t=uu(n,this.origHit);this.hit=n;this.trigger("hitOver",this.hit,t,this.origHit)},handleHitOut:function(){this.hit&&(this.trigger("hitOut",this.hit),this.handleHitDone(),this.hit=null)},handleHitDone:function(){this.hit&&this.trigger("hitDone",this.hit)},handleInteractionEnd:function(){h.prototype.handleInteractionEnd.apply(this,arguments);this.origHit=null;this.hit=null;this.component.releaseHits()},handleScrollEnd:function(){h.prototype.handleScrollEnd.apply(this,arguments);this.computeCoords()},queryHit:function(n,t){return this.coordAdjust&&(n+=this.coordAdjust.left,t+=this.coordAdjust.top),this.component.queryHit(n,t)}});eu=s.extend(tt,{options:null,sourceEl:null,el:null,parentEl:null,top0:null,left0:null,y0:null,x0:null,topDelta:null,leftDelta:null,isFollowing:!1,isHidden:!1,isAnimating:!1,constructor:function(t,i){this.options=i=i||{};this.sourceEl=t;this.parentEl=i.parentEl?n(i.parentEl):t.parent()},start:function(t){this.isFollowing||(this.isFollowing=!0,this.y0=a(t),this.x0=l(t),this.topDelta=0,this.leftDelta=0,this.isHidden||this.updatePosition(),ur(t)?this.listenTo(n(document),"touchmove",this.handleMove):this.listenTo(n(document),"mousemove",this.handleMove))},stop:function(t,i){function f(){r.isAnimating=!1;r.removeElement();r.top0=r.left0=null;i&&i()}var r=this,u=this.options.revertDuration;this.isFollowing&&!this.isAnimating&&(this.isFollowing=!1,this.stopListeningTo(n(document)),t&&u&&!this.isHidden?(this.isAnimating=!0,this.el.animate({top:this.top0,left:this.left0},{duration:u,complete:f})):f())},getEl:function(){var n=this.el;return n||(n=this.el=this.sourceEl.clone().addClass(this.options.additionalClass||"").css({position:"absolute",visibility:"",display:this.isHidden?"none":"",margin:0,right:"auto",bottom:"auto",width:this.sourceEl.width(),height:this.sourceEl.height(),opacity:this.options.opacity||"",zIndex:this.options.zIndex}),n.addClass("fc-unselectable"),n.appendTo(this.parentEl)),n},removeElement:function(){this.el&&(this.el.remove(),this.el=null)},updatePosition:function(){var n,t;this.getEl();this.top0===null&&(n=this.sourceEl.offset(),t=this.el.offsetParent().offset(),this.top0=n.top-t.top,this.left0=n.left-t.left);this.el.css({top:this.top0+this.topDelta,left:this.left0+this.leftDelta})},handleMove:function(n){this.topDelta=a(n)-this.y0;this.leftDelta=l(n)-this.x0;this.isHidden||this.updatePosition()},hide:function(){this.isHidden||(this.isHidden=!0,this.el&&this.el.hide())},show:function(){this.isHidden&&(this.isHidden=!1,this.updatePosition(),this.getEl().show())}});c=i.Grid=s.extend(tt,ru,{hasDayInteractions:!0,view:null,isRTL:null,start:null,end:null,el:null,elsByFill:null,eventTimeFormat:null,displayEventTime:null,displayEventEnd:null,minResizeDuration:null,largeUnit:null,dayDragListener:null,segDragListener:null,segResizeListener:null,externalDragListener:null,constructor:function(n){this.view=n;this.isRTL=n.opt("isRTL");this.elsByFill={};this.dayDragListener=this.buildDayDragListener();this.initMouseIgnoring()},computeEventTimeFormat:function(){return this.view.opt("smallTimeFormat")},computeDisplayEventTime:function(){return!0},computeDisplayEventEnd:function(){return!0},setRange:function(n){this.start=n.start.clone();this.end=n.end.clone();this.rangeUpdated();this.processRangeOptions()},rangeUpdated:function(){},processRangeOptions:function(){var n=this.view,t,i;this.eventTimeFormat=n.opt("eventTimeFormat")||n.opt("timeFormat")||this.computeEventTimeFormat();t=n.opt("displayEventTime");t==null&&(t=this.computeDisplayEventTime());i=n.opt("displayEventEnd");i==null&&(i=this.computeDisplayEventEnd());this.displayEventTime=t;this.displayEventEnd=i},spanToSegs:function(){},diffDates:function(n,t){return this.largeUnit?lr(n,t,this.largeUnit):cr(n,t)},prepareHits:function(){},releaseHits:function(){},queryHit:function(){},getHitSpan:function(){},getHitEl:function(){},setElement:function(n){this.el=n;this.hasDayInteractions&&(tf(n),this.bindDayHandler("touchstart",this.dayTouchStart),this.bindDayHandler("mousedown",this.dayMousedown));this.bindSegHandlers();this.bindGlobalHandlers()},bindDayHandler:function(t,i){var r=this;this.el.on(t,function(t){if(!n(t.target).is(r.segSelector+","+r.segSelector+" *,.fc-more,a[data-goto]"))return i.call(r,t)})},removeElement:function(){this.unbindGlobalHandlers();this.clearDragListeners();this.el.remove()},renderSkeleton:function(){},renderDates:function(){},unrenderDates:function(){},bindGlobalHandlers:function(){this.listenTo(n(document),{dragstart:this.externalDragStart,sortstart:this.externalDragStart})},unbindGlobalHandlers:function(){this.stopListeningTo(n(document))},dayMousedown:function(n){this.isIgnoringMouse||this.dayDragListener.startInteraction(n,{})},dayTouchStart:function(n){var t=this.view;(t.isSelected||t.selectedEvent)&&this.tempIgnoreMouse();this.dayDragListener.startInteraction(n,{delay:this.view.opt("longPressDelay")})},buildDayDragListener:function(){var n=this,r=this.view,f=r.opt("selectable"),i,t,u=new it(this,{scroll:r.opt("dragScroll"),interactionStart:function(){i=u.origHit;t=null},dragStart:function(){r.unselect()},hitOver:function(r,u,e){e&&(u||(i=null),f&&(t=n.computeSelection(n.getHitSpan(e),n.getHitSpan(r)),t?n.renderSelection(t):t===!1&&ut()))},hitOut:function(){i=null;t=null;n.unrenderSelection()},hitDone:function(){ft()},interactionEnd:function(u,f){f||(i&&!n.isIgnoringMouse&&r.triggerDayClick(n.getHitSpan(i),n.getHitEl(i),u),t&&r.reportSelection(t,u))}});return u},clearDragListeners:function(){this.dayDragListener.endInteraction();this.segDragListener&&this.segDragListener.endInteraction();this.segResizeListener&&this.segResizeListener.endInteraction();this.externalDragListener&&this.externalDragListener.endInteraction()},renderEventLocationHelper:function(n,t){var i=this.fabricateHelperEvent(n,t);return this.renderHelper(i,t)},fabricateHelperEvent:function(n,t){var i=t?ct(t.event):{};return i.start=n.start.clone(),i.end=n.end?n.end.clone():null,i.allDay=null,this.view.calendar.normalizeEventDates(i),i.className=(i.className||[]).concat("fc-helper"),t||(i.editable=!1),i},renderHelper:function(){},unrenderHelper:function(){},renderSelection:function(n){this.renderHighlight(n)},unrenderSelection:function(){this.unrenderHighlight()},computeSelection:function(n,t){var i=this.computeSelectionSpan(n,t);return i&&!this.view.calendar.isSelectionSpanAllowed(i)?!1:i},computeSelectionSpan:function(n,t){var i=[n.start,n.end,t.start,t.end];return i.sort(pf),{start:i[0].clone(),end:i[3].clone()}},renderHighlight:function(n){this.renderFill("highlight",this.spanToSegs(n))},unrenderHighlight:function(){this.unrenderFill("highlight")},highlightSegClasses:function(){return["fc-highlight"]},renderBusinessHours:function(){},unrenderBusinessHours:function(){},getNowIndicatorUnit:function(){},renderNowIndicator:function(){},unrenderNowIndicator:function(){},renderFill:function(){},unrenderFill:function(n){var t=this.elsByFill[n];t&&(t.remove(),delete this.elsByFill[n])},renderFillSegEls:function(t,i){var u=this,f=this[t+"SegEl"],e="",o=[],r;if(i.length){for(r=0;r<i.length;r++)e+=this.fillSegHtml(t,i[r]);n(e).each(function(t,r){var s=i[t],e=n(r);f&&(e=f.call(u,s,e));e&&(e=n(e),e.is(u.fillSegTag)&&(s.el=e,o.push(s)))})}return o},fillSegTag:"div",fillSegHtml:function(n,t){var i=this[n+"SegClasses"],r=this[n+"SegCss"],u=i?i.call(this,t):[],f=at(r?r.call(this,t):{});return"<"+this.fillSegTag+(u.length?' class="'+u.join(" ")+'"':"")+(f?' style="'+f+'"':"")+" />"},getDayClasses:function(n){var i=this.view,r=i.calendar.getNow(),t=["fc-"+ni[n.day()]];return i.intervalDuration.as("months")==1&&n.month()!=i.intervalStart.month()&&t.push("fc-other-month"),n.isSame(r,"day")?t.push("fc-today",i.highlightStateClass):n<r?t.push("fc-past"):t.push("fc-future"),t}});c.mixin({segSelector:".fc-event-container > *",mousedOverSeg:null,isDraggingSeg:!1,isResizingSeg:!1,isDraggingExternal:!1,segs:null,renderEvents:function(n){for(var i=[],r=[],t=0;t<n.length;t++)(su(n[t])?i:r).push(n[t]);this.segs=[].concat(this.renderBgEvents(i),this.renderFgEvents(r))},renderBgEvents:function(n){var t=this.eventsToSegs(n);return this.renderBgSegs(t)||t},renderFgEvents:function(n){var t=this.eventsToSegs(n);return this.renderFgSegs(t)||t},unrenderEvents:function(){this.handleSegMouseout();this.clearDragListeners();this.unrenderFgSegs();this.unrenderBgSegs();this.segs=null},getEventSegs:function(){return this.segs||[]},renderFgSegs:function(){},unrenderFgSegs:function(){},renderFgSegEls:function(t,i){var e=this.view,u="",f=[],r;if(t.length){for(r=0;r<t.length;r++)u+=this.fgSegHtml(t[r],i);n(u).each(function(i,r){var u=t[i],o=e.resolveEventEl(u.event,n(r));o&&(o.data("fc-seg",u),u.el=o,f.push(u))})}return f},fgSegHtml:function(){},renderBgSegs:function(n){return this.renderFill("bgEvent",n)},unrenderBgSegs:function(){this.unrenderFill("bgEvent")},bgEventSegEl:function(n,t){return this.view.resolveEventEl(n.event,t)},bgEventSegClasses:function(n){var t=n.event,i=t.source||{};return["fc-bgevent"].concat(t.className,i.className||[])},bgEventSegCss:function(n){return{"background-color":this.getSegSkinCss(n)["background-color"]}},businessHoursSegClasses:function(){return["fc-nonbusiness","fc-bgevent"]},buildBusinessHourSegs:function(t){var i=this.view.calendar.getCurrentBusinessHourEvents(t);return!i.length&&this.view.calendar.options.businessHours&&(i=[n.extend({},pi,{start:this.view.end,end:this.view.end,dow:null})]),this.eventsToSegs(i)},bindSegHandlers:function(){this.bindSegHandlersToEl(this.el)},bindSegHandlersToEl:function(n){this.bindSegHandlerToEl(n,"touchstart",this.handleSegTouchStart);this.bindSegHandlerToEl(n,"touchend",this.handleSegTouchEnd);this.bindSegHandlerToEl(n,"mouseenter",this.handleSegMouseover);this.bindSegHandlerToEl(n,"mouseleave",this.handleSegMouseout);this.bindSegHandlerToEl(n,"mousedown",this.handleSegMousedown);this.bindSegHandlerToEl(n,"click",this.handleSegClick)},bindSegHandlerToEl:function(t,i,r){var u=this;t.on(i,this.segSelector,function(t){var i=n(this).data("fc-seg");if(i&&!u.isDraggingSeg&&!u.isResizingSeg)return r.call(u,i,t)})},handleSegClick:function(n,t){var i=this.view.trigger("eventClick",n.el[0],n.event,t);i===!1&&t.preventDefault()},handleSegMouseover:function(n,t){this.isIgnoringMouse||this.mousedOverSeg||(this.mousedOverSeg=n,this.view.isEventResizable(n.event)&&n.el.addClass("fc-allow-mouse-resize"),this.view.trigger("eventMouseover",n.el[0],n.event,t))},handleSegMouseout:function(n,t){t=t||{};this.mousedOverSeg&&(n=n||this.mousedOverSeg,this.mousedOverSeg=null,this.view.isEventResizable(n.event)&&n.el.removeClass("fc-allow-mouse-resize"),this.view.trigger("eventMouseout",n.el[0],n.event,t))},handleSegMousedown:function(n,t){var i=this.startSegResize(n,t,{distance:5});!i&&this.view.isEventDraggable(n.event)&&this.buildSegDragListener(n).startInteraction(t,{distance:5})},handleSegTouchStart:function(n,t){var i=this.view,r=n.event,u=i.isEventSelected(r),f=i.isEventDraggable(r),e=i.isEventResizable(r),o=!1,s;u&&e&&(o=this.startSegResize(n,t));!o&&(f||e)&&(s=f?this.buildSegDragListener(n):this.buildSegSelectListener(n),s.startInteraction(t,{delay:u?0:this.view.opt("longPressDelay")}));this.tempIgnoreMouse()},handleSegTouchEnd:function(){this.tempIgnoreMouse()},startSegResize:function(t,i,r){return n(i.target).is(".fc-resizer")?(this.buildSegResizeListener(t,n(i.target).is(".fc-start-resizer")).startInteraction(i,r),!0):!1},buildSegDragListener:function(n){var r=this,t=this.view,h=t.calendar,s=n.el,u=n.event,o,f,i,e;return this.segDragListener?this.segDragListener:e=this.segDragListener=new it(t,{scroll:t.opt("dragScroll"),subjectEl:s,subjectCenter:!0,interactionStart:function(i){n.component=r;o=!1;f=new eu(n.el,{additionalClass:"fc-dragging",parentEl:t.el,opacity:e.isTouch?null:t.opt("dragOpacity"),revertDuration:t.opt("dragRevertDuration"),zIndex:2});f.hide();f.start(i)},dragStart:function(i){e.isTouch&&!t.isEventSelected(u)&&t.selectEvent(u);o=!0;r.handleSegMouseout(n,i);r.segDragStart(n,i);t.hideEvent(u)},hitOver:function(o,s,c){var l;n.hit&&(c=n.hit);i=r.computeEventDrop(c.component.getHitSpan(c),o.component.getHitSpan(o),u);i&&!h.isEventSpanAllowed(r.eventToSpan(i),u)&&(ut(),i=null);i&&(l=t.renderDrag(i,n))?(l.addClass("fc-dragging"),e.isTouch||r.applyDragOpacity(l),f.hide()):f.show();s&&(i=null)},hitOut:function(){t.unrenderDrag();f.show();i=null},hitDone:function(){ft()},interactionEnd:function(e){delete n.component;f.stop(!i,function(){o&&(t.unrenderDrag(),t.showEvent(u),r.segDragStop(n,e));i&&t.reportEventDrop(u,i,this.largeUnit,s,e)});r.segDragListener=null}})},buildSegSelectListener:function(n){var u=this,t=this.view,i=n.event,r;return this.segDragListener?this.segDragListener:r=this.segDragListener=new h({dragStart:function(){r.isTouch&&!t.isEventSelected(i)&&t.selectEvent(i)},interactionEnd:function(){u.segDragListener=null}})},segDragStart:function(n,t){this.isDraggingSeg=!0;this.view.trigger("eventDragStart",n.el[0],n.event,t,{})},segDragStop:function(n,t){this.isDraggingSeg=!1;this.view.trigger("eventDragStop",n.el[0],n.event,t,{})},computeEventDrop:function(n,t,i){var e=this.view.calendar,o=n.start,u=t.start,f,r;return o.hasTime()===u.hasTime()?(f=this.diffDates(u,o),i.allDay&&k(f)?(r={start:i.start.clone(),end:e.getEventEnd(i),allDay:!1},e.normalizeEventTimes(r)):r=ou(i),r.start.add(f),r.end&&r.end.add(f)):r={start:u.clone(),end:null,allDay:!u.hasTime()},r},applyDragOpacity:function(n){var t=this.view.opt("dragOpacity");t!=null&&n.css("opacity",t)},externalDragStart:function(t,i){var f=this.view,r,u;f.opt("droppable")&&(r=n((i?i.item:null)||t.target),u=f.opt("dropAccept"),(n.isFunction(u)?u.call(r[0],r):r.is(u))&&(this.isDraggingExternal||this.listenToExternalDrag(r,t,i)))},listenToExternalDrag:function(n,t,i){var u=this,e=this.view.calendar,f=ue(n),r,o=u.externalDragListener=new it(this,{interactionStart:function(){u.isDraggingExternal=!0},hitOver:function(n){r=u.computeExternalDrop(n.component.getHitSpan(n),f);r&&!e.isExternalSpanAllowed(u.eventToSpan(r),r,f.eventProps)&&(ut(),r=null);r&&u.renderDrag(r)},hitOut:function(){r=null},hitDone:function(){ft();u.unrenderDrag()},interactionEnd:function(t){r&&u.view.reportExternalDrop(f,r,n,t,i);u.isDraggingExternal=!1;u.externalDragListener=null}});o.startDrag(t)},computeExternalDrop:function(n,t){var r=this.view.calendar,i={start:r.applyTimezone(n.start),end:null};return t.startTime&&!i.start.hasTime()&&i.start.time(t.startTime),t.duration&&(i.end=i.start.clone().add(t.duration)),i},renderDrag:function(){},unrenderDrag:function(){},buildSegResizeListener:function(n,t){var r=this,f=this.view,o=f.calendar,s=n.el,u=n.event,h=o.getEventEnd(u),e,i;return this.segResizeListener=new it(this,{scroll:f.opt("dragScroll"),subjectEl:s,interactionStart:function(){e=!1},dragStart:function(t){e=!0;r.handleSegMouseout(n,t);r.segResizeStart(n,t)},hitOver:function(e,s,c){var l=r.getHitSpan(c),a=r.getHitSpan(e);i=t?r.computeEventStartResize(l,a,u):r.computeEventEndResize(l,a,u);i&&(o.isEventSpanAllowed(r.eventToSpan(i),u)?i.start.isSame(u.start.clone().stripZone())&&i.end.isSame(h.clone().stripZone())&&(i=null):(ut(),i=null));i&&(f.hideEvent(u),r.renderEventResize(i,n))},hitOut:function(){i=null},hitDone:function(){r.unrenderEventResize();f.showEvent(u);ft()},interactionEnd:function(t){e&&r.segResizeStop(n,t);i&&f.reportEventResize(u,i,this.largeUnit,s,t);r.segResizeListener=null}})},segResizeStart:function(n,t){this.isResizingSeg=!0;this.view.trigger("eventResizeStart",n.el[0],n.event,t,{})},segResizeStop:function(n,t){this.isResizingSeg=!1;this.view.trigger("eventResizeStop",n.el[0],n.event,t,{})},computeEventStartResize:function(n,t,i){return this.computeEventResize("start",n,t,i)},computeEventEndResize:function(n,t,i){return this.computeEventResize("end",n,t,i)},computeEventResize:function(n,t,i,r){var f=this.view.calendar,o=this.diffDates(i[n],t[n]),u,e;return u={start:r.start.clone(),end:f.getEventEnd(r),allDay:r.allDay},u.allDay&&k(o)&&(u.allDay=!1,f.normalizeEventTimes(u)),u[n].add(o),u.start.isBefore(u.end)||(e=this.minResizeDuration||(r.allDay?f.defaultAllDayEventDuration:f.defaultTimedEventDuration),n=="start"?u.start=u.end.clone().subtract(e):u.end=u.start.clone().add(e)),u},renderEventResize:function(){},unrenderEventResize:function(){},getEventTimeText:function(n,t,i){return(t==null&&(t=this.eventTimeFormat),i==null&&(i=this.displayEventEnd),this.displayEventTime&&n.start.hasTime())?i&&n.end?this.view.formatRange(n,t):n.start.format(t):""},getSegClasses:function(n,t,i){var u=this.view,r=["fc-event",n.isStart?"fc-start":"fc-not-start",n.isEnd?"fc-end":"fc-not-end"].concat(this.getSegCustomClasses(n));return t&&r.push("fc-draggable"),i&&r.push("fc-resizable"),u.isEventSelected(n.event)&&r.push("fc-selected"),r},getSegCustomClasses:function(n){var t=n.event;return[].concat(t.className,t.source?t.source.className:[])},getSegSkinCss:function(n){return{"background-color":this.getSegBackgroundColor(n),"border-color":this.getSegBorderColor(n),color:this.getSegTextColor(n)}},getSegBackgroundColor:function(n){return n.event.backgroundColor||n.event.color||this.getSegDefaultBackgroundColor(n)},getSegDefaultBackgroundColor:function(n){var t=n.event.source||{};return t.backgroundColor||t.color||this.view.opt("eventBackgroundColor")||this.view.opt("eventColor")},getSegBorderColor:function(n){return n.event.borderColor||n.event.color||this.getSegDefaultBorderColor(n)},getSegDefaultBorderColor:function(n){var t=n.event.source||{};return t.borderColor||t.color||this.view.opt("eventBorderColor")||this.view.opt("eventColor")},getSegTextColor:function(n){return n.event.textColor||this.getSegDefaultTextColor(n)},getSegDefaultTextColor:function(n){var t=n.event.source||{};return t.textColor||this.view.opt("eventTextColor")},eventToSegs:function(n){return this.eventsToSegs([n])},eventToSpan:function(n){return this.eventToSpans(n)[0]},eventToSpans:function(n){var t=this.eventToRange(n);return this.eventRangeToSpans(t,n)},eventsToSegs:function(t,i){var u=this,f=ie(t),r=[];return n.each(f,function(n,t){for(var e=[],f=0;f<t.length;f++)e.push(u.eventToRange(t[f]));if(te(t[0]))for(e=u.invertRanges(e),f=0;f<e.length;f++)r.push.apply(r,u.eventRangeToSegs(e[f],t[0],i));else for(f=0;f<e.length;f++)r.push.apply(r,u.eventRangeToSegs(e[f],t[f],i))}),r},eventToRange:function(n){var t=this.view.calendar,i=n.start.clone().stripZone(),r=(n.end?n.end.clone():t.getDefaultEventEnd(n.allDay!=null?n.allDay:!n.start.hasTime(),n.start)).stripZone();return t.localizeMoment(i),t.localizeMoment(r),{start:i,end:r}},eventRangeToSegs:function(n,t,i){for(var f=this.eventRangeToSpans(n,t),u=[],r=0;r<f.length;r++)u.push.apply(u,this.eventSpanToSegs(f[r],t,i));return u},eventRangeToSpans:function(t){return[n.extend({},t)]},eventSpanToSegs:function(n,t,i){for(var f=i?i(n):this.spanToSegs(n),u,r=0;r<f.length;r++)u=f[r],u.event=t,u.eventStartMS=+n.start,u.eventDurationMS=n.end-n.start;return f},invertRanges:function(n){var f=this.view,o=f.start.clone(),e=f.end.clone(),u=[],t=o,i,r;for(n.sort(re),i=0;i<n.length;i++)r=n[i],r.start>t&&u.push({start:t,end:r.start}),t=r.end;return t<e&&u.push({start:t,end:e}),u},sortEventSegs:function(n){n.sort(d(this,"compareEventSegs"))},compareEventSegs:function(n,t){return n.eventStartMS-t.eventStartMS||t.eventDurationMS-n.eventDurationMS||t.event.allDay-n.event.allDay||or(n.event,t.event,this.view.eventOrderSpecs)}});i.pluckEventDateProps=ou;i.isBgEvent=su;i.dataAttrPrefix="";ai=i.DayTableMixin={breakOnWeeks:!1,dayDates:null,dayIndices:null,daysPerRow:null,rowCnt:null,colCnt:null,colHeadFormat:null,updateDayTable:function(){for(var o=this.view,i=this.start.clone(),r=-1,u=[],n=[],t,e,f;i.isBefore(this.end);)o.isHiddenDay(i)?u.push(r+.5):(r++,u.push(r),n.push(i.clone())),i.add(1,"days");if(this.breakOnWeeks){for(e=n[0].day(),t=1;t<n.length;t++)if(n[t].day()==e)break;f=Math.ceil(n.length/t)}else f=1,t=n.length;this.dayDates=n;this.dayIndices=u;this.daysPerRow=t;this.rowCnt=f;this.updateDayTableCols()},updateDayTableCols:function(){this.colCnt=this.computeColCnt();this.colHeadFormat=this.view.opt("columnFormat")||this.computeColHeadFormat()},computeColCnt:function(){return this.daysPerRow},getCellDate:function(n,t){return this.dayDates[this.getCellDayIndex(n,t)].clone()},getCellRange:function(n,t){var i=this.getCellDate(n,t),r=i.clone().add(1,"days");return{start:i,end:r}},getCellDayIndex:function(n,t){return n*this.daysPerRow+this.getColDayIndex(t)},getColDayIndex:function(n){return this.isRTL?this.colCnt-1-n:n},getDateDayIndex:function(n){var t=this.dayIndices,i=n.diff(this.start,"days");return i<0?t[0]-1:i>=t.length?t[t.length-1]+1:t[i]},computeColHeadFormat:function(){return this.rowCnt>1||this.colCnt>10?"ddd":this.colCnt>1?this.view.opt("dayOfMonthFormat"):"dddd"},sliceRangeByRow:function(n){for(var f=this.daysPerRow,e=this.view.computeDayRange(n),o=this.getDateDayIndex(e.start),s=this.getDateDayIndex(e.end.clone().subtract(1,"days")),h=[],u,c,t,i,r=0;r<this.rowCnt;r++)u=r*f,c=u+f-1,t=Math.max(o,u),i=Math.min(s,c),t=Math.ceil(t),i=Math.floor(i),t<=i&&h.push({row:r,firstRowDayIndex:t-u,lastRowDayIndex:i-u,isStart:t===o,isEnd:i===s});return h},sliceRangeByDay:function(n){for(var e=this.daysPerRow,o=this.view.computeDayRange(n),s=this.getDateDayIndex(o.start),h=this.getDateDayIndex(o.end.clone().subtract(1,"days")),c=[],u,l,f,t,i,r=0;r<this.rowCnt;r++)for(u=r*e,l=u+e-1,f=u;f<=l;f++)t=Math.max(s,f),i=Math.min(h,f),t=Math.ceil(t),i=Math.floor(i),t<=i&&c.push({row:r,firstRowDayIndex:t-u,lastRowDayIndex:i-u,isStart:t===s,isEnd:i===h});return c},renderHeadHtml:function(){var n=this.view;return'<div class="fc-row '+n.widgetHeaderClass+'"><table><thead>'+this.renderHeadTrHtml()+"<\/thead><\/table><\/div>"},renderHeadIntroHtml:function(){return this.renderIntroHtml()},renderHeadTrHtml:function(){return"<tr>"+(this.isRTL?"":this.renderHeadIntroHtml())+this.renderHeadDateCellsHtml()+(this.isRTL?this.renderHeadIntroHtml():"")+"<\/tr>"},renderHeadDateCellsHtml:function(){for(var t=[],i,n=0;n<this.colCnt;n++)i=this.getCellDate(0,n),t.push(this.renderHeadDateCellHtml(i));return t.join("")},renderHeadDateCellHtml:function(n,t,i){var u=this.view;return'<th class="fc-day-header '+u.widgetHeaderClass+" fc-"+ni[n.day()]+'"'+(this.rowCnt===1?' data-date="'+n.format("YYYY-MM-DD")+'"':"")+(t>1?' colspan="'+t+'"':"")+(i?" "+i:"")+">"+u.buildGotoAnchorHtml({date:n,forceOff:this.rowCnt>1||this.colCnt===1},r(n.format(this.colHeadFormat)))+"<\/th>"},renderBgTrHtml:function(n){return"<tr>"+(this.isRTL?"":this.renderBgIntroHtml(n))+this.renderBgCellsHtml(n)+(this.isRTL?this.renderBgIntroHtml(n):"")+"<\/tr>"},renderBgIntroHtml:function(){return this.renderIntroHtml()},renderBgCellsHtml:function(n){for(var i=[],r,t=0;t<this.colCnt;t++)r=this.getCellDate(n,t),i.push(this.renderBgCellHtml(r));return i.join("")},renderBgCellHtml:function(n,t){var r=this.view,i=this.getDayClasses(n);return i.unshift("fc-day",r.widgetContentClass),'<td class="'+i.join(" ")+'" data-date="'+n.format("YYYY-MM-DD")+'"'+(t?" "+t:"")+"><\/td>"},renderIntroHtml:function(){},bookendCells:function(n){var t=this.renderIntroHtml();t&&(this.isRTL?n.append(t):n.prepend(t))}};rt=i.DayGrid=c.extend(ai,{numbersVisible:!1,bottomCoordPadding:0,rowEls:null,cellEls:null,helperEls:null,rowCoordCache:null,colCoordCache:null,renderDates:function(n){for(var f=this.view,r=this.rowCnt,e=this.colCnt,u="",i,t=0;t<r;t++)u+=this.renderDayRowHtml(t,n);for(this.el.html(u),this.rowEls=this.el.find(".fc-row"),this.cellEls=this.el.find(".fc-day"),this.rowCoordCache=new pt({els:this.rowEls,isVertical:!0}),this.colCoordCache=new pt({els:this.cellEls.slice(0,this.colCnt),isHorizontal:!0}),t=0;t<r;t++)for(i=0;i<e;i++)f.trigger("dayRender",null,this.getCellDate(t,i),this.getCellEl(t,i))},unrenderDates:function(){this.removeSegPopover()},renderBusinessHours:function(){var n=this.buildBusinessHourSegs(!0);this.renderFill("businessHours",n,"bgevent")},unrenderBusinessHours:function(){this.unrenderFill("businessHours")},renderDayRowHtml:function(n,t){var r=this.view,i=["fc-row","fc-week",r.widgetContentClass];return t&&i.push("fc-rigid"),'<div class="'+i.join(" ")+'"><div class="fc-bg"><table>'+this.renderBgTrHtml(n)+'<\/table><\/div><div class="fc-content-skeleton"><table>'+(this.numbersVisible?"<thead>"+this.renderNumberTrHtml(n)+"<\/thead>":"")+"<\/table><\/div><\/div>"},renderNumberTrHtml:function(n){return"<tr>"+(this.isRTL?"":this.renderNumberIntroHtml(n))+this.renderNumberCellsHtml(n)+(this.isRTL?this.renderNumberIntroHtml(n):"")+"<\/tr>"},renderNumberIntroHtml:function(){return this.renderIntroHtml()},renderNumberCellsHtml:function(n){for(var i=[],r,t=0;t<this.colCnt;t++)r=this.getCellDate(n,t),i.push(this.renderNumberCellHtml(r));return i.join("")},renderNumberCellHtml:function(n){var t="",i,r;return!this.view.dayNumbersVisible&&!this.view.cellWeekNumbersVisible?"<td/>":(i=this.getDayClasses(n),i.unshift("fc-day-top"),this.view.cellWeekNumbersVisible&&(r=n._locale._fullCalendar_weekCalc==="ISO"?1:n._locale.firstDayOfWeek()),t+='<td class="'+i.join(" ")+'" data-date="'+n.format()+'">',this.view.cellWeekNumbersVisible&&n.day()==r&&(t+=this.view.buildGotoAnchorHtml({date:n,type:"week"},{"class":"fc-week-number"},n.format("w"))),this.view.dayNumbersVisible&&(t+=this.view.buildGotoAnchorHtml(n,{"class":"fc-day-number"},n.date())),t+"<\/td>")},computeEventTimeFormat:function(){return this.view.opt("extraSmallTimeFormat")},computeDisplayEventEnd:function(){return this.colCnt==1},rangeUpdated:function(){this.updateDayTable()},spanToSegs:function(n){for(var r=this.sliceRangeByRow(n),t,i=0;i<r.length;i++)t=r[i],this.isRTL?(t.leftCol=this.daysPerRow-1-t.lastRowDayIndex,t.rightCol=this.daysPerRow-1-t.firstRowDayIndex):(t.leftCol=t.firstRowDayIndex,t.rightCol=t.lastRowDayIndex);return r},prepareHits:function(){this.colCoordCache.build();this.rowCoordCache.build();this.rowCoordCache.bottoms[this.rowCnt-1]+=this.bottomCoordPadding},releaseHits:function(){this.colCoordCache.clear();this.rowCoordCache.clear()},queryHit:function(n,t){if(this.colCoordCache.isLeftInBounds(n)&&this.rowCoordCache.isTopInBounds(t)){var i=this.colCoordCache.getHorizontalIndex(n),r=this.rowCoordCache.getVerticalIndex(t);if(r!=null&&i!=null)return this.getCellHit(r,i)}},getHitSpan:function(n){return this.getCellRange(n.row,n.col)},getHitEl:function(n){return this.getCellEl(n.row,n.col)},getCellHit:function(n,t){return{row:n,col:t,component:this,left:this.colCoordCache.getLeftOffset(t),right:this.colCoordCache.getRightOffset(t),top:this.rowCoordCache.getTopOffset(n),bottom:this.rowCoordCache.getBottomOffset(n)}},getCellEl:function(n,t){return this.cellEls.eq(n*this.colCnt+t)},renderDrag:function(n,t){return this.renderHighlight(this.eventToSpan(n)),t&&t.component!==this?this.renderEventLocationHelper(n,t):void 0},unrenderDrag:function(){this.unrenderHighlight();this.unrenderHelper()},renderEventResize:function(n,t){return this.renderHighlight(this.eventToSpan(n)),this.renderEventLocationHelper(n,t)},unrenderEventResize:function(){this.unrenderHighlight();this.unrenderHelper()},renderHelper:function(t,i){var u=[],r=this.eventToSegs(t),f;return r=this.renderFgSegEls(r),f=this.renderSegRows(r),this.rowEls.each(function(t,r){var o=n(r),e=n('<div class="fc-helper-skeleton"><table/><\/div>'),s;s=i&&i.row===t?i.el.position().top:o.find(".fc-content-skeleton tbody").position().top;e.css("top",s).find("table").append(f[t].tbodyEl);o.append(e);u.push(e[0])}),this.helperEls=n(u)},unrenderHelper:function(){this.helperEls&&(this.helperEls.remove(),this.helperEls=null)},fillSegTag:"td",renderFill:function(t,i,r){var o=[],u,f,e;for(i=this.renderFillSegEls(t,i),u=0;u<i.length;u++)f=i[u],e=this.renderFillRow(t,f,r),this.rowEls.eq(f.row).append(e),o.push(e[0]);return this.elsByFill[t]=n(o),i},renderFillRow:function(t,i,r){var s=this.colCnt,f=i.leftCol,e=i.rightCol+1,o,u;return r=r||t.toLowerCase(),o=n('<div class="fc-'+r+'-skeleton"><table><tr/><\/table><\/div>'),u=o.find("tr"),f>0&&u.append('<td colspan="'+f+'"/>'),u.append(i.el.attr("colspan",e-f)),e<s&&u.append('<td colspan="'+(s-e)+'"/>'),this.bookendCells(u),o}});rt.mixin({rowStructs:null,unrenderEvents:function(){this.removeSegPopover();c.prototype.unrenderEvents.apply(this,arguments)},getEventSegs:function(){return c.prototype.getEventSegs.call(this).concat(this.popoverSegs||[])},renderBgSegs:function(t){var i=n.grep(t,function(n){return n.event.allDay});return c.prototype.renderBgSegs.call(this,i)},renderFgSegs:function(t){var i;return t=this.renderFgSegEls(t),i=this.rowStructs=this.renderSegRows(t),this.rowEls.each(function(t,r){n(r).find(".fc-content-skeleton > table").append(i[t].tbodyEl)}),t},unrenderFgSegs:function(){for(var t=this.rowStructs||[],n;n=t.pop();)n.tbodyEl.remove();this.rowStructs=null},renderSegRows:function(n){for(var r=[],i=this.groupSegRows(n),t=0;t<i.length;t++)r.push(this.renderSegRow(t,i[t]));return r},fgSegHtml:function(n,t){var u=this.view,i=n.event,a=u.isEventDraggable(i),s=!t&&i.allDay&&n.isStart&&u.isEventResizableFromStart(i),h=!t&&i.allDay&&n.isEnd&&u.isEventResizableFromEnd(i),c=this.getSegClasses(n,a,s||h),l=at(this.getSegSkinCss(n)),f="",e,o;return c.unshift("fc-day-grid-event","fc-h-event"),n.isStart&&(e=this.getEventTimeText(i),e&&(f='<span class="fc-time">'+r(e)+"<\/span>")),o='<span class="fc-title">'+(r(i.title||"")||"&nbsp;")+"<\/span>",'<a class="'+c.join(" ")+'"'+(i.url?' href="'+r(i.url)+'"':"")+(l?' style="'+l+'"':"")+'><div class="fc-content">'+(this.isRTL?o+" "+f:f+" "+o)+"<\/div>"+(s?'<div class="fc-resizer fc-start-resizer" />':"")+(h?'<div class="fc-resizer fc-end-resizer" />':"")+"<\/a>"},renderSegRow:function(t,i){function p(t){while(u<t)r=(h[f-1]||[])[u],r?r.attr("rowspan",parseInt(r.attr("rowspan")||1,10)+1):(r=n("<td/>"),o.append(r)),s[f][u]=r,h[f][u]=r,u++}for(var w=this.colCnt,a=this.buildSegLevels(i),b=Math.max(1,a.length),y=n("<tbody/>"),v=[],s=[],h=[],c,u,o,l,e,r,f=0;f<b;f++){if(c=a[f],u=0,o=n("<tr/>"),v.push([]),s.push([]),h.push([]),c)for(l=0;l<c.length;l++){for(e=c[l],p(e.leftCol),r=n('<td class="fc-event-container"/>').append(e.el),e.leftCol!=e.rightCol?r.attr("colspan",e.rightCol-e.leftCol+1):h[f][u]=r;u<=e.rightCol;)s[f][u]=r,v[f][u]=e,u++;o.append(r)}p(w);this.bookendCells(o);y.append(o)}return{row:t,tbodyEl:y,cellMatrix:s,segMatrix:v,segLevels:a,segs:i}},buildSegLevels:function(n){var i=[],r,u,t;for(this.sortEventSegs(n),r=0;r<n.length;r++){for(u=n[r],t=0;t<i.length;t++)if(!fe(u,i[t]))break;u.level=t;(i[t]||(i[t]=[])).push(u)}for(t=0;t<i.length;t++)i[t].sort(ee);return i},groupSegRows:function(n){for(var i=[],t=0;t<this.rowCnt;t++)i.push([]);for(t=0;t<n.length;t++)i[n[t].row].push(n[t]);return i}});rt.mixin({segPopover:null,popoverSegs:null,removeSegPopover:function(){this.segPopover&&this.segPopover.hide()},limitRows:function(n){for(var r=this.rowStructs||[],i,t=0;t<r.length;t++)this.unlimitRow(t),i=n?typeof n=="number"?n:this.computeRowLevelLimit(t):!1,i!==!1&&this.limitRow(t,i)},computeRowLevelLimit:function(t){function s(t,i){r=Math.max(r,n(i).outerHeight())}for(var e=this.rowEls.eq(t),o=e.height(),f=this.rowStructs[t].tbodyEl.children(),u,r,i=0;i<f.length;i++)if(u=f.eq(i).removeClass("fc-limited"),r=0,u.find("> td > :first-child").each(s),u.position().top+r>o)return i;return!1},limitRow:function(t,i){function tt(f){while(r<f)u=g.getCellSegs(t,r,i),u.length&&(o=w[i-1][r],v=g.renderMoreLink(t,r,u),h=n("<div/>").append(v),o.append(h),y.push(h[0])),r++}var g=this,f=this.rowStructs[t],y=[],r=0,p,w,b,c,e,u,k,l,o,nt,d,s,a,h,v;if(i&&i<f.segLevels.length){for(p=f.segLevels[i-1],w=f.cellMatrix,b=f.tbodyEl.children().slice(i).addClass("fc-limited").get(),c=0;c<p.length;c++){for(e=p[c],tt(e.leftCol),l=[],k=0;r<=e.rightCol;)u=this.getCellSegs(t,r,i),l.push(u),k+=u.length,r++;if(k){for(o=w[i-1][e.leftCol],nt=o.attr("rowspan")||1,d=[],s=0;s<l.length;s++)a=n('<td class="fc-more-cell"/>').attr("rowspan",nt),u=l[s],v=this.renderMoreLink(t,e.leftCol+s,[e].concat(u)),h=n("<div/>").append(v),a.append(h),d.push(a[0]),y.push(a[0]);o.addClass("fc-limited").after(n(d));b.push(o[0])}}tt(this.colCnt);f.moreEls=n(y);f.limitedEls=n(b)}},unlimitRow:function(n){var t=this.rowStructs[n];t.moreEls&&(t.moreEls.remove(),t.moreEls=null);t.limitedEls&&(t.limitedEls.removeClass("fc-limited"),t.limitedEls=null)},renderMoreLink:function(t,i,r){var u=this,f=this.view;return n('<a class="fc-more"/>').text(this.getMoreLinkText(r.length)).on("click",function(e){var o=f.opt("eventLimitClick"),s=u.getCellDate(t,i),h=n(this),l=u.getCellEl(t,i),a=u.getCellSegs(t,i),c=u.resliceDaySegs(a,s),v=u.resliceDaySegs(r,s);typeof o=="function"&&(o=f.trigger("eventLimitClick",null,{date:s,dayEl:l,moreEl:h,segs:c,hiddenSegs:v},e));o==="popover"?u.showSegPopover(t,i,h,c):typeof o=="string"&&f.calendar.zoomTo(s,o)})},showSegPopover:function(n,t,i,r){var f=this,o=this.view,e=i.parent(),s,u;s=this.rowCnt==1?o.el:this.rowEls.eq(n);u={className:"fc-more-popover",content:this.renderSegPopoverContent(n,t,r),parentEl:this.view.el,top:s.offset().top,autoHide:!0,viewportConstrain:o.opt("popoverViewportConstrain"),hide:function(){f.segPopover.removeElement();f.segPopover=null;f.popoverSegs=null}};this.isRTL?u.right=e.offset().left+e.outerWidth()+1:u.left=e.offset().left-1;this.segPopover=new ne(u);this.segPopover.show();this.bindSegHandlersToEl(this.segPopover.el)},renderSegPopoverContent:function(t,i,u){var e=this.view,s=e.opt("theme"),h=this.getCellDate(t,i).format(e.opt("dayPopoverFormat")),o=n('<div class="fc-header '+e.widgetHeaderClass+'"><span class="fc-close '+(s?"ui-icon ui-icon-closethick":"fc-icon fc-icon-x")+'"><\/span><span class="fc-title">'+r(h)+'<\/span><div class="fc-clear"/><\/div><div class="fc-body '+e.widgetContentClass+'"><div class="fc-event-container"><\/div><\/div>'),c=o.find(".fc-event-container"),f;for(u=this.renderFgSegEls(u,!0),this.popoverSegs=u,f=0;f<u.length;f++)this.prepareHits(),u[f].hit=this.getCellHit(t,i),this.releaseHits(),c.append(u[f].el);return o},resliceDaySegs:function(t,i){var u=n.map(t,function(n){return n.event}),r=i.clone(),f=r.clone().add(1,"days"),e={start:r,end:f};return t=this.eventsToSegs(u,function(n){var t=st(n,e);return t?[t]:[]}),this.sortEventSegs(t),t},getMoreLinkText:function(n){var t=this.view.opt("eventLimitText");return typeof t=="function"?t(n):"+"+n+" "+t},getCellSegs:function(n,t,i){for(var f=this.rowStructs[n].segMatrix,r=i||0,e=[],u;r<f.length;)u=f[r][t],u&&e.push(u),r++;return e}});vi=i.TimeGrid=c.extend(ai,{slotDuration:null,snapDuration:null,snapsPerSlot:null,minTime:null,maxTime:null,labelFormat:null,labelInterval:null,colEls:null,slatContainerEl:null,slatEls:null,nowIndicatorEls:null,colCoordCache:null,slatCoordCache:null,constructor:function(){c.apply(this,arguments);this.processOptions()},renderDates:function(){this.el.html(this.renderHtml());this.colEls=this.el.find(".fc-day");this.slatContainerEl=this.el.find(".fc-slats");this.slatEls=this.slatContainerEl.find("tr");this.colCoordCache=new pt({els:this.colEls,isHorizontal:!0});this.slatCoordCache=new pt({els:this.slatEls,isVertical:!0});this.renderContentSkeleton()},renderHtml:function(){return'<div class="fc-bg"><table>'+this.renderBgTrHtml(0)+'<\/table><\/div><div class="fc-slats"><table>'+this.renderSlatRowHtml()+"<\/table><\/div>"},renderSlatRowHtml:function(){for(var i=this.view,o=this.isRTL,s="",n=t.duration(+this.minTime),u,f,e;n<this.maxTime;)u=this.start.clone().time(n),f=y(ii(n,this.labelInterval)),e='<td class="fc-axis fc-time '+i.widgetContentClass+'" '+i.axisStyleAttr()+">"+(f?"<span>"+r(u.format(this.labelFormat))+"<\/span>":"")+"<\/td>",s+='<tr data-time="'+u.format("HH:mm:ss")+'"'+(f?"":' class="fc-minor"')+">"+(o?"":e)+'<td class="'+i.widgetContentClass+'"/>'+(o?e:"")+"<\/tr>",n.add(this.slotDuration);return s},processOptions:function(){var r=this.view,u=r.opt("slotDuration"),f=r.opt("snapDuration"),i;u=t.duration(u);f=f?t.duration(f):u;this.slotDuration=u;this.snapDuration=f;this.snapsPerSlot=u/f;this.minResizeDuration=f;this.minTime=t.duration(r.opt("minTime"));this.maxTime=t.duration(r.opt("maxTime"));i=r.opt("slotLabelFormat");n.isArray(i)&&(i=i[i.length-1]);this.labelFormat=i||r.opt("smallTimeFormat");i=r.opt("slotLabelInterval");this.labelInterval=i?t.duration(i):this.computeLabelInterval(u)},computeLabelInterval:function(n){for(var r,u,i=wu.length-1;i>=0;i--)if(r=t.duration(wu[i]),u=ii(r,n),y(u)&&u>1)return r;return t.duration(n)},computeEventTimeFormat:function(){return this.view.opt("noMeridiemTimeFormat")},computeDisplayEventEnd:function(){return!0},prepareHits:function(){this.colCoordCache.build();this.slatCoordCache.build()},releaseHits:function(){this.colCoordCache.clear()},queryHit:function(n,t){var u=this.snapsPerSlot,f=this.colCoordCache,e=this.slatCoordCache,i,r;if(f.isLeftInBounds(n)&&e.isTopInBounds(t)&&(i=f.getHorizontalIndex(n),r=e.getVerticalIndex(t),i!=null&&r!=null)){var o=e.getTopOffset(r),s=e.getHeight(r),c=(t-o)/s,h=Math.floor(c*u),l=r*u+h,a=o+h/u*s,v=o+(h+1)/u*s;return{col:i,snap:l,component:this,left:f.getLeftOffset(i),right:f.getRightOffset(i),top:a,bottom:v}}},getHitSpan:function(n){var t=this.getCellDate(0,n.col),r=this.computeSnapTime(n.snap),i;return t.time(r),i=t.clone().add(this.snapDuration),{start:t,end:i}},getHitEl:function(n){return this.colEls.eq(n.col)},rangeUpdated:function(){this.updateDayTable()},computeSnapTime:function(n){return t.duration(this.minTime+this.snapDuration*n)},spanToSegs:function(n){for(var i=this.sliceRangeByTimes(n),t=0;t<i.length;t++)i[t].col=this.isRTL?this.daysPerRow-1-i[t].dayIndex:i[t].dayIndex;return i},sliceRangeByTimes:function(n){for(var u=[],i,r,f,t=0;t<this.daysPerRow;t++)r=this.dayDates[t].clone(),f={start:r.clone().time(this.minTime),end:r.clone().time(this.maxTime)},i=st(n,f),i&&(i.dayIndex=t,u.push(i));return u},updateSize:function(n){this.slatCoordCache.build();n&&this.updateSegVerticals([].concat(this.fgSegs||[],this.bgSegs||[],this.businessSegs||[]))},getTotalSlatHeight:function(){return this.slatContainerEl.outerHeight()},computeDateTop:function(n,i){return this.computeTimeTop(t.duration(n-i.clone().stripTime()))},computeTimeTop:function(n){var r=this.slatEls.length,t=(n-this.minTime)/this.slotDuration,i,u;return t=Math.max(0,t),t=Math.min(r,t),i=Math.floor(t),i=Math.min(i,r-1),u=t-i,this.slatCoordCache.getTopPosition(i)+this.slatCoordCache.getHeight(i)*u},renderDrag:function(n,t){if(t)return this.renderEventLocationHelper(n,t);this.renderHighlight(this.eventToSpan(n))},unrenderDrag:function(){this.unrenderHelper();this.unrenderHighlight()},renderEventResize:function(n,t){return this.renderEventLocationHelper(n,t)},unrenderEventResize:function(){this.unrenderHelper()},renderHelper:function(n,t){return this.renderHelperSegs(this.eventToSegs(n),t)},unrenderHelper:function(){this.unrenderHelperSegs()},renderBusinessHours:function(){this.renderBusinessSegs(this.buildBusinessHourSegs())},unrenderBusinessHours:function(){this.unrenderBusinessSegs()},getNowIndicatorUnit:function(){return"minute"},renderNowIndicator:function(t){for(var r=this.spanToSegs({start:t,end:t}),f=this.computeDateTop(t,t),u=[],i=0;i<r.length;i++)u.push(n('<div class="fc-now-indicator fc-now-indicator-line"><\/div>').css("top",f).appendTo(this.colContainerEls.eq(r[i].col))[0]);r.length>0&&u.push(n('<div class="fc-now-indicator fc-now-indicator-arrow"><\/div>').css("top",f).appendTo(this.el.find(".fc-content-skeleton"))[0]);this.nowIndicatorEls=n(u)},unrenderNowIndicator:function(){this.nowIndicatorEls&&(this.nowIndicatorEls.remove(),this.nowIndicatorEls=null)},renderSelection:function(n){this.view.opt("selectHelper")?this.renderEventLocationHelper(n):this.renderHighlight(n)},unrenderSelection:function(){this.unrenderHelper();this.unrenderHighlight()},renderHighlight:function(n){this.renderHighlightSegs(this.spanToSegs(n))},unrenderHighlight:function(){this.unrenderHighlightSegs()}});vi.mixin({colContainerEls:null,fgContainerEls:null,bgContainerEls:null,helperContainerEls:null,highlightContainerEls:null,businessContainerEls:null,fgSegs:null,bgSegs:null,helperSegs:null,highlightSegs:null,businessSegs:null,renderContentSkeleton:function(){for(var r="",t,i=0;i<this.colCnt;i++)r+='<td><div class="fc-content-col"><div class="fc-event-container fc-helper-container"><\/div><div class="fc-event-container"><\/div><div class="fc-highlight-container"><\/div><div class="fc-bgevent-container"><\/div><div class="fc-business-container"><\/div><\/div><\/td>';t=n('<div class="fc-content-skeleton"><table><tr>'+r+"<\/tr><\/table><\/div>");this.colContainerEls=t.find(".fc-content-col");this.helperContainerEls=t.find(".fc-helper-container");this.fgContainerEls=t.find(".fc-event-container:not(.fc-helper-container)");this.bgContainerEls=t.find(".fc-bgevent-container");this.highlightContainerEls=t.find(".fc-highlight-container");this.businessContainerEls=t.find(".fc-business-container");this.bookendCells(t.find("tr"));this.el.append(t)},renderFgSegs:function(n){return n=this.renderFgSegsIntoContainers(n,this.fgContainerEls),this.fgSegs=n,n},unrenderFgSegs:function(){this.unrenderNamedSegs("fgSegs")},renderHelperSegs:function(t,i){var e=[],u,f,r;for(t=this.renderFgSegsIntoContainers(t,this.helperContainerEls),u=0;u<t.length;u++)f=t[u],i&&i.col===f.col&&(r=i.el,f.el.css({left:r.css("left"),right:r.css("right"),"margin-left":r.css("margin-left"),"margin-right":r.css("margin-right")})),e.push(f.el[0]);return this.helperSegs=t,n(e)},unrenderHelperSegs:function(){this.unrenderNamedSegs("helperSegs")},renderBgSegs:function(n){return n=this.renderFillSegEls("bgEvent",n),this.updateSegVerticals(n),this.attachSegsByCol(this.groupSegsByCol(n),this.bgContainerEls),this.bgSegs=n,n},unrenderBgSegs:function(){this.unrenderNamedSegs("bgSegs")},renderHighlightSegs:function(n){n=this.renderFillSegEls("highlight",n);this.updateSegVerticals(n);this.attachSegsByCol(this.groupSegsByCol(n),this.highlightContainerEls);this.highlightSegs=n},unrenderHighlightSegs:function(){this.unrenderNamedSegs("highlightSegs")},renderBusinessSegs:function(n){n=this.renderFillSegEls("businessHours",n);this.updateSegVerticals(n);this.attachSegsByCol(this.groupSegsByCol(n),this.businessContainerEls);this.businessSegs=n},unrenderBusinessSegs:function(){this.unrenderNamedSegs("businessSegs")},groupSegsByCol:function(n){for(var i=[],t=0;t<this.colCnt;t++)i.push([]);for(t=0;t<n.length;t++)i[n[t].col].push(n[t]);return i},attachSegsByCol:function(n,t){for(var u,r,i=0;i<this.colCnt;i++)for(u=n[i],r=0;r<u.length;r++)t.eq(i).append(u[r].el)},unrenderNamedSegs:function(n){var i=this[n],t;if(i){for(t=0;t<i.length;t++)i[t].el.remove();this[n]=null}},renderFgSegsIntoContainers:function(n,t){var r,i;for(n=this.renderFgSegEls(n),r=this.groupSegsByCol(n),i=0;i<this.colCnt;i++)this.updateFgSegCoords(r[i]);return this.attachSegsByCol(r,t),n},fgSegHtml:function(n,t){var u=this.view,i=n.event,l=u.isEventDraggable(i),a=!t&&n.isStart&&u.isEventResizableFromStart(i),s=!t&&n.isEnd&&u.isEventResizableFromEnd(i),h=this.getSegClasses(n,l,a||s),c=at(this.getSegSkinCss(n)),f,e,o;return h.unshift("fc-time-grid-event","fc-v-event"),u.isMultiDayEvent(i)?(n.isStart||n.isEnd)&&(f=this.getEventTimeText(n),e=this.getEventTimeText(n,"LT"),o=this.getEventTimeText(n,null,!1)):(f=this.getEventTimeText(i),e=this.getEventTimeText(i,"LT"),o=this.getEventTimeText(i,null,!1)),'<a class="'+h.join(" ")+'"'+(i.url?' href="'+r(i.url)+'"':"")+(c?' style="'+c+'"':"")+'><div class="fc-content">'+(f?'<div class="fc-time" data-start="'+r(o)+'" data-full="'+r(e)+'"><span>'+r(f)+"<\/span><\/div>":"")+(i.title?'<div class="fc-title">'+r(i.title)+"<\/div>":"")+'<\/div><div class="fc-bg"/>'+(s?'<div class="fc-resizer fc-end-resizer" />':"")+"<\/a>"},updateSegVerticals:function(n){this.computeSegVerticals(n);this.assignSegVerticals(n)},computeSegVerticals:function(n){for(var t,i=0;i<n.length;i++)t=n[i],t.top=this.computeDateTop(t.start,t.start),t.bottom=this.computeDateTop(t.end,t.start)},assignSegVerticals:function(n){for(var i,t=0;t<n.length;t++)i=n[t],i.el.css(this.generateSegVerticalCss(i))},generateSegVerticalCss:function(n){return{top:n.top,bottom:-n.bottom}},updateFgSegCoords:function(n){this.computeSegVerticals(n);this.computeFgSegHorizontals(n);this.assignSegVerticals(n);this.assignFgSegHorizontals(n)},computeFgSegHorizontals:function(n){var r,i,t;if(this.sortEventSegs(n),r=oe(n),se(r),i=r[0]){for(t=0;t<i.length;t++)cu(i[t]);for(t=0;t<i.length;t++)this.computeFgSegForwardBack(i[t],0,0)}},computeFgSegForwardBack:function(n,t,i){var r=n.forwardSegs,u;if(n.forwardCoord===undefined)for(r.length?(this.sortForwardSegs(r),this.computeFgSegForwardBack(r[0],t+1,i),n.forwardCoord=r[0].backwardCoord):n.forwardCoord=1,n.backwardCoord=n.forwardCoord-(n.forwardCoord-i)/(t+1),u=0;u<r.length;u++)this.computeFgSegForwardBack(r[u],0,n.forwardCoord)},sortForwardSegs:function(n){n.sort(d(this,"compareForwardSegs"))},compareForwardSegs:function(n,t){return t.forwardPressure-n.forwardPressure||(n.backwardCoord||0)-(t.backwardCoord||0)||this.compareEventSegs(n,t)},assignFgSegHorizontals:function(n){for(var t,i=0;i<n.length;i++)t=n[i],t.el.css(this.generateFgSegHorizontalCss(t)),t.bottom-t.top<30&&t.el.addClass("fc-short")},generateFgSegHorizontalCss:function(n){var e=this.view.opt("slotEventOverlap"),i=n.backwardCoord,r=n.forwardCoord,t=this.generateSegVerticalCss(n),u,f;return e&&(r=Math.min(1,i+(r-i)*2)),this.isRTL?(u=1-r,f=i):(u=i,f=1-r),t.zIndex=n.level+1,t.left=u*100+"%",t.right=f*100+"%",e&&n.forwardPressure&&(t[this.isRTL?"marginLeft":"marginRight"]=20),t}});var w=i.View=s.extend(iu,tt,{type:null,name:null,title:null,calendar:null,options:null,el:null,displaying:null,isSkeletonRendered:!1,isEventsRendered:!1,start:null,end:null,intervalStart:null,intervalEnd:null,intervalDuration:null,intervalUnit:null,isRTL:!1,isSelected:!1,selectedEvent:null,eventOrderSpecs:null,widgetHeaderClass:null,widgetContentClass:null,highlightStateClass:null,nextDayThreshold:null,isHiddenDayHash:null,isNowIndicatorRendered:null,initialNowDate:null,initialNowQueriedMs:null,nowIndicatorTimeoutID:null,nowIndicatorIntervalID:null,constructor:function(n,i,r,u){this.calendar=n;this.type=this.name=i;this.options=r;this.intervalDuration=u||t.duration(1,"day");this.nextDayThreshold=t.duration(this.opt("nextDayThreshold"));this.initThemingProps();this.initHiddenDays();this.isRTL=this.opt("isRTL");this.eventOrderSpecs=er(this.opt("eventOrder"));this.initialize()},initialize:function(){},opt:function(n){return this.options[n]},trigger:function(n,t){var i=this.calendar;return i.trigger.apply(i,[n,t||this].concat(Array.prototype.slice.call(arguments,2),[this]))},setDate:function(n){this.setRange(this.computeRange(n))},setRange:function(t){n.extend(this,t);this.updateTitle()},computeRange:function(n){var f=ti(this.intervalDuration),t=n.clone().startOf(f),i=t.clone().add(this.intervalDuration),r,u;return/year|month|week|day/.test(f)?(t.stripTime(),i.stripTime()):(t.hasTime()||(t=this.calendar.time(0)),i.hasTime()||(i=this.calendar.time(0))),r=t.clone(),r=this.skipHiddenDays(r),u=i.clone(),u=this.skipHiddenDays(u,-1,!0),{intervalUnit:f,intervalStart:t,intervalEnd:i,start:r,end:u}},computePrevDate:function(n){return this.massageCurrentDate(n.clone().startOf(this.intervalUnit).subtract(this.intervalDuration),-1)},computeNextDate:function(n){return this.massageCurrentDate(n.clone().startOf(this.intervalUnit).add(this.intervalDuration))},massageCurrentDate:function(n,t){return this.intervalDuration.as("days")<=1&&this.isHiddenDay(n)&&(n=this.skipHiddenDays(n,t),n.startOf("day")),n},updateTitle:function(){this.title=this.computeTitle()},computeTitle:function(){return this.formatRange({start:this.calendar.applyTimezone(this.intervalStart),end:this.calendar.applyTimezone(this.intervalEnd)},this.opt("titleFormat")||this.computeTitleFormat(),this.opt("titleRangeSeparator"))},computeTitleFormat:function(){return this.intervalUnit=="year"?"YYYY":this.intervalUnit=="month"?this.opt("monthYearFormat"):this.intervalDuration.as("days")>1?"ll":"LL"},formatRange:function(n,t,i){var r=n.end;return r.hasTime()||(r=r.clone().subtract(1)),br(n.start,r,t,i,this.opt("isRTL"))},getAllDayHtml:function(){return this.opt("allDayHtml")||r(this.opt("allDayText"))},buildGotoAnchorHtml:function(t,u,f){var e,o,s,h;return n.isPlainObject(t)?(e=t.date,o=t.type,s=t.forceOff):e=t,e=i.moment(e),h={date:e.format("YYYY-MM-DD"),type:o||"day"},typeof u=="string"&&(f=u,u=null),u=u?" "+yf(u):"",f=f||"",!s&&this.opt("navLinks")?"<a"+u+' data-goto="'+r(JSON.stringify(h))+'">'+f+"<\/a>":"<span"+u+">"+f+"<\/span>"},setElement:function(n){this.el=n;this.bindGlobalHandlers()},removeElement:function(){this.clear();this.isSkeletonRendered&&(this.unrenderSkeleton(),this.isSkeletonRendered=!1);this.unbindGlobalHandlers();this.el.remove()},display:function(n,t){var i=this,r=null;return t!=null&&this.displaying&&(r=this.queryScroll()),this.calendar.freezeContentHeight(),ei(this.clear(),function(){return i.displaying=ei(i.displayView(n),function(){t!=null?i.setScroll(t):i.forceScroll(i.computeInitialScroll(r));i.calendar.unfreezeContentHeight();i.triggerRender()})})},clear:function(){var t=this,i=this.displaying;return i?ei(i,function(){return t.displaying=null,t.clearEvents(),t.clearView()}):n.when()},displayView:function(n){this.isSkeletonRendered||(this.renderSkeleton(),this.isSkeletonRendered=!0);n&&this.setDate(n);this.render&&this.render();this.renderDates();this.updateSize();this.renderBusinessHours();this.startNowIndicator()},clearView:function(){this.unselect();this.stopNowIndicator();this.triggerUnrender();this.unrenderBusinessHours();this.unrenderDates();this.destroy&&this.destroy()},renderSkeleton:function(){},unrenderSkeleton:function(){},renderDates:function(){},unrenderDates:function(){},triggerRender:function(){this.trigger("viewRender",this,this,this.el)},triggerUnrender:function(){this.trigger("viewDestroy",this,this,this.el)},bindGlobalHandlers:function(){this.listenTo(n(document),"mousedown",this.handleDocumentMousedown);this.listenTo(n(document),"touchstart",this.processUnselect)},unbindGlobalHandlers:function(){this.stopListeningTo(n(document))},initThemingProps:function(){var n=this.opt("theme")?"ui":"fc";this.widgetHeaderClass=n+"-widget-header";this.widgetContentClass=n+"-widget-content";this.highlightStateClass=n+"-state-highlight"},renderBusinessHours:function(){},unrenderBusinessHours:function(){},startNowIndicator:function(){var u=this,i,r,n;this.opt("nowIndicator")&&(i=this.getNowIndicatorUnit(),i&&(r=d(this,"updateNowIndicator"),this.initialNowDate=this.calendar.getNow(),this.initialNowQueriedMs=+new Date,this.renderNowIndicator(this.initialNowDate),this.isNowIndicatorRendered=!0,n=this.initialNowDate.clone().startOf(i).add(1,i)-this.initialNowDate,this.nowIndicatorTimeoutID=setTimeout(function(){u.nowIndicatorTimeoutID=null;r();n=+t.duration(1,i);n=Math.max(100,n);u.nowIndicatorIntervalID=setInterval(r,n)},n)))},updateNowIndicator:function(){this.isNowIndicatorRendered&&(this.unrenderNowIndicator(),this.renderNowIndicator(this.initialNowDate.clone().add(new Date-this.initialNowQueriedMs)))},stopNowIndicator:function(){this.isNowIndicatorRendered&&(this.nowIndicatorTimeoutID&&(clearTimeout(this.nowIndicatorTimeoutID),this.nowIndicatorTimeoutID=null),this.nowIndicatorIntervalID&&(clearTimeout(this.nowIndicatorIntervalID),this.nowIndicatorIntervalID=null),this.unrenderNowIndicator(),this.isNowIndicatorRendered=!1)},getNowIndicatorUnit:function(){},renderNowIndicator:function(){},unrenderNowIndicator:function(){},updateSize:function(n){var t;n&&(t=this.queryScroll());this.updateHeight(n);this.updateWidth(n);this.updateNowIndicator();n&&this.setScroll(t)},updateWidth:function(){},updateHeight:function(){var n=this.calendar;this.setHeight(n.getSuggestedViewHeight(),n.isHeightAuto())},setHeight:function(){},computeInitialScroll:function(){return 0},queryScroll:function(){},setScroll:function(){},forceScroll:function(n){var t=this;this.setScroll(n);setTimeout(function(){t.setScroll(n)},0)},displayEvents:function(n){var t=this.queryScroll();this.clearEvents();this.renderEvents(n);this.isEventsRendered=!0;this.setScroll(t);this.triggerEventRender()},clearEvents:function(){var n;this.isEventsRendered&&(n=this.queryScroll(),this.triggerEventUnrender(),this.destroyEvents&&this.destroyEvents(),this.unrenderEvents(),this.setScroll(n),this.isEventsRendered=!1)},renderEvents:function(){},unrenderEvents:function(){},triggerEventRender:function(){this.renderedEventSegEach(function(n){this.trigger("eventAfterRender",n.event,n.event,n.el)});this.trigger("eventAfterAllRender")},triggerEventUnrender:function(){this.renderedEventSegEach(function(n){this.trigger("eventDestroy",n.event,n.event,n.el)})},resolveEventEl:function(t,i){var r=this.trigger("eventRender",t,t,i);return r===!1?i=null:r&&r!==!0&&(i=n(r)),i},showEvent:function(n){this.renderedEventSegEach(function(n){n.el.css("visibility","")},n)},hideEvent:function(n){this.renderedEventSegEach(function(n){n.el.css("visibility","hidden")},n)},renderedEventSegEach:function(n,t){for(var r=this.getEventSegs(),i=0;i<r.length;i++)t&&r[i].event._id!==t._id||r[i].el&&n.call(this,r[i])},getEventSegs:function(){return[]},isEventDraggable:function(n){return this.isEventStartEditable(n)},isEventStartEditable:function(n){return f(n.startEditable,(n.source||{}).startEditable,this.opt("eventStartEditable"),this.isEventGenerallyEditable(n))},isEventGenerallyEditable:function(n){return f(n.editable,(n.source||{}).editable,this.opt("editable"))},reportEventDrop:function(n,t,i,r,u){var f=this.calendar,e=f.mutateEvent(n,t,i),o=function(){e.undo();f.reportEventChange()};this.triggerEventDrop(n,e.dateDelta,o,r,u);f.reportEventChange()},triggerEventDrop:function(n,t,i,r,u){this.trigger("eventDrop",r[0],n,t,i,u,{})},reportExternalDrop:function(t,i,r,u,f){var e=t.eventProps,o,s;e&&(o=n.extend({},e,i),s=this.calendar.renderEvent(o,t.stick)[0]);this.triggerExternalDrop(s,i,r,u,f)},triggerExternalDrop:function(n,t,i,r,u){this.trigger("drop",i[0],t.start,r,u);n&&this.trigger("eventReceive",null,n)},renderDrag:function(){},unrenderDrag:function(){},isEventResizableFromStart:function(n){return this.opt("eventResizableFromStart")&&this.isEventResizable(n)},isEventResizableFromEnd:function(n){return this.isEventResizable(n)},isEventResizable:function(n){var t=n.source||{};return f(n.durationEditable,t.durationEditable,this.opt("eventDurationEditable"),n.editable,t.editable,this.opt("editable"))},reportEventResize:function(n,t,i,r,u){var f=this.calendar,e=f.mutateEvent(n,t,i),o=function(){e.undo();f.reportEventChange()};this.triggerEventResize(n,e.durationDelta,o,r,u);f.reportEventChange()},triggerEventResize:function(n,t,i,r,u){this.trigger("eventResize",r[0],n,t,i,u,{})},select:function(n,t){this.unselect(t);this.renderSelection(n);this.reportSelection(n,t)},renderSelection:function(){},reportSelection:function(n,t){this.isSelected=!0;this.triggerSelect(n,t)},triggerSelect:function(n,t){this.trigger("select",null,this.calendar.applyTimezone(n.start),this.calendar.applyTimezone(n.end),t)},unselect:function(n){this.isSelected&&(this.isSelected=!1,this.destroySelection&&this.destroySelection(),this.unrenderSelection(),this.trigger("unselect",null,n))},unrenderSelection:function(){},selectEvent:function(n){this.selectedEvent&&this.selectedEvent===n||(this.unselectEvent(),this.renderedEventSegEach(function(n){n.el.addClass("fc-selected")},n),this.selectedEvent=n)},unselectEvent:function(){this.selectedEvent&&(this.renderedEventSegEach(function(n){n.el.removeClass("fc-selected")},this.selectedEvent),this.selectedEvent=null)},isEventSelected:function(n){return this.selectedEvent&&this.selectedEvent._id===n._id},handleDocumentMousedown:function(n){rr(n)&&this.processUnselect(n)},processUnselect:function(n){this.processRangeUnselect(n);this.processEventUnselect(n)},processRangeUnselect:function(t){var i;this.isSelected&&this.opt("unselectAuto")&&(i=this.opt("unselectCancel"),i&&n(t.target).closest(i).length||this.unselect(t))},processEventUnselect:function(t){this.selectedEvent&&(n(t.target).closest(".fc-selected").length||this.unselectEvent())},triggerDayClick:function(n,t,i){this.trigger("dayClick",t,this.calendar.applyTimezone(n.start),i)},initHiddenDays:function(){var i=this.opt("hiddenDays")||[],r=[],u=0,t;for(this.opt("weekends")===!1&&i.push(0,6),t=0;t<7;t++)(r[t]=n.inArray(t,i)!==-1)||u++;if(!u)throw"invalid hiddenDays";this.isHiddenDayHash=r},isHiddenDay:function(n){return t.isMoment(n)&&(n=n.day()),this.isHiddenDayHash[n]},skipHiddenDays:function(n,t,i){var r=n.clone();for(t=t||1;this.isHiddenDayHash[(r.day()+(i?t:0)+7)%7];)r.add(t,"days");return r},computeDayRange:function(n){var r=n.start.clone().stripTime(),i=n.end,t=null,u;return i&&(t=i.clone().stripTime(),u=+i.time(),u&&u>=this.nextDayThreshold&&t.add(1,"days")),(!i||t<=r)&&(t=r.clone().add(1,"days")),{start:r,end:t}},isMultiDayEvent:function(n){var t=this.computeDayRange(n);return t.end.diff(t.start,"days")>1}}),yi=i.Scroller=s.extend({el:null,scrollEl:null,overflowX:null,overflowY:null,constructor:function(n){n=n||{};this.overflowX=n.overflowX||n.overflow||"auto";this.overflowY=n.overflowY||n.overflow||"auto"},render:function(){this.el=this.renderEl();this.applyOverflow()},renderEl:function(){return this.scrollEl=n('<div class="fc-scroller"><\/div>')},clear:function(){this.setHeight("auto");this.applyOverflow()},destroy:function(){this.el.remove()},applyOverflow:function(){this.scrollEl.css({"overflow-x":this.overflowX,"overflow-y":this.overflowY})},lockOverflow:function(n){var t=this.overflowX,i=this.overflowY;n=n||this.getScrollbarWidths();t==="auto"&&(t=n.top||n.bottom||this.scrollEl[0].scrollWidth-1>this.scrollEl[0].clientWidth?"scroll":"hidden");i==="auto"&&(i=n.left||n.right||this.scrollEl[0].scrollHeight-1>this.scrollEl[0].clientHeight?"scroll":"hidden");this.scrollEl.css({"overflow-x":t,"overflow-y":i})},setHeight:function(n){this.scrollEl.height(n)},getScrollTop:function(){return this.scrollEl.scrollTop()},setScrollTop:function(n){this.scrollEl.scrollTop(n)},getClientWidth:function(){return this.scrollEl[0].clientWidth},getClientHeight:function(){return this.scrollEl[0].clientHeight},getScrollbarWidths:function(){return gt(this.scrollEl)}}),u=i.Calendar=s.extend({dirDefaults:null,localeDefaults:null,overrides:null,dynamicOverrides:null,options:null,viewSpecCache:null,view:null,header:null,loadingLevel:0,constructor:ce,initialize:function(){},populateOptionsHash:function(){var t,n,r,i;t=f(this.dynamicOverrides.locale,this.overrides.locale);n=b[t];n||(t=u.defaults.locale,n=b[t]||{});r=f(this.dynamicOverrides.isRTL,this.overrides.isRTL,n.isRTL,u.defaults.isRTL);i=r?u.rtlDefaults:{};this.dirDefaults=i;this.localeDefaults=n;this.options=nt([u.defaults,i,n,this.overrides,this.dynamicOverrides]);au(this.options)},getViewSpec:function(n){var t=this.viewSpecCache;return t[n]||(t[n]=this.buildViewSpec(n))},getUnitViewSpec:function(t){var r,u,f;if(n.inArray(t,ht)!=-1)for(r=this.header.getViewsWithButtons(),n.each(i.views,function(n){r.push(n)}),u=0;u<r.length;u++)if(f=this.getViewSpec(r[u]),f&&f.singleUnit==t)return f},buildViewSpec:function(n){for(var h=this.overrides.views||{},c=[],l=[],s=[],u=n,i,f,r,o;u;)i=e[u],f=h[u],u=null,typeof i=="function"&&(i={"class":i}),i&&(c.unshift(i),l.unshift(i.defaults||{}),r=r||i.duration,u=u||i.type),f&&(s.unshift(f),r=r||f.duration,u=u||f.type);return(i=ri(c),i.type=n,!i["class"])?!1:(r&&(r=t.duration(r),r.valueOf()&&(i.duration=r,o=ti(r),r.as(o)===1&&(i.singleUnit=o,s.unshift(h[o]||{})))),i.defaults=nt(l),i.overrides=nt(s),this.buildViewSpecOptions(i),this.buildViewSpecButtonText(i,n),i)},buildViewSpecOptions:function(n){n.options=nt([u.defaults,n.defaults,this.dirDefaults,this.localeDefaults,this.overrides,n.overrides,this.dynamicOverrides]);au(n.options)},buildViewSpecButtonText:function(n,t){function i(i){var r=i.buttonText||{};return r[t]||(n.buttonTextKey?r[n.buttonTextKey]:null)||(n.singleUnit?r[n.singleUnit]:null)}n.buttonTextOverride=i(this.dynamicOverrides)||i(this.overrides)||n.overrides.buttonText;n.buttonTextDefault=i(this.localeDefaults)||i(this.dirDefaults)||n.defaults.buttonText||i(u.defaults)||(n.duration?this.humanizeDuration(n.duration):null)||t},instantiateView:function(n){var t=this.getViewSpec(n);return new t["class"](this,n,t.options,t.duration)},isValidViewType:function(n){return Boolean(this.getViewSpec(n))},pushLoading:function(){this.loadingLevel++||this.trigger("loading",null,!0,this.view)},popLoading:function(){--this.loadingLevel||this.trigger("loading",null,!1,this.view)},buildSelectSpan:function(n,t){var i=this.moment(n).stripZone(),r;return r=t?this.moment(t).stripZone():i.hasTime()?i.clone().add(this.defaultTimedEventDuration):i.clone().add(this.defaultAllDayEventDuration),{start:i,end:r}}});u.mixin(iu);u.mixin({optionHandlers:null,bindOption:function(n,t){this.bindOptions([n],t)},bindOptions:function(n,t){for(var r={func:t,names:n},i=0;i<n.length;i++)this.registerOptionHandlerObj(n[i],r);this.triggerOptionHandlerObj(r)},registerOptionHandlerObj:function(n,t){(this.optionHandlers[n]||(this.optionHandlers[n]=[])).push(t)},triggerOptionHandlers:function(n){for(var i=this.optionHandlers[n]||[],t=0;t<i.length;t++)this.triggerOptionHandlerObj(i[t])},triggerOptionHandlerObj:function(n){for(var i=n.names,r=[],t=0;t<i.length;t++)r.push(this.options[i[t]]);n.func.apply(this,r)}});u.defaults={titleRangeSeparator:" – ",monthYearFormat:"MMMM YYYY",defaultTimedEventDuration:"02:00:00",defaultAllDayEventDuration:{days:1},forceEventDuration:!1,nextDayThreshold:"09:00:00",defaultView:"month",aspectRatio:1.35,header:{left:"title",center:"",right:"today prev,next"},weekends:!0,weekNumbers:!1,weekNumberTitle:"W",weekNumberCalculation:"local",scrollTime:"06:00:00",lazyFetching:!0,startParam:"start",endParam:"end",timezoneParam:"timezone",timezone:!1,isRTL:!1,buttonText:{prev:"prev",next:"next",prevYear:"prev year",nextYear:"next year",year:"year",today:"today",month:"month",week:"week",day:"day"},buttonIcons:{prev:"left-single-arrow",next:"right-single-arrow",prevYear:"left-double-arrow",nextYear:"right-double-arrow"},allDayText:"all-day",theme:!1,themeButtonIcons:{prev:"circle-triangle-w",next:"circle-triangle-e",prevYear:"seek-prev",nextYear:"seek-next"},dragOpacity:.75,dragRevertDuration:500,dragScroll:!0,unselectAuto:!0,dropAccept:"*",eventOrder:"title",eventLimit:!1,eventLimitText:"more",eventLimitClick:"popover",dayPopoverFormat:"LL",handleWindowResize:!0,windowResizeDelay:100,longPressDelay:1e3};u.englishDefaults={dayPopoverFormat:"dddd, MMMM D"};u.rtlDefaults={header:{left:"next,prev today",center:"",right:"title"},buttonIcons:{prev:"right-single-arrow",next:"left-single-arrow",prevYear:"right-double-arrow",nextYear:"left-double-arrow"},themeButtonIcons:{prev:"circle-triangle-e",next:"circle-triangle-w",nextYear:"seek-prev",prevYear:"seek-next"}};b=i.locales={};i.datepickerLocale=function(t,i,r){var u=b[t]||(b[t]={});u.isRTL=r.isRTL;u.weekNumberTitle=r.weekHeader;n.each(le,function(n,t){u[n]=t(r)});n.datepicker&&(n.datepicker.regional[i]=n.datepicker.regional[t]=r,n.datepicker.regional.en=n.datepicker.regional[""],n.datepicker.setDefaults(r))};i.locale=function(t,i){var r,f;r=b[t]||(b[t]={});i&&(r=b[t]=nt([r,i]));f=vu(t);n.each(ae,function(n,t){r[n]==null&&(r[n]=t(f,r))});u.defaults.locale=t};var le={buttonText:function(n){return{prev:fi(n.prevText),next:fi(n.nextText),today:fi(n.currentText)}},monthYearFormat:function(n){return n.showMonthAfterYear?"YYYY["+n.yearSuffix+"] MMMM":"MMMM YYYY["+n.yearSuffix+"]"}},ae={dayOfMonthFormat:function(n,t){var i=n.longDateFormat("l");return i=i.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g,""),t.isRTL?i+=" ddd":i="ddd "+i,i},mediumTimeFormat:function(n){return n.longDateFormat("LT").replace(/\s*a$/i,"a")},smallTimeFormat:function(n){return n.longDateFormat("LT").replace(":mm","(:mm)").replace(/(\Wmm)$/,"($1)").replace(/\s*a$/i,"a")},extraSmallTimeFormat:function(n){return n.longDateFormat("LT").replace(":mm","(:mm)").replace(/(\Wmm)$/,"($1)").replace(/\s*a$/i,"t")},hourFormat:function(n){return n.longDateFormat("LT").replace(":mm","").replace(/(\Wmm)$/,"").replace(/\s*a$/i,"a")},noMeridiemTimeFormat:function(n){return n.longDateFormat("LT").replace(/\s*a$/i,"")}},ve={smallDayDateFormat:function(n){return n.isRTL?"D dd":"dd D"},weekFormat:function(n){return n.isRTL?"w[ "+n.weekNumberTitle+"]":"["+n.weekNumberTitle+" ]w"},smallWeekFormat:function(n){return n.isRTL?"w["+n.weekNumberTitle+"]":"["+n.weekNumberTitle+"]w"}};i.locale("en",u.englishDefaults);i.sourceNormalizers=[];i.sourceFetchers=[];yu={dataType:"json",cache:!1};pu=1;u.prototype.normalizeEvent=function(){};u.prototype.spanContainsSpan=function(n,t){var i=n.start.clone().stripZone(),r=this.getEventEnd(n).stripZone();return t.start>=i&&t.end<=r};u.prototype.getPeerEvents=function(n,t){for(var u=this.getEventCache(),f=[],r,i=0;i<u.length;i++)r=u[i],t&&t._id===r._id||f.push(r);return f};u.prototype.isEventSpanAllowed=function(n,t){var i=t.source||{},r=f(t.constraint,i.constraint,this.options.eventConstraint),u=f(t.overlap,i.overlap,this.options.eventOverlap);return this.isSpanAllowed(n,r,u,t)&&(!this.options.eventAllow||this.options.eventAllow(n,t)!==!1)};u.prototype.isExternalSpanAllowed=function(t,i,r){var f,u;return r&&(f=n.extend({},r,i),u=this.expandEvent(this.buildEventFromInput(f))[0]),u?this.isEventSpanAllowed(t,u):this.isSelectionSpanAllowed(t)};u.prototype.isSelectionSpanAllowed=function(n){return this.isSpanAllowed(n,this.options.selectConstraint,this.options.selectOverlap)&&(!this.options.selectAllow||this.options.selectAllow(n)!==!1)};u.prototype.isSpanAllowed=function(n,t,i,r){var o,h,c,u,e,s;if(t!=null&&(o=this.constraintToEvents(t),o)){for(h=!1,u=0;u<o.length;u++)if(this.spanContainsSpan(o[u],n)){h=!0;break}if(!h)return!1}for(c=this.getPeerEvents(n,r),u=0;u<c.length;u++)if(e=c[u],this.eventIntersectsRange(e,n)&&(i===!1||typeof i=="function"&&!i(e,r)||r&&((s=f(e.overlap,(e.source||{}).overlap),s===!1)||typeof s=="function"&&!s(r,e))))return!1;return!0};u.prototype.constraintToEvents=function(n){return n==="businessHours"?this.getCurrentBusinessHourEvents():typeof n=="object"?n.start!=null?this.expandEvent(this.buildEventFromInput(n)):null:this.clientEvents(n)};u.prototype.eventIntersectsRange=function(n,t){var i=n.start.clone().stripZone(),r=this.getEventEnd(n).stripZone();return t.start<r&&t.end>i};pi={id:"_fcBusinessHours",start:"09:00",end:"17:00",dow:[1,2,3,4,5],rendering:"inverse-background"};u.prototype.getCurrentBusinessHourEvents=function(n){return this.computeBusinessHourEvents(n,this.options.businessHours)};u.prototype.computeBusinessHourEvents=function(t,i){return i===!0?this.expandBusinessHourEvents(t,[{}]):n.isPlainObject(i)?this.expandBusinessHourEvents(t,[i]):n.isArray(i)?this.expandBusinessHourEvents(t,i,!0):[]};u.prototype.expandBusinessHourEvents=function(t,i,r){for(var o=this.getView(),e=[],u,f=0;f<i.length;f++)(u=i[f],!r||u.dow)&&(u=n.extend({},pi,u),t&&(u.start=null,u.end=null),e.push.apply(e,this.expandEvent(this.buildEventFromInput(u),o.start,o.end)));return e};var wi=i.BasicView=w.extend({scroller:null,dayGridClass:rt,dayGrid:null,dayNumbersVisible:!1,colWeekNumbersVisible:!1,cellWeekNumbersVisible:!1,weekNumberWidth:null,headContainerEl:null,headRowEl:null,initialize:function(){this.dayGrid=this.instantiateDayGrid();this.scroller=new yi({overflowX:"hidden",overflowY:"auto"})},instantiateDayGrid:function(){var n=this.dayGridClass.extend(we);return new n(this)},setRange:function(n){w.prototype.setRange.call(this,n);this.dayGrid.breakOnWeeks=/year|month|week/.test(this.intervalUnit);this.dayGrid.setRange(n)},computeRange:function(n){var t=w.prototype.computeRange.call(this,n);return/year|month/.test(t.intervalUnit)&&(t.start.startOf("week"),t.start=this.skipHiddenDays(t.start),t.end.weekday()&&(t.end.add(1,"week").startOf("week"),t.end=this.skipHiddenDays(t.end,-1,!0))),t},renderDates:function(){this.dayNumbersVisible=this.dayGrid.rowCnt>1;this.opt("weekNumbers")&&(this.opt("weekNumbersWithinDays")?(this.cellWeekNumbersVisible=!0,this.colWeekNumbersVisible=!1):(this.cellWeekNumbersVisible=!1,this.colWeekNumbersVisible=!0));this.dayGrid.numbersVisible=this.dayNumbersVisible||this.cellWeekNumbersVisible||this.colWeekNumbersVisible;this.el.addClass("fc-basic-view").html(this.renderSkeletonHtml());this.renderHead();this.scroller.render();var t=this.scroller.el.addClass("fc-day-grid-container"),i=n('<div class="fc-day-grid" />').appendTo(t);this.el.find(".fc-body > tr > td").append(t);this.dayGrid.setElement(i);this.dayGrid.renderDates(this.hasRigidRows())},renderHead:function(){this.headContainerEl=this.el.find(".fc-head-container").html(this.dayGrid.renderHeadHtml());this.headRowEl=this.headContainerEl.find(".fc-row")},unrenderDates:function(){this.dayGrid.unrenderDates();this.dayGrid.removeElement();this.scroller.destroy()},renderBusinessHours:function(){this.dayGrid.renderBusinessHours()},unrenderBusinessHours:function(){this.dayGrid.unrenderBusinessHours()},renderSkeletonHtml:function(){return'<table><thead class="fc-head"><tr><td class="fc-head-container '+this.widgetHeaderClass+'"><\/td><\/tr><\/thead><tbody class="fc-body"><tr><td class="'+this.widgetContentClass+'"><\/td><\/tr><\/tbody><\/table>'},weekNumberStyleAttr:function(){return this.weekNumberWidth!==null?'style="width:'+this.weekNumberWidth+'px"':""},hasRigidRows:function(){var n=this.opt("eventLimit");return n&&typeof n!="number"},updateWidth:function(){this.colWeekNumbersVisible&&(this.weekNumberWidth=tr(this.el.find(".fc-week-number")))},setHeight:function(n,t){var i=this.opt("eventLimit"),r,u;this.scroller.clear();di(this.headRowEl);this.dayGrid.removeSegPopover();i&&typeof i=="number"&&this.dayGrid.limitRows(i);r=this.computeScrollerHeight(n);this.setGridHeight(r,t);i&&typeof i!="number"&&this.dayGrid.limitRows(i);t||(this.scroller.setHeight(r),u=this.scroller.getScrollbarWidths(),(u.left||u.right)&&(ki(this.headRowEl,u),r=this.computeScrollerHeight(n),this.scroller.setHeight(r)),this.scroller.lockOverflow(u))},computeScrollerHeight:function(n){return n-bt(this.el,this.scroller.el)},setGridHeight:function(n,t){t?nr(this.dayGrid.rowEls):gi(this.dayGrid.rowEls,n,!0)},queryScroll:function(){return this.scroller.getScrollTop()},setScroll:function(n){this.scroller.setScrollTop(n)},prepareHits:function(){this.dayGrid.prepareHits()},releaseHits:function(){this.dayGrid.releaseHits()},queryHit:function(n,t){return this.dayGrid.queryHit(n,t)},getHitSpan:function(n){return this.dayGrid.getHitSpan(n)},getHitEl:function(n){return this.dayGrid.getHitEl(n)},renderEvents:function(n){this.dayGrid.renderEvents(n);this.updateHeight()},getEventSegs:function(){return this.dayGrid.getEventSegs()},unrenderEvents:function(){this.dayGrid.unrenderEvents()},renderDrag:function(n,t){return this.dayGrid.renderDrag(n,t)},unrenderDrag:function(){this.dayGrid.unrenderDrag()},renderSelection:function(n){this.dayGrid.renderSelection(n)},unrenderSelection:function(){this.dayGrid.unrenderSelection()}}),we={renderHeadIntroHtml:function(){var n=this.view;return n.colWeekNumbersVisible?'<th class="fc-week-number '+n.widgetHeaderClass+'" '+n.weekNumberStyleAttr()+"><span>"+r(n.opt("weekNumberTitle"))+"<\/span><\/th>":""},renderNumberIntroHtml:function(n){var t=this.view,i=this.getCellDate(n,0);return t.colWeekNumbersVisible?'<td class="fc-week-number" '+t.weekNumberStyleAttr()+">"+t.buildGotoAnchorHtml({date:i,type:"week",forceOff:this.colCnt===1},i.format("w"))+"<\/td>":""},renderBgIntroHtml:function(){var n=this.view;return n.colWeekNumbersVisible?'<td class="fc-week-number '+n.widgetContentClass+'" '+n.weekNumberStyleAttr()+"><\/td>":""},renderIntroHtml:function(){var n=this.view;return n.colWeekNumbersVisible?'<td class="fc-week-number" '+n.weekNumberStyleAttr()+"><\/td>":""}},be=i.MonthView=wi.extend({computeRange:function(n){var t=wi.prototype.computeRange.call(this,n),i;return this.isFixedWeeks()&&(i=Math.ceil(t.end.diff(t.start,"weeks",!0)),t.end.add(6-i,"weeks")),t},setGridHeight:function(n,t){t&&(n*=this.rowCnt/6);gi(this.dayGrid.rowEls,n,!t)},isFixedWeeks:function(){return this.opt("fixedWeekCount")}});e.basic={"class":wi};e.basicDay={type:"basic",duration:{days:1}};e.basicWeek={type:"basic",duration:{weeks:1}};e.month={"class":be,duration:{months:1},defaults:{fixedWeekCount:!0}};var ke=i.AgendaView=w.extend({scroller:null,timeGridClass:vi,timeGrid:null,dayGridClass:rt,dayGrid:null,axisWidth:null,headContainerEl:null,noScrollRowEls:null,bottomRuleEl:null,initialize:function(){this.timeGrid=this.instantiateTimeGrid();this.opt("allDaySlot")&&(this.dayGrid=this.instantiateDayGrid());this.scroller=new yi({overflowX:"hidden",overflowY:"auto"})},instantiateTimeGrid:function(){var n=this.timeGridClass.extend(de);return new n(this)},instantiateDayGrid:function(){var n=this.dayGridClass.extend(ge);return new n(this)},setRange:function(n){w.prototype.setRange.call(this,n);this.timeGrid.setRange(n);this.dayGrid&&this.dayGrid.setRange(n)},renderDates:function(){this.el.addClass("fc-agenda-view").html(this.renderSkeletonHtml());this.renderHead();this.scroller.render();var t=this.scroller.el.addClass("fc-time-grid-container"),i=n('<div class="fc-time-grid" />').appendTo(t);this.el.find(".fc-body > tr > td").append(t);this.timeGrid.setElement(i);this.timeGrid.renderDates();this.bottomRuleEl=n('<hr class="fc-divider '+this.widgetHeaderClass+'"/>').appendTo(this.timeGrid.el);this.dayGrid&&(this.dayGrid.setElement(this.el.find(".fc-day-grid")),this.dayGrid.renderDates(),this.dayGrid.bottomCoordPadding=this.dayGrid.el.next("hr").outerHeight());this.noScrollRowEls=this.el.find(".fc-row:not(.fc-scroller *)")},renderHead:function(){this.headContainerEl=this.el.find(".fc-head-container").html(this.timeGrid.renderHeadHtml())},unrenderDates:function(){this.timeGrid.unrenderDates();this.timeGrid.removeElement();this.dayGrid&&(this.dayGrid.unrenderDates(),this.dayGrid.removeElement());this.scroller.destroy()},renderSkeletonHtml:function(){return'<table><thead class="fc-head"><tr><td class="fc-head-container '+this.widgetHeaderClass+'"><\/td><\/tr><\/thead><tbody class="fc-body"><tr><td class="'+this.widgetContentClass+'">'+(this.dayGrid?'<div class="fc-day-grid"/><hr class="fc-divider '+this.widgetHeaderClass+'"/>':"")+"<\/td><\/tr><\/tbody><\/table>"},axisStyleAttr:function(){return this.axisWidth!==null?'style="width:'+this.axisWidth+'px"':""},renderBusinessHours:function(){this.timeGrid.renderBusinessHours();this.dayGrid&&this.dayGrid.renderBusinessHours()},unrenderBusinessHours:function(){this.timeGrid.unrenderBusinessHours();this.dayGrid&&this.dayGrid.unrenderBusinessHours()},getNowIndicatorUnit:function(){return this.timeGrid.getNowIndicatorUnit()},renderNowIndicator:function(n){this.timeGrid.renderNowIndicator(n)},unrenderNowIndicator:function(){this.timeGrid.unrenderNowIndicator()},updateSize:function(n){this.timeGrid.updateSize(n);w.prototype.updateSize.call(this,n)},updateWidth:function(){this.axisWidth=tr(this.el.find(".fc-axis"))},setHeight:function(n,t){var i,r,u;this.bottomRuleEl.hide();this.scroller.clear();di(this.noScrollRowEls);this.dayGrid&&(this.dayGrid.removeSegPopover(),i=this.opt("eventLimit"),i&&typeof i!="number"&&(i=no),i&&this.dayGrid.limitRows(i));t||(r=this.computeScrollerHeight(n),this.scroller.setHeight(r),u=this.scroller.getScrollbarWidths(),(u.left||u.right)&&(ki(this.noScrollRowEls,u),r=this.computeScrollerHeight(n),this.scroller.setHeight(r)),this.scroller.lockOverflow(u),this.timeGrid.getTotalSlatHeight()<r&&this.bottomRuleEl.show())},computeScrollerHeight:function(n){return n-bt(this.el,this.scroller.el)},computeInitialScroll:function(){var i=t.duration(this.opt("scrollTime")),n=this.timeGrid.computeTimeTop(i);return n=Math.ceil(n),n&&n++,n},queryScroll:function(){return this.scroller.getScrollTop()},setScroll:function(n){this.scroller.setScrollTop(n)},prepareHits:function(){this.timeGrid.prepareHits();this.dayGrid&&this.dayGrid.prepareHits()},releaseHits:function(){this.timeGrid.releaseHits();this.dayGrid&&this.dayGrid.releaseHits()},queryHit:function(n,t){var i=this.timeGrid.queryHit(n,t);return!i&&this.dayGrid&&(i=this.dayGrid.queryHit(n,t)),i},getHitSpan:function(n){return n.component.getHitSpan(n)},getHitEl:function(n){return n.component.getHitEl(n)},renderEvents:function(n){for(var i=[],r=[],u=[],f,t=0;t<n.length;t++)n[t].allDay?i.push(n[t]):r.push(n[t]);f=this.timeGrid.renderEvents(r);this.dayGrid&&(u=this.dayGrid.renderEvents(i));this.updateHeight()},getEventSegs:function(){return this.timeGrid.getEventSegs().concat(this.dayGrid?this.dayGrid.getEventSegs():[])},unrenderEvents:function(){this.timeGrid.unrenderEvents();this.dayGrid&&this.dayGrid.unrenderEvents()},renderDrag:function(n,t){return n.start.hasTime()?this.timeGrid.renderDrag(n,t):this.dayGrid?this.dayGrid.renderDrag(n,t):void 0},unrenderDrag:function(){this.timeGrid.unrenderDrag();this.dayGrid&&this.dayGrid.unrenderDrag()},renderSelection:function(n){n.start.hasTime()||n.end.hasTime()?this.timeGrid.renderSelection(n):this.dayGrid&&this.dayGrid.renderSelection(n)},unrenderSelection:function(){this.timeGrid.unrenderSelection();this.dayGrid&&this.dayGrid.unrenderSelection()}}),de={renderHeadIntroHtml:function(){var n=this.view,t;return n.opt("weekNumbers")?(t=this.start.format(n.opt("smallWeekFormat")),'<th class="fc-axis fc-week-number '+n.widgetHeaderClass+'" '+n.axisStyleAttr()+">"+n.buildGotoAnchorHtml({date:this.start,type:"week",forceOff:this.colCnt>1},r(t))+"<\/th>"):'<th class="fc-axis '+n.widgetHeaderClass+'" '+n.axisStyleAttr()+"><\/th>"},renderBgIntroHtml:function(){var n=this.view;return'<td class="fc-axis '+n.widgetContentClass+'" '+n.axisStyleAttr()+"><\/td>"},renderIntroHtml:function(){var n=this.view;return'<td class="fc-axis" '+n.axisStyleAttr()+"><\/td>"}},ge={renderBgIntroHtml:function(){var n=this.view;return'<td class="fc-axis '+n.widgetContentClass+'" '+n.axisStyleAttr()+"><span>"+n.getAllDayHtml()+"<\/span><\/td>"},renderIntroHtml:function(){var n=this.view;return'<td class="fc-axis" '+n.axisStyleAttr()+"><\/td>"}},no=5,wu=[{hours:1},{minutes:30},{minutes:15},{seconds:30},{seconds:15}];return e.agenda={"class":ke,defaults:{allDaySlot:!0,slotDuration:"00:30:00",minTime:"00:00:00",maxTime:"24:00:00",slotEventOverlap:!0}},e.agendaDay={type:"agenda",duration:{days:1}},e.agendaWeek={type:"agenda",duration:{weeks:1}},bu=w.extend({grid:null,scroller:null,initialize:function(){this.grid=new ku(this);this.scroller=new yi({overflowX:"hidden",overflowY:"auto"})},setRange:function(n){w.prototype.setRange.call(this,n);this.grid.setRange(n)},renderSkeleton:function(){this.el.addClass("fc-list-view "+this.widgetContentClass);this.scroller.render();this.scroller.el.appendTo(this.el);this.grid.setElement(this.scroller.scrollEl)},unrenderSkeleton:function(){this.scroller.destroy()},setHeight:function(n){this.scroller.setHeight(this.computeScrollerHeight(n))},computeScrollerHeight:function(n){return n-bt(this.el,this.scroller.el)},renderEvents:function(n){this.grid.renderEvents(n)},unrenderEvents:function(){this.grid.unrenderEvents()},isEventResizable:function(){return!1},isEventDraggable:function(){return!1}}),ku=c.extend({segSelector:".fc-list-item",hasDayInteractions:!1,spanToSegs:function(n){for(var r=this.view,i=r.start.clone().time(0),u=0,t,f=[];i<r.end;)if(t=st(n,{start:i,end:i.clone().add(1,"day")}),t&&(t.dayIndex=u,f.push(t)),i.add(1,"day"),u++,t&&!t.isEnd&&n.end.hasTime()&&n.end<i.clone().add(this.view.nextDayThreshold)){t.end=n.end.clone();t.isEnd=!0;break}return f},computeEventTimeFormat:function(){return this.view.opt("mediumTimeFormat")},handleSegClick:function(t,i){var r;c.prototype.handleSegClick.apply(this,arguments);n(i.target).closest("a[href]").length||(r=t.event.url,r&&!i.isDefaultPrevented()&&(window.location.href=r))},renderFgSegs:function(n){return n=this.renderFgSegEls(n),n.length?this.renderSegList(n):this.renderEmptyMessage(),n},renderEmptyMessage:function(){this.el.html('<div class="fc-list-empty-wrap2"><div class="fc-list-empty-wrap1"><div class="fc-list-empty">'+r(this.view.opt("noEventsMessage"))+"<\/div><\/div><\/div>")},renderSegList:function(t){for(var f=this.groupSegsByDay(t),r,u,e=n('<table class="fc-list-table"><tbody/><\/table>'),o=e.find("tbody"),i=0;i<f.length;i++)if(r=f[i],r)for(o.append(this.dayHeaderHtml(this.view.start.clone().add(i,"days"))),this.sortEventSegs(r),u=0;u<r.length;u++)o.append(r[u].el);this.el.empty().append(e)},groupSegsByDay:function(n){for(var r=[],i,t=0;t<n.length;t++)i=n[t],(r[i.dayIndex]||(r[i.dayIndex]=[])).push(i);return r},dayHeaderHtml:function(n){var t=this.view,i=t.opt("listDayFormat"),u=t.opt("listDayAltFormat");return'<tr class="fc-list-heading" data-date="'+n.format("YYYY-MM-DD")+'"><td class="'+t.widgetHeaderClass+'" colspan="3">'+(i?t.buildGotoAnchorHtml(n,{"class":"fc-list-heading-main"},r(n.format(i))):"")+(u?t.buildGotoAnchorHtml(n,{"class":"fc-list-heading-alt"},r(n.format(u))):"")+"<\/td><\/tr>"},fgSegHtml:function(n){var t=this.view,f=["fc-list-item"].concat(this.getSegCustomClasses(n)),e=this.getSegBackgroundColor(n),i=n.event,u=i.url,o;return o=i.allDay?t.getAllDayHtml():t.isMultiDayEvent(i)?n.isStart||n.isEnd?r(this.getEventTimeText(n)):t.getAllDayHtml():r(this.getEventTimeText(i)),u&&f.push("fc-has-url"),'<tr class="'+f.join(" ")+'">'+(this.displayEventTime?'<td class="fc-list-item-time '+t.widgetContentClass+'">'+(o||"")+"<\/td>":"")+'<td class="fc-list-item-marker '+t.widgetContentClass+'"><span class="fc-event-dot"'+(e?' style="background-color:'+e+'"':"")+'><\/span><\/td><td class="fc-list-item-title '+t.widgetContentClass+'"><a'+(u?' href="'+r(u)+'"':"")+">"+r(n.event.title||"")+"<\/a><\/td><\/tr>"}}),e.list={"class":bu,buttonTextKey:"list",defaults:{buttonText:"list",listDayFormat:"LL",noEventsMessage:"No events to display"}},e.listDay={type:"list",duration:{days:1},defaults:{listDayFormat:"dddd"}},e.listWeek={type:"list",duration:{weeks:1},defaults:{listDayFormat:"dddd",listDayAltFormat:"LL"}},e.listMonth={type:"list",duration:{month:1},defaults:{listDayAltFormat:"dddd"}},e.listYear={type:"list",duration:{year:1},defaults:{listDayAltFormat:"dddd"}},i});;
/*! =======================================================
========================================================= */
"use strict";

function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }

/*! =========================================================
 * bootstrap-slider.js
 *
 * Maintainers:
 *		Kyle Kemp
 *			- Twitter: @seiyria
 *			- Github:  seiyria
 *		Rohit Kalkur
 *			- Twitter: @Rovolutionary
 *			- Github:  rovolution
 *
 * =========================================================
 *
 * bootstrap-slider is released under the MIT License
 * Copyright (c) 2016 Kyle Kemp, Rohit Kalkur, and contributors
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * ========================================================= */

/**
 * Bridget makes jQuery widgets
 * v1.0.1
 * MIT license
 */
var windowIsDefined = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object";

(function (factory) {
	if (typeof define === "function" && define.amd) {
		define(["jquery"], factory);
	} else if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports) {
		var jQuery;
		try {
			jQuery = require("jquery");
		} catch (err) {
			jQuery = null;
		}
		module.exports = factory(jQuery);
	} else if (window) {
		window.Slider = factory(window.jQuery);
	}
})(function ($) {
	// Constants
	var NAMESPACE_MAIN = 'slider';
	var NAMESPACE_ALTERNATE = 'bootstrapSlider';

	// Polyfill console methods
	if (windowIsDefined && !window.console) {
		window.console = {};
	}
	if (windowIsDefined && !window.console.log) {
		window.console.log = function () {};
	}
	if (windowIsDefined && !window.console.warn) {
		window.console.warn = function () {};
	}

	// Reference to Slider constructor
	var Slider;

	(function ($) {

		'use strict';

		// -------------------------- utils -------------------------- //

		var slice = Array.prototype.slice;

		function noop() {}

		// -------------------------- definition -------------------------- //

		function defineBridget($) {

			// bail if no jQuery
			if (!$) {
				return;
			}

			// -------------------------- addOptionMethod -------------------------- //

			/**
    * adds option method -> $().plugin('option', {...})
    * @param {Function} PluginClass - constructor class
    */
			function addOptionMethod(PluginClass) {
				// don't overwrite original option method
				if (PluginClass.prototype.option) {
					return;
				}

				// option setter
				PluginClass.prototype.option = function (opts) {
					// bail out if not an object
					if (!$.isPlainObject(opts)) {
						return;
					}
					this.options = $.extend(true, this.options, opts);
				};
			}

			// -------------------------- plugin bridge -------------------------- //

			// helper function for logging errors
			// $.error breaks jQuery chaining
			var logError = typeof console === 'undefined' ? noop : function (message) {
				console.error(message);
			};

			/**
    * jQuery plugin bridge, access methods like $elem.plugin('method')
    * @param {String} namespace - plugin name
    * @param {Function} PluginClass - constructor class
    */
			function bridge(namespace, PluginClass) {
				// add to jQuery fn namespace
				$.fn[namespace] = function (options) {
					if (typeof options === 'string') {
						// call plugin method when first argument is a string
						// get arguments for method
						var args = slice.call(arguments, 1);

						for (var i = 0, len = this.length; i < len; i++) {
							var elem = this[i];
							var instance = $.data(elem, namespace);
							if (!instance) {
								logError("cannot call methods on " + namespace + " prior to initialization; " + "attempted to call '" + options + "'");
								continue;
							}
							if (!$.isFunction(instance[options]) || options.charAt(0) === '_') {
								logError("no such method '" + options + "' for " + namespace + " instance");
								continue;
							}

							// trigger method with arguments
							var returnValue = instance[options].apply(instance, args);

							// break look and return first value if provided
							if (returnValue !== undefined && returnValue !== instance) {
								return returnValue;
							}
						}
						// return this if no return value
						return this;
					} else {
						var objects = this.map(function () {
							var instance = $.data(this, namespace);
							if (instance) {
								// apply options & init
								instance.option(options);
								instance._init();
							} else {
								// initialize new instance
								instance = new PluginClass(this, options);
								$.data(this, namespace, instance);
							}
							return $(this);
						});

						if (!objects || objects.length > 1) {
							return objects;
						} else {
							return objects[0];
						}
					}
				};
			}

			// -------------------------- bridget -------------------------- //

			/**
    * converts a Prototypical class into a proper jQuery plugin
    *   the class must have a ._init method
    * @param {String} namespace - plugin name, used in $().pluginName
    * @param {Function} PluginClass - constructor class
    */
			$.bridget = function (namespace, PluginClass) {
				addOptionMethod(PluginClass);
				bridge(namespace, PluginClass);
			};

			return $.bridget;
		}

		// get jquery from browser global
		defineBridget($);
	})($);

	/*************************************************
 			BOOTSTRAP-SLIDER SOURCE CODE
 	**************************************************/

	(function ($) {

		var ErrorMsgs = {
			formatInvalidInputErrorMsg: function formatInvalidInputErrorMsg(input) {
				return "Invalid input value '" + input + "' passed in";
			},
			callingContextNotSliderInstance: "Calling context element does not have instance of Slider bound to it. Check your code to make sure the JQuery object returned from the call to the slider() initializer is calling the method"
		};

		var SliderScale = {
			linear: {
				toValue: function toValue(percentage) {
					var rawValue = percentage / 100 * (this.options.max - this.options.min);
					var shouldAdjustWithBase = true;
					if (this.options.ticks_positions.length > 0) {
						var minv,
						    maxv,
						    minp,
						    maxp = 0;
						for (var i = 1; i < this.options.ticks_positions.length; i++) {
							if (percentage <= this.options.ticks_positions[i]) {
								minv = this.options.ticks[i - 1];
								minp = this.options.ticks_positions[i - 1];
								maxv = this.options.ticks[i];
								maxp = this.options.ticks_positions[i];

								break;
							}
						}
						var partialPercentage = (percentage - minp) / (maxp - minp);
						rawValue = minv + partialPercentage * (maxv - minv);
						shouldAdjustWithBase = false;
					}

					var adjustment = shouldAdjustWithBase ? this.options.min : 0;
					var value = adjustment + Math.round(rawValue / this.options.step) * this.options.step;
					if (value < this.options.min) {
						return this.options.min;
					} else if (value > this.options.max) {
						return this.options.max;
					} else {
						return value;
					}
				},
				toPercentage: function toPercentage(value) {
					if (this.options.max === this.options.min) {
						return 0;
					}

					if (this.options.ticks_positions.length > 0) {
						var minv,
						    maxv,
						    minp,
						    maxp = 0;
						for (var i = 0; i < this.options.ticks.length; i++) {
							if (value <= this.options.ticks[i]) {
								minv = i > 0 ? this.options.ticks[i - 1] : 0;
								minp = i > 0 ? this.options.ticks_positions[i - 1] : 0;
								maxv = this.options.ticks[i];
								maxp = this.options.ticks_positions[i];

								break;
							}
						}
						if (i > 0) {
							var partialPercentage = (value - minv) / (maxv - minv);
							return minp + partialPercentage * (maxp - minp);
						}
					}

					return 100 * (value - this.options.min) / (this.options.max - this.options.min);
				}
			},

			logarithmic: {
				/* Based on http://stackoverflow.com/questions/846221/logarithmic-slider */
				toValue: function toValue(percentage) {
					var min = this.options.min === 0 ? 0 : Math.log(this.options.min);
					var max = Math.log(this.options.max);
					var value = Math.exp(min + (max - min) * percentage / 100);
					value = this.options.min + Math.round((value - this.options.min) / this.options.step) * this.options.step;
					/* Rounding to the nearest step could exceed the min or
      * max, so clip to those values. */
					if (value < this.options.min) {
						return this.options.min;
					} else if (value > this.options.max) {
						return this.options.max;
					} else {
						return value;
					}
				},
				toPercentage: function toPercentage(value) {
					if (this.options.max === this.options.min) {
						return 0;
					} else {
						var max = Math.log(this.options.max);
						var min = this.options.min === 0 ? 0 : Math.log(this.options.min);
						var v = value === 0 ? 0 : Math.log(value);
						return 100 * (v - min) / (max - min);
					}
				}
			}
		};

		/*************************************************
  						CONSTRUCTOR
  	**************************************************/
		Slider = function (element, options) {
			createNewSlider.call(this, element, options);
			return this;
		};

		function createNewSlider(element, options) {

			/*
   	The internal state object is used to store data about the current 'state' of slider.
   	This includes values such as the `value`, `enabled`, etc...
   */
			this._state = {
				value: null,
				enabled: null,
				offset: null,
				size: null,
				percentage: null,
				inDrag: false,
				over: false
			};

			// The objects used to store the reference to the tick methods if ticks_tooltip is on
			this.ticksCallbackMap = {};
			this.handleCallbackMap = {};

			if (typeof element === "string") {
				this.element = document.querySelector(element);
			} else if (element instanceof HTMLElement) {
				this.element = element;
			}

			/*************************************************
   					Process Options
   	**************************************************/
			options = options ? options : {};
			var optionTypes = Object.keys(this.defaultOptions);

			for (var i = 0; i < optionTypes.length; i++) {
				var optName = optionTypes[i];

				// First check if an option was passed in via the constructor
				var val = options[optName];
				// If no data attrib, then check data atrributes
				val = typeof val !== 'undefined' ? val : getDataAttrib(this.element, optName);
				// Finally, if nothing was specified, use the defaults
				val = val !== null ? val : this.defaultOptions[optName];

				// Set all options on the instance of the Slider
				if (!this.options) {
					this.options = {};
				}
				this.options[optName] = val;
            }

            if (!this.options.tooltipFormatter)
                this.options.tooltipFormatter = options.formatter;

			/*
   	Validate `tooltip_position` against 'orientation`
   	- if `tooltip_position` is incompatible with orientation, swith it to a default compatible with specified `orientation`
   		-- default for "vertical" -> "right"
   		-- default for "horizontal" -> "left"
   */
			if (this.options.orientation === "vertical" && (this.options.tooltip_position === "top" || this.options.tooltip_position === "bottom")) {

				this.options.tooltip_position = "right";
			} else if (this.options.orientation === "horizontal" && (this.options.tooltip_position === "left" || this.options.tooltip_position === "right")) {

				this.options.tooltip_position = "top";
			}

			function getDataAttrib(element, optName) {
				var dataName = "data-slider-" + optName.replace(/_/g, '-');
				var dataValString = element.getAttribute(dataName);

				try {
					return JSON.parse(dataValString);
				} catch (err) {
					return dataValString;
				}
			}

			/*************************************************
   					Create Markup
   	**************************************************/

			var origWidth = this.element.style.width;
			var updateSlider = false;
			var parent = this.element.parentNode;
			var sliderTrackSelection;
			var sliderTrackLow, sliderTrackHigh;
			var sliderMinHandle;
			var sliderMaxHandle;

			if (this.sliderElem) {
				updateSlider = true;
			} else {
				/* Create elements needed for slider */
				this.sliderElem = document.createElement("div");
				this.sliderElem.className = "slider";

				/* Create slider track elements */
				var sliderTrack = document.createElement("div");
				sliderTrack.className = "slider-track";

				sliderTrackLow = document.createElement("div");
				sliderTrackLow.className = "slider-track-low";

				sliderTrackSelection = document.createElement("div");
				sliderTrackSelection.className = "slider-selection";

				sliderTrackHigh = document.createElement("div");
				sliderTrackHigh.className = "slider-track-high";

				sliderMinHandle = document.createElement("div");
				sliderMinHandle.className = "slider-handle min-slider-handle";
				sliderMinHandle.setAttribute('role', 'slider');
				sliderMinHandle.setAttribute('aria-valuemin', this.options.min);
				sliderMinHandle.setAttribute('aria-valuemax', this.options.max);

				sliderMaxHandle = document.createElement("div");
				sliderMaxHandle.className = "slider-handle max-slider-handle";
				sliderMaxHandle.setAttribute('role', 'slider');
				sliderMaxHandle.setAttribute('aria-valuemin', this.options.min);
				sliderMaxHandle.setAttribute('aria-valuemax', this.options.max);

				sliderTrack.appendChild(sliderTrackLow);
				sliderTrack.appendChild(sliderTrackSelection);
				sliderTrack.appendChild(sliderTrackHigh);

				/* Create highlight range elements */
				this.rangeHighlightElements = [];
				if (Array.isArray(this.options.rangeHighlights) && this.options.rangeHighlights.length > 0) {
					for (var j = 0; j < this.options.rangeHighlights.length; j++) {

						var rangeHighlightElement = document.createElement("div");
						rangeHighlightElement.className = "slider-rangeHighlight slider-selection";

						this.rangeHighlightElements.push(rangeHighlightElement);
						sliderTrack.appendChild(rangeHighlightElement);
					}
				}

				/* Add aria-labelledby to handle's */
				var isLabelledbyArray = Array.isArray(this.options.labelledby);
				if (isLabelledbyArray && this.options.labelledby[0]) {
					sliderMinHandle.setAttribute('aria-labelledby', this.options.labelledby[0]);
				}
				if (isLabelledbyArray && this.options.labelledby[1]) {
					sliderMaxHandle.setAttribute('aria-labelledby', this.options.labelledby[1]);
				}
				if (!isLabelledbyArray && this.options.labelledby) {
					sliderMinHandle.setAttribute('aria-labelledby', this.options.labelledby);
					sliderMaxHandle.setAttribute('aria-labelledby', this.options.labelledby);
				}

				/* Create ticks */
				this.ticks = [];
				if (Array.isArray(this.options.ticks) && this.options.ticks.length > 0) {
					this.ticksContainer = document.createElement('div');
					this.ticksContainer.className = 'slider-tick-container';

					for (i = 0; i < this.options.ticks.length; i++) {
						var tick = document.createElement('div');
						tick.className = 'slider-tick';
						if (this.options.ticks_tooltip) {
							var tickListenerReference = this._addTickListener();
							var enterCallback = tickListenerReference.addMouseEnter(this, tick, i);
							var leaveCallback = tickListenerReference.addMouseLeave(this, tick);

							this.ticksCallbackMap[i] = {
								mouseEnter: enterCallback,
								mouseLeave: leaveCallback
							};
						}
						this.ticks.push(tick);
						this.ticksContainer.appendChild(tick);
					}

					sliderTrackSelection.className += " tick-slider-selection";
				}

				this.tickLabels = [];
				if (Array.isArray(this.options.ticks_labels) && this.options.ticks_labels.length > 0) {
					this.tickLabelContainer = document.createElement('div');
					this.tickLabelContainer.className = 'slider-tick-label-container';

					for (i = 0; i < this.options.ticks_labels.length; i++) {
						var label = document.createElement('div');
						var noTickPositionsSpecified = this.options.ticks_positions.length === 0;
						var tickLabelsIndex = this.options.reversed && noTickPositionsSpecified ? this.options.ticks_labels.length - (i + 1) : i;
						label.className = 'slider-tick-label';
						label.innerHTML = this.options.ticks_labels[tickLabelsIndex];

						this.tickLabels.push(label);
						this.tickLabelContainer.appendChild(label);
					}
				}

				var createAndAppendTooltipSubElements = function createAndAppendTooltipSubElements(tooltipElem) {
					var arrow = document.createElement("div");
					arrow.className = "tooltip-arrow";

					var inner = document.createElement("div");
					inner.className = "tooltip-inner";

					tooltipElem.appendChild(arrow);
					tooltipElem.appendChild(inner);
				};

				/* Create tooltip elements */
				var sliderTooltip = document.createElement("div");
				sliderTooltip.className = "tooltip tooltip-main";
				sliderTooltip.setAttribute('role', 'presentation');
				createAndAppendTooltipSubElements(sliderTooltip);

				var sliderTooltipMin = document.createElement("div");
				sliderTooltipMin.className = "tooltip tooltip-min";
				sliderTooltipMin.setAttribute('role', 'presentation');
				createAndAppendTooltipSubElements(sliderTooltipMin);

				var sliderTooltipMax = document.createElement("div");
				sliderTooltipMax.className = "tooltip tooltip-max";
				sliderTooltipMax.setAttribute('role', 'presentation');
				createAndAppendTooltipSubElements(sliderTooltipMax);

				/* Append components to sliderElem */
				this.sliderElem.appendChild(sliderTrack);
				this.sliderElem.appendChild(sliderTooltip);
				this.sliderElem.appendChild(sliderTooltipMin);
				this.sliderElem.appendChild(sliderTooltipMax);

				if (this.tickLabelContainer) {
					this.sliderElem.appendChild(this.tickLabelContainer);
				}
				if (this.ticksContainer) {
					this.sliderElem.appendChild(this.ticksContainer);
				}

				this.sliderElem.appendChild(sliderMinHandle);
				this.sliderElem.appendChild(sliderMaxHandle);

				/* Append slider element to parent container, right before the original <input> element */
				parent.insertBefore(this.sliderElem, this.element);

				/* Hide original <input> element */
				this.element.style.display = "none";
			}
			/* If JQuery exists, cache JQ references */
			if ($) {
				this.$element = $(this.element);
				this.$sliderElem = $(this.sliderElem);
			}

			/*************************************************
   						Setup
   	**************************************************/
			this.eventToCallbackMap = {};
			this.sliderElem.id = this.options.id;

			this.touchCapable = 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch;

			this.touchX = 0;
			this.touchY = 0;

			this.tooltip = this.sliderElem.querySelector('.tooltip-main');
			this.tooltipInner = this.tooltip.querySelector('.tooltip-inner');

			this.tooltip_min = this.sliderElem.querySelector('.tooltip-min');
			this.tooltipInner_min = this.tooltip_min.querySelector('.tooltip-inner');

			this.tooltip_max = this.sliderElem.querySelector('.tooltip-max');
			this.tooltipInner_max = this.tooltip_max.querySelector('.tooltip-inner');

			if (SliderScale[this.options.scale]) {
				this.options.scale = SliderScale[this.options.scale];
			}

			if (updateSlider === true) {
				// Reset classes
				this._removeClass(this.sliderElem, 'slider-horizontal');
				this._removeClass(this.sliderElem, 'slider-vertical');
				this._removeClass(this.tooltip, 'hide');
				this._removeClass(this.tooltip_min, 'hide');
				this._removeClass(this.tooltip_max, 'hide');

				// Undo existing inline styles for track
				["left", "top", "width", "height"].forEach(function (prop) {
					this._removeProperty(this.trackLow, prop);
					this._removeProperty(this.trackSelection, prop);
					this._removeProperty(this.trackHigh, prop);
				}, this);

				// Undo inline styles on handles
				[this.handle1, this.handle2].forEach(function (handle) {
					this._removeProperty(handle, 'left');
					this._removeProperty(handle, 'top');
				}, this);

				// Undo inline styles and classes on tooltips
				[this.tooltip, this.tooltip_min, this.tooltip_max].forEach(function (tooltip) {
					this._removeProperty(tooltip, 'left');
					this._removeProperty(tooltip, 'top');
					this._removeProperty(tooltip, 'margin-left');
					this._removeProperty(tooltip, 'margin-top');

					this._removeClass(tooltip, 'right');
					this._removeClass(tooltip, 'top');
				}, this);
			}

			if (this.options.orientation === 'vertical') {
				this._addClass(this.sliderElem, 'slider-vertical');
				this.stylePos = 'top';
				this.mousePos = 'pageY';
				this.sizePos = 'offsetHeight';
			} else {
				this._addClass(this.sliderElem, 'slider-horizontal');
				this.sliderElem.style.width = origWidth;
				this.options.orientation = 'horizontal';
				this.stylePos = 'left';
				this.mousePos = 'pageX';
				this.sizePos = 'offsetWidth';
			}
			this._setTooltipPosition();
			/* In case ticks are specified, overwrite the min and max bounds */
			if (Array.isArray(this.options.ticks) && this.options.ticks.length > 0) {
				this.options.max = Math.max.apply(Math, this.options.ticks);
				this.options.min = Math.min.apply(Math, this.options.ticks);
			}

			if (Array.isArray(this.options.value)) {
				this.options.range = true;
				this._state.value = this.options.value;
			} else if (this.options.range) {
				// User wants a range, but value is not an array
				this._state.value = [this.options.value, this.options.max];
			} else {
				this._state.value = this.options.value;
			}

			this.trackLow = sliderTrackLow || this.trackLow;
			this.trackSelection = sliderTrackSelection || this.trackSelection;
			this.trackHigh = sliderTrackHigh || this.trackHigh;

			if (this.options.selection === 'none') {
				this._addClass(this.trackLow, 'hide');
				this._addClass(this.trackSelection, 'hide');
				this._addClass(this.trackHigh, 'hide');
			} else if (this.options.selection === 'after' || this.options.selection === 'before') {
				this._removeClass(this.trackLow, 'hide');
				this._removeClass(this.trackSelection, 'hide');
				this._removeClass(this.trackHigh, 'hide');
			}

			this.handle1 = sliderMinHandle || this.handle1;
			this.handle2 = sliderMaxHandle || this.handle2;

			if (updateSlider === true) {
				// Reset classes
				this._removeClass(this.handle1, 'round triangle');
				this._removeClass(this.handle2, 'round triangle hide');

				for (i = 0; i < this.ticks.length; i++) {
					this._removeClass(this.ticks[i], 'round triangle hide');
				}
			}

			var availableHandleModifiers = ['round', 'triangle', 'custom'];
			var isValidHandleType = availableHandleModifiers.indexOf(this.options.handle) !== -1;
			if (isValidHandleType) {
				this._addClass(this.handle1, this.options.handle);
				this._addClass(this.handle2, this.options.handle);

				for (i = 0; i < this.ticks.length; i++) {
					this._addClass(this.ticks[i], this.options.handle);
				}
			}

			this._state.offset = this._offset(this.sliderElem);
			this._state.size = this.sliderElem[this.sizePos];
			this.setValue(this._state.value);

			/******************************************
   				Bind Event Listeners
   	******************************************/

			// Bind keyboard handlers
			this.handle1Keydown = this._keydown.bind(this, 0);
			this.handle1.addEventListener("keydown", this.handle1Keydown, false);

			this.handle2Keydown = this._keydown.bind(this, 1);
			this.handle2.addEventListener("keydown", this.handle2Keydown, false);

			this.mousedown = this._mousedown.bind(this);
			this.touchstart = this._touchstart.bind(this);
			this.touchmove = this._touchmove.bind(this);

			if (this.touchCapable) {
				// Bind touch handlers
				this.sliderElem.addEventListener("touchstart", this.touchstart, false);
				this.sliderElem.addEventListener("touchmove", this.touchmove, false);
			}
			this.sliderElem.addEventListener("mousedown", this.mousedown, false);

			// Bind window handlers
			this.resize = this._resize.bind(this);
			window.addEventListener("resize", this.resize, false);

			// Bind tooltip-related handlers
			if (this.options.tooltip === 'hide') {
				this._addClass(this.tooltip, 'hide');
				this._addClass(this.tooltip_min, 'hide');
				this._addClass(this.tooltip_max, 'hide');
			} else if (this.options.tooltip === 'always') {
				this._showTooltip();
				this._alwaysShowTooltip = true;
			} else {
				this.showTooltip = this._showTooltip.bind(this);
				this.hideTooltip = this._hideTooltip.bind(this);

				if (this.options.ticks_tooltip) {
					var callbackHandle = this._addTickListener();
					//create handle1 listeners and store references in map
					var mouseEnter = callbackHandle.addMouseEnter(this, this.handle1);
					var mouseLeave = callbackHandle.addMouseLeave(this, this.handle1);
					this.handleCallbackMap.handle1 = {
						mouseEnter: mouseEnter,
						mouseLeave: mouseLeave
					};
					//create handle2 listeners and store references in map
					mouseEnter = callbackHandle.addMouseEnter(this, this.handle2);
					mouseLeave = callbackHandle.addMouseLeave(this, this.handle2);
					this.handleCallbackMap.handle2 = {
						mouseEnter: mouseEnter,
						mouseLeave: mouseLeave
					};
				} else {
					this.sliderElem.addEventListener("mouseenter", this.showTooltip, false);
					this.sliderElem.addEventListener("mouseleave", this.hideTooltip, false);
				}

				this.handle1.addEventListener("focus", this.showTooltip, false);
				this.handle1.addEventListener("blur", this.hideTooltip, false);

				this.handle2.addEventListener("focus", this.showTooltip, false);
				this.handle2.addEventListener("blur", this.hideTooltip, false);
			}

			if (this.options.enabled) {
				this.enable();
			} else {
				this.disable();
			}
		}

		/*************************************************
  				INSTANCE PROPERTIES/METHODS
  	- Any methods bound to the prototype are considered
  part of the plugin's `public` interface
  	**************************************************/
		Slider.prototype = {
			_init: function _init() {}, // NOTE: Must exist to support bridget

			constructor: Slider,

			defaultOptions: {
				id: "",
				min: 0,
				max: 10,
				step: 1,
				precision: 0,
				orientation: 'horizontal',
				value: 5,
				range: false,
				selection: 'before',
				tooltip: 'show',
				tooltip_split: false,
				handle: 'round',
				reversed: false,
				enabled: true,
				formatter: function formatter(val) {
					if (Array.isArray(val)) {
						return val[0] + " : " + val[1];
					} else {
						return val;
					}
				},
				natural_arrow_keys: false,
				ticks: [],
				ticks_positions: [],
				ticks_labels: [],
				ticks_snap_bounds: 0,
				ticks_tooltip: false,
				scale: 'linear',
				focus: false,
				tooltip_position: null,
				labelledby: null,
				rangeHighlights: []
			},

			getElement: function getElement() {
				return this.sliderElem;
			},

			getValue: function getValue() {
				if (this.options.range) {
					return this._state.value;
				} else {
					return this._state.value[0];
				}
			},

			setValue: function setValue(val, triggerSlideEvent, triggerChangeEvent) {
				if (!val) {
					val = 0;
				}
				var oldValue = this.getValue();
				this._state.value = this._validateInputValue(val);
				var applyPrecision = this._applyPrecision.bind(this);

				if (this.options.range) {
					this._state.value[0] = applyPrecision(this._state.value[0]);
					this._state.value[1] = applyPrecision(this._state.value[1]);

					this._state.value[0] = Math.max(this.options.min, Math.min(this.options.max, this._state.value[0]));
					this._state.value[1] = Math.max(this.options.min, Math.min(this.options.max, this._state.value[1]));
				} else {
					this._state.value = applyPrecision(this._state.value);
					this._state.value = [Math.max(this.options.min, Math.min(this.options.max, this._state.value))];
					this._addClass(this.handle2, 'hide');
					if (this.options.selection === 'after') {
						this._state.value[1] = this.options.max;
					} else {
						this._state.value[1] = this.options.min;
					}
				}

				if (this.options.max > this.options.min) {
					this._state.percentage = [this._toPercentage(this._state.value[0]), this._toPercentage(this._state.value[1]), this.options.step * 100 / (this.options.max - this.options.min)];
				} else {
					this._state.percentage = [0, 0, 100];
				}

				this._layout();
				var newValue = this.options.range ? this._state.value : this._state.value[0];

				this._setDataVal(newValue);
				if (triggerSlideEvent === true) {
					this._trigger('slide', newValue);
				}
				if (oldValue !== newValue && triggerChangeEvent === true) {
					this._trigger('change', {
						oldValue: oldValue,
						newValue: newValue
					});
				}

				return this;
			},

			destroy: function destroy() {
				// Remove event handlers on slider elements
				this._removeSliderEventHandlers();

				// Remove the slider from the DOM
				this.sliderElem.parentNode.removeChild(this.sliderElem);
				/* Show original <input> element */
				this.element.style.display = "";

				// Clear out custom event bindings
				this._cleanUpEventCallbacksMap();

				// Remove data values
				this.element.removeAttribute("data");

				// Remove JQuery handlers/data
				if ($) {
					this._unbindJQueryEventHandlers();
					this.$element.removeData('slider');
				}
			},

			disable: function disable() {
				this._state.enabled = false;
				this.handle1.removeAttribute("tabindex");
				this.handle2.removeAttribute("tabindex");
				this._addClass(this.sliderElem, 'slider-disabled');
				this._trigger('slideDisabled');

				return this;
			},

			enable: function enable() {
				this._state.enabled = true;
				this.handle1.setAttribute("tabindex", 0);
				this.handle2.setAttribute("tabindex", 0);
				this._removeClass(this.sliderElem, 'slider-disabled');
				this._trigger('slideEnabled');

				return this;
			},

			toggle: function toggle() {
				if (this._state.enabled) {
					this.disable();
				} else {
					this.enable();
				}
				return this;
			},

			isEnabled: function isEnabled() {
				return this._state.enabled;
			},

			on: function on(evt, callback) {
				this._bindNonQueryEventHandler(evt, callback);
				return this;
			},

			off: function off(evt, callback) {
				if ($) {
					this.$element.off(evt, callback);
					this.$sliderElem.off(evt, callback);
				} else {
					this._unbindNonQueryEventHandler(evt, callback);
				}
			},

			getAttribute: function getAttribute(attribute) {
				if (attribute) {
					return this.options[attribute];
				} else {
					return this.options;
				}
			},

			setAttribute: function setAttribute(attribute, value) {
				this.options[attribute] = value;
				return this;
			},

			refresh: function refresh() {
				this._removeSliderEventHandlers();
				createNewSlider.call(this, this.element, this.options);
				if ($) {
					// Bind new instance of slider to the element
					$.data(this.element, 'slider', this);
				}
				return this;
			},

			relayout: function relayout() {
				this._resize();
				this._layout();
				return this;
			},

			/******************************+
   				HELPERS
   	- Any method that is not part of the public interface.
   - Place it underneath this comment block and write its signature like so:
   		_fnName : function() {...}
   	********************************/
			_removeSliderEventHandlers: function _removeSliderEventHandlers() {
				// Remove keydown event listeners
				this.handle1.removeEventListener("keydown", this.handle1Keydown, false);
				this.handle2.removeEventListener("keydown", this.handle2Keydown, false);

				//remove the listeners from the ticks and handles if they had their own listeners
				if (this.options.ticks_tooltip) {
					var ticks = this.ticksContainer.getElementsByClassName('slider-tick');
					for (var i = 0; i < ticks.length; i++) {
						ticks[i].removeEventListener('mouseenter', this.ticksCallbackMap[i].mouseEnter, false);
						ticks[i].removeEventListener('mouseleave', this.ticksCallbackMap[i].mouseLeave, false);
					}
					this.handle1.removeEventListener('mouseenter', this.handleCallbackMap.handle1.mouseEnter, false);
					this.handle2.removeEventListener('mouseenter', this.handleCallbackMap.handle2.mouseEnter, false);
					this.handle1.removeEventListener('mouseleave', this.handleCallbackMap.handle1.mouseLeave, false);
					this.handle2.removeEventListener('mouseleave', this.handleCallbackMap.handle2.mouseLeave, false);
				}

				this.handleCallbackMap = null;
				this.ticksCallbackMap = null;

				if (this.showTooltip) {
					this.handle1.removeEventListener("focus", this.showTooltip, false);
					this.handle2.removeEventListener("focus", this.showTooltip, false);
				}
				if (this.hideTooltip) {
					this.handle1.removeEventListener("blur", this.hideTooltip, false);
					this.handle2.removeEventListener("blur", this.hideTooltip, false);
				}

				// Remove event listeners from sliderElem
				if (this.showTooltip) {
					this.sliderElem.removeEventListener("mouseenter", this.showTooltip, false);
				}
				if (this.hideTooltip) {
					this.sliderElem.removeEventListener("mouseleave", this.hideTooltip, false);
				}
				this.sliderElem.removeEventListener("touchstart", this.touchstart, false);
				this.sliderElem.removeEventListener("touchmove", this.touchmove, false);
				this.sliderElem.removeEventListener("mousedown", this.mousedown, false);

				// Remove window event listener
				window.removeEventListener("resize", this.resize, false);
			},
			_bindNonQueryEventHandler: function _bindNonQueryEventHandler(evt, callback) {
				if (this.eventToCallbackMap[evt] === undefined) {
					this.eventToCallbackMap[evt] = [];
				}
				this.eventToCallbackMap[evt].push(callback);
			},
			_unbindNonQueryEventHandler: function _unbindNonQueryEventHandler(evt, callback) {
				var callbacks = this.eventToCallbackMap[evt];
				if (callbacks !== undefined) {
					for (var i = 0; i < callbacks.length; i++) {
						if (callbacks[i] === callback) {
							callbacks.splice(i, 1);
							break;
						}
					}
				}
			},
			_cleanUpEventCallbacksMap: function _cleanUpEventCallbacksMap() {
				var eventNames = Object.keys(this.eventToCallbackMap);
				for (var i = 0; i < eventNames.length; i++) {
					var eventName = eventNames[i];
					delete this.eventToCallbackMap[eventName];
				}
			},
			_showTooltip: function _showTooltip() {
				if (this.options.tooltip_split === false) {
					this._addClass(this.tooltip, 'in');
					this.tooltip_min.style.display = 'none';
					this.tooltip_max.style.display = 'none';
				} else {
					this._addClass(this.tooltip_min, 'in');
					this._addClass(this.tooltip_max, 'in');
					this.tooltip.style.display = 'none';
				}
				this._state.over = true;
			},
			_hideTooltip: function _hideTooltip() {
				if (this._state.inDrag === false && this.alwaysShowTooltip !== true) {
					this._removeClass(this.tooltip, 'in');
					this._removeClass(this.tooltip_min, 'in');
					this._removeClass(this.tooltip_max, 'in');
				}
				this._state.over = false;
			},
			_setToolTipOnMouseOver: function _setToolTipOnMouseOver(tempState) {
                var formattedTooltipVal = this.options.tooltipFormatter(!tempState ? this._state.value[0] : tempState.value[0]);
				var positionPercentages = !tempState ? getPositionPercentages(this._state, this.options.reversed) : getPositionPercentages(tempState, this.options.reversed);
				this._setText(this.tooltipInner, formattedTooltipVal);

				this.tooltip.style[this.stylePos] = positionPercentages[0] + '%';
				if (this.options.orientation === 'vertical') {
					this._css(this.tooltip, 'margin-top', -this.tooltip.offsetHeight / 2 + 'px');
				} else {
					this._css(this.tooltip, 'margin-left', -this.tooltip.offsetWidth / 2 + 'px');
				}

				function getPositionPercentages(state, reversed) {
					if (reversed) {
						return [100 - state.percentage[0], this.options.range ? 100 - state.percentage[1] : state.percentage[1]];
					}
					return [state.percentage[0], state.percentage[1]];
				}
			},
			_addTickListener: function _addTickListener() {
				return {
					addMouseEnter: function addMouseEnter(reference, tick, index) {
						var enter = function enter() {
							var tempState = reference._state;
							var idString = index >= 0 ? index : this.attributes['aria-valuenow'].value;
							var hoverIndex = parseInt(idString, 10);
							tempState.value[0] = hoverIndex;
							tempState.percentage[0] = reference.options.ticks_positions[hoverIndex];
							reference._setToolTipOnMouseOver(tempState);
							reference._showTooltip();
						};
						tick.addEventListener("mouseenter", enter, false);
						return enter;
					},
					addMouseLeave: function addMouseLeave(reference, tick) {
						var leave = function leave() {
							reference._hideTooltip();
						};
						tick.addEventListener("mouseleave", leave, false);
						return leave;
					}
				};
			},
			_layout: function _layout() {
				var positionPercentages;

				if (this.options.reversed) {
					positionPercentages = [100 - this._state.percentage[0], this.options.range ? 100 - this._state.percentage[1] : this._state.percentage[1]];
				} else {
					positionPercentages = [this._state.percentage[0], this._state.percentage[1]];
				}

				this.handle1.style[this.stylePos] = positionPercentages[0] + '%';
				this.handle1.setAttribute('aria-valuenow', this._state.value[0]);
				if (isNaN(this.options.formatter(this._state.value[0]))) {
					this.handle1.setAttribute('aria-valuetext', this.options.formatter(this._state.value[0]));
				}

				this.handle2.style[this.stylePos] = positionPercentages[1] + '%';
				this.handle2.setAttribute('aria-valuenow', this._state.value[1]);
				if (isNaN(this.options.formatter(this._state.value[1]))) {
					this.handle2.setAttribute('aria-valuetext', this.options.formatter(this._state.value[1]));
				}

				/* Position highlight range elements */
				if (this.rangeHighlightElements.length > 0 && Array.isArray(this.options.rangeHighlights) && this.options.rangeHighlights.length > 0) {
					for (var _i = 0; _i < this.options.rangeHighlights.length; _i++) {
						var startPercent = this._toPercentage(this.options.rangeHighlights[_i].start);
						var endPercent = this._toPercentage(this.options.rangeHighlights[_i].end);

						if (this.options.reversed) {
							var sp = 100 - endPercent;
							endPercent = 100 - startPercent;
							startPercent = sp;
						}

						var currentRange = this._createHighlightRange(startPercent, endPercent);

						if (currentRange) {
							if (this.options.orientation === 'vertical') {
								this.rangeHighlightElements[_i].style.top = currentRange.start + "%";
								this.rangeHighlightElements[_i].style.height = currentRange.size + "%";
							} else {
								this.rangeHighlightElements[_i].style.left = currentRange.start + "%";
								this.rangeHighlightElements[_i].style.width = currentRange.size + "%";
							}
						} else {
							this.rangeHighlightElements[_i].style.display = "none";
						}
					}
				}

				/* Position ticks and labels */
				if (Array.isArray(this.options.ticks) && this.options.ticks.length > 0) {

					var styleSize = this.options.orientation === 'vertical' ? 'height' : 'width';
					var styleMargin = this.options.orientation === 'vertical' ? 'marginTop' : 'marginLeft';
					var labelSize = this._state.size / (this.options.ticks.length - 1);

					if (this.tickLabelContainer) {
						var extraMargin = 0;
						if (this.options.ticks_positions.length === 0) {
							if (this.options.orientation !== 'vertical') {
								this.tickLabelContainer.style[styleMargin] = -labelSize / 2 + 'px';
							}

							extraMargin = this.tickLabelContainer.offsetHeight;
						} else {
							/* Chidren are position absolute, calculate height by finding the max offsetHeight of a child */
							for (i = 0; i < this.tickLabelContainer.childNodes.length; i++) {
								if (this.tickLabelContainer.childNodes[i].offsetHeight > extraMargin) {
									extraMargin = this.tickLabelContainer.childNodes[i].offsetHeight;
								}
							}
						}
						if (this.options.orientation === 'horizontal') {
							this.sliderElem.style.marginBottom = extraMargin + 'px';
						}
					}
					for (var i = 0; i < this.options.ticks.length; i++) {

						var percentage = this.options.ticks_positions[i] || this._toPercentage(this.options.ticks[i]);

						if (this.options.reversed) {
							percentage = 100 - percentage;
						}

						this.ticks[i].style[this.stylePos] = percentage + '%';

						/* Set class labels to denote whether ticks are in the selection */
						this._removeClass(this.ticks[i], 'in-selection');
						if (!this.options.range) {
							if (this.options.selection === 'after' && percentage >= positionPercentages[0]) {
								this._addClass(this.ticks[i], 'in-selection');
							} else if (this.options.selection === 'before' && percentage <= positionPercentages[0]) {
								this._addClass(this.ticks[i], 'in-selection');
							}
						} else if (percentage >= positionPercentages[0] && percentage <= positionPercentages[1]) {
							this._addClass(this.ticks[i], 'in-selection');
						}

						if (this.tickLabels[i]) {
							this.tickLabels[i].style[styleSize] = labelSize + 'px';

							if (this.options.orientation !== 'vertical' && this.options.ticks_positions[i] !== undefined) {
								this.tickLabels[i].style.position = 'absolute';
								this.tickLabels[i].style[this.stylePos] = percentage + '%';
								this.tickLabels[i].style[styleMargin] = -labelSize / 2 + 'px';
							} else if (this.options.orientation === 'vertical') {
								this.tickLabels[i].style['marginLeft'] = this.sliderElem.offsetWidth + 'px';
								this.tickLabelContainer.style['marginTop'] = this.sliderElem.offsetWidth / 2 * -1 + 'px';
							}
						}
					}
				}

				var formattedTooltipVal;

                if (this.options.range) {
                    formattedTooltipVal = this.options.tooltipFormatter(this._state.value);
					this._setText(this.tooltipInner, formattedTooltipVal);
					this.tooltip.style[this.stylePos] = (positionPercentages[1] + positionPercentages[0]) / 2 + '%';

					if (this.options.orientation === 'vertical') {
						this._css(this.tooltip, 'margin-top', -this.tooltip.offsetHeight / 2 + 'px');
					} else {
						this._css(this.tooltip, 'margin-left', -this.tooltip.offsetWidth / 2 + 'px');
					}

					if (this.options.orientation === 'vertical') {
						this._css(this.tooltip, 'margin-top', -this.tooltip.offsetHeight / 2 + 'px');
					} else {
						this._css(this.tooltip, 'margin-left', -this.tooltip.offsetWidth / 2 + 'px');
					}

                    var innerTooltipMinText = this.options.tooltipFormatter(this._state.value[0]);
					this._setText(this.tooltipInner_min, innerTooltipMinText);

                    var innerTooltipMaxText = this.options.tooltipFormatter(this._state.value[1]);
					this._setText(this.tooltipInner_max, innerTooltipMaxText);

					this.tooltip_min.style[this.stylePos] = positionPercentages[0] + '%';

					if (this.options.orientation === 'vertical') {
						this._css(this.tooltip_min, 'margin-top', -this.tooltip_min.offsetHeight / 2 + 'px');
					} else {
						this._css(this.tooltip_min, 'margin-left', -this.tooltip_min.offsetWidth / 2 + 'px');
					}

					this.tooltip_max.style[this.stylePos] = positionPercentages[1] + '%';

					if (this.options.orientation === 'vertical') {
						this._css(this.tooltip_max, 'margin-top', -this.tooltip_max.offsetHeight / 2 + 'px');
					} else {
						this._css(this.tooltip_max, 'margin-left', -this.tooltip_max.offsetWidth / 2 + 'px');
					}
				} else {
                    formattedTooltipVal = this.options.tooltipFormatter(this._state.value[0]);
					this._setText(this.tooltipInner, formattedTooltipVal);

					this.tooltip.style[this.stylePos] = positionPercentages[0] + '%';
					if (this.options.orientation === 'vertical') {
						this._css(this.tooltip, 'margin-top', -this.tooltip.offsetHeight / 2 + 'px');
					} else {
						this._css(this.tooltip, 'margin-left', -this.tooltip.offsetWidth / 2 + 'px');
					}
				}

				if (this.options.orientation === 'vertical') {
					this.trackLow.style.top = '0';
					this.trackLow.style.height = Math.min(positionPercentages[0], positionPercentages[1]) + '%';

					this.trackSelection.style.top = Math.min(positionPercentages[0], positionPercentages[1]) + '%';
					this.trackSelection.style.height = Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';

					this.trackHigh.style.bottom = '0';
					this.trackHigh.style.height = 100 - Math.min(positionPercentages[0], positionPercentages[1]) - Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';
				} else {
					this.trackLow.style.left = '0';
					this.trackLow.style.width = Math.min(positionPercentages[0], positionPercentages[1]) + '%';

					this.trackSelection.style.left = Math.min(positionPercentages[0], positionPercentages[1]) + '%';
					this.trackSelection.style.width = Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';

					this.trackHigh.style.right = '0';
					this.trackHigh.style.width = 100 - Math.min(positionPercentages[0], positionPercentages[1]) - Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';

					var offset_min = this.tooltip_min.getBoundingClientRect();
					var offset_max = this.tooltip_max.getBoundingClientRect();

					if (this.options.tooltip_position === 'bottom') {
						if (offset_min.right > offset_max.left) {
							this._removeClass(this.tooltip_max, 'bottom');
							this._addClass(this.tooltip_max, 'top');
							this.tooltip_max.style.top = '';
							this.tooltip_max.style.bottom = 22 + 'px';
						} else {
							this._removeClass(this.tooltip_max, 'top');
							this._addClass(this.tooltip_max, 'bottom');
							this.tooltip_max.style.top = this.tooltip_min.style.top;
							this.tooltip_max.style.bottom = '';
						}
					} else {
						if (offset_min.right > offset_max.left) {
							this._removeClass(this.tooltip_max, 'top');
							this._addClass(this.tooltip_max, 'bottom');
							this.tooltip_max.style.top = 18 + 'px';
						} else {
							this._removeClass(this.tooltip_max, 'bottom');
							this._addClass(this.tooltip_max, 'top');
							this.tooltip_max.style.top = this.tooltip_min.style.top;
						}
					}
				}
			},
			_createHighlightRange: function _createHighlightRange(start, end) {
				if (this._isHighlightRange(start, end)) {
					if (start > end) {
						return { 'start': end, 'size': start - end };
					}
					return { 'start': start, 'size': end - start };
				}
				return null;
			},
			_isHighlightRange: function _isHighlightRange(start, end) {
				if (0 <= start && start <= 100 && 0 <= end && end <= 100) {
					return true;
				} else {
					return false;
				}
			},
			_resize: function _resize(ev) {
				/*jshint unused:false*/
				this._state.offset = this._offset(this.sliderElem);
				this._state.size = this.sliderElem[this.sizePos];
				this._layout();
			},
			_removeProperty: function _removeProperty(element, prop) {
				if (element.style.removeProperty) {
					element.style.removeProperty(prop);
				} else {
					element.style.removeAttribute(prop);
				}
			},
			_mousedown: function _mousedown(ev) {
				if (!this._state.enabled) {
					return false;
				}

				this._state.offset = this._offset(this.sliderElem);
				this._state.size = this.sliderElem[this.sizePos];

				var percentage = this._getPercentage(ev);

				if (this.options.range) {
					var diff1 = Math.abs(this._state.percentage[0] - percentage);
					var diff2 = Math.abs(this._state.percentage[1] - percentage);
					this._state.dragged = diff1 < diff2 ? 0 : 1;
					this._adjustPercentageForRangeSliders(percentage);
				} else {
					this._state.dragged = 0;
				}

				this._state.percentage[this._state.dragged] = percentage;
				this._layout();

				if (this.touchCapable) {
					document.removeEventListener("touchmove", this.mousemove, false);
					document.removeEventListener("touchend", this.mouseup, false);
				}

				if (this.mousemove) {
					document.removeEventListener("mousemove", this.mousemove, false);
				}
				if (this.mouseup) {
					document.removeEventListener("mouseup", this.mouseup, false);
				}

				this.mousemove = this._mousemove.bind(this);
				this.mouseup = this._mouseup.bind(this);

				if (this.touchCapable) {
					// Touch: Bind touch events:
					document.addEventListener("touchmove", this.mousemove, false);
					document.addEventListener("touchend", this.mouseup, false);
				}
				// Bind mouse events:
				document.addEventListener("mousemove", this.mousemove, false);
				document.addEventListener("mouseup", this.mouseup, false);

				this._state.inDrag = true;
				var newValue = this._calculateValue();

				this._trigger('slideStart', newValue);

				this._setDataVal(newValue);
				this.setValue(newValue, false, true);

				this._pauseEvent(ev);

				if (this.options.focus) {
					this._triggerFocusOnHandle(this._state.dragged);
				}

				return true;
			},
			_touchstart: function _touchstart(ev) {
				if (ev.changedTouches === undefined) {
					this._mousedown(ev);
					return;
				}

				var touch = ev.changedTouches[0];
				this.touchX = touch.pageX;
				this.touchY = touch.pageY;
			},
			_triggerFocusOnHandle: function _triggerFocusOnHandle(handleIdx) {
				if (handleIdx === 0) {
					this.handle1.focus();
				}
				if (handleIdx === 1) {
					this.handle2.focus();
				}
			},
			_keydown: function _keydown(handleIdx, ev) {
				if (!this._state.enabled) {
					return false;
				}

				var dir;
				switch (ev.keyCode) {
					case 37: // left
					case 40:
						// down
						dir = -1;
						break;
					case 39: // right
					case 38:
						// up
						dir = 1;
						break;
				}
				if (!dir) {
					return;
				}

				// use natural arrow keys instead of from min to max
				if (this.options.natural_arrow_keys) {
					var ifVerticalAndNotReversed = this.options.orientation === 'vertical' && !this.options.reversed;
					var ifHorizontalAndReversed = this.options.orientation === 'horizontal' && this.options.reversed;

					if (ifVerticalAndNotReversed || ifHorizontalAndReversed) {
						dir = -dir;
					}
				}

				var val = this._state.value[handleIdx] + dir * this.options.step;
				if (this.options.range) {
					val = [!handleIdx ? val : this._state.value[0], handleIdx ? val : this._state.value[1]];
				}

				this._trigger('slideStart', val);
				this._setDataVal(val);
				this.setValue(val, true, true);

				this._setDataVal(val);
				this._trigger('slideStop', val);
				this._layout();

				this._pauseEvent(ev);

				return false;
			},
			_pauseEvent: function _pauseEvent(ev) {
				if (ev.stopPropagation) {
					ev.stopPropagation();
				}
				if (ev.preventDefault) {
					ev.preventDefault();
				}
				ev.cancelBubble = true;
				ev.returnValue = false;
			},
			_mousemove: function _mousemove(ev) {
				if (!this._state.enabled) {
					return false;
				}

				var percentage = this._getPercentage(ev);
				this._adjustPercentageForRangeSliders(percentage);
				this._state.percentage[this._state.dragged] = percentage;
				this._layout();

				var val = this._calculateValue(true);
				this.setValue(val, true, true);

				return false;
			},
			_touchmove: function _touchmove(ev) {
				if (ev.changedTouches === undefined) {
					return;
				}

				var touch = ev.changedTouches[0];

				var xDiff = touch.pageX - this.touchX;
				var yDiff = touch.pageY - this.touchY;

				if (!this._state.inDrag) {
					// Vertical Slider
					if (this.options.orientation === 'vertical' && xDiff <= 5 && xDiff >= -5 && (yDiff >= 15 || yDiff <= -15)) {
						this._mousedown(ev);
					}
					// Horizontal slider.
					else if (yDiff <= 5 && yDiff >= -5 && (xDiff >= 15 || xDiff <= -15)) {
							this._mousedown(ev);
						}
				}
			},
			_adjustPercentageForRangeSliders: function _adjustPercentageForRangeSliders(percentage) {
				if (this.options.range) {
					var precision = this._getNumDigitsAfterDecimalPlace(percentage);
					precision = precision ? precision - 1 : 0;
					var percentageWithAdjustedPrecision = this._applyToFixedAndParseFloat(percentage, precision);
					if (this._state.dragged === 0 && this._applyToFixedAndParseFloat(this._state.percentage[1], precision) < percentageWithAdjustedPrecision) {
						this._state.percentage[0] = this._state.percentage[1];
						this._state.dragged = 1;
					} else if (this._state.dragged === 1 && this._applyToFixedAndParseFloat(this._state.percentage[0], precision) > percentageWithAdjustedPrecision) {
						this._state.percentage[1] = this._state.percentage[0];
						this._state.dragged = 0;
					}
				}
			},
			_mouseup: function _mouseup() {
				if (!this._state.enabled) {
					return false;
				}
				if (this.touchCapable) {
					// Touch: Unbind touch event handlers:
					document.removeEventListener("touchmove", this.mousemove, false);
					document.removeEventListener("touchend", this.mouseup, false);
				}
				// Unbind mouse event handlers:
				document.removeEventListener("mousemove", this.mousemove, false);
				document.removeEventListener("mouseup", this.mouseup, false);

				this._state.inDrag = false;
				if (this._state.over === false) {
					this._hideTooltip();
				}
				var val = this._calculateValue(true);

				this._layout();
				this._setDataVal(val);
				this._trigger('slideStop', val);

				return false;
			},
			_calculateValue: function _calculateValue(snapToClosestTick) {
				var val;
				if (this.options.range) {
					val = [this.options.min, this.options.max];
					if (this._state.percentage[0] !== 0) {
						val[0] = this._toValue(this._state.percentage[0]);
						val[0] = this._applyPrecision(val[0]);
					}
					if (this._state.percentage[1] !== 100) {
						val[1] = this._toValue(this._state.percentage[1]);
						val[1] = this._applyPrecision(val[1]);
					}
				} else {
					val = this._toValue(this._state.percentage[0]);
					val = parseFloat(val);
					val = this._applyPrecision(val);
				}

				if (snapToClosestTick) {
					var min = [val, Infinity];
					for (var i = 0; i < this.options.ticks.length; i++) {
						var diff = Math.abs(this.options.ticks[i] - val);
						if (diff <= min[1]) {
							min = [this.options.ticks[i], diff];
						}
					}
					if (min[1] <= this.options.ticks_snap_bounds) {
						return min[0];
					}
				}

				return val;
			},
			_applyPrecision: function _applyPrecision(val) {
				var precision = this.options.precision || this._getNumDigitsAfterDecimalPlace(this.options.step);
				return this._applyToFixedAndParseFloat(val, precision);
			},
			_getNumDigitsAfterDecimalPlace: function _getNumDigitsAfterDecimalPlace(num) {
				var match = ('' + num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
				if (!match) {
					return 0;
				}
				return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));
			},
			_applyToFixedAndParseFloat: function _applyToFixedAndParseFloat(num, toFixedInput) {
				var truncatedNum = num.toFixed(toFixedInput);
				return parseFloat(truncatedNum);
			},
			/*
   	Credits to Mike Samuel for the following method!
   	Source: http://stackoverflow.com/questions/10454518/javascript-how-to-retrieve-the-number-of-decimals-of-a-string-number
   */
			_getPercentage: function _getPercentage(ev) {
				if (this.touchCapable && (ev.type === 'touchstart' || ev.type === 'touchmove')) {
					ev = ev.touches[0];
				}

				var eventPosition = ev[this.mousePos];
				var sliderOffset = this._state.offset[this.stylePos];
				var distanceToSlide = eventPosition - sliderOffset;
				// Calculate what percent of the length the slider handle has slid
				var percentage = distanceToSlide / this._state.size * 100;
				percentage = Math.round(percentage / this._state.percentage[2]) * this._state.percentage[2];
				if (this.options.reversed) {
					percentage = 100 - percentage;
				}

				// Make sure the percent is within the bounds of the slider.
				// 0% corresponds to the 'min' value of the slide
				// 100% corresponds to the 'max' value of the slide
				return Math.max(0, Math.min(100, percentage));
			},
			_validateInputValue: function _validateInputValue(val) {
				if (!isNaN(+val)) {
					return +val;
				} else if (Array.isArray(val)) {
					this._validateArray(val);
					return val;
				} else {
					throw new Error(ErrorMsgs.formatInvalidInputErrorMsg(val));
				}
			},
			_validateArray: function _validateArray(val) {
				for (var i = 0; i < val.length; i++) {
					var input = val[i];
					if (typeof input !== 'number') {
						throw new Error(ErrorMsgs.formatInvalidInputErrorMsg(input));
					}
				}
			},
			_setDataVal: function _setDataVal(val) {
				this.element.setAttribute('data-value', val);
				this.element.setAttribute('value', val);
				this.element.value = val;
			},
			_trigger: function _trigger(evt, val) {
				val = val || val === 0 ? val : undefined;

				var callbackFnArray = this.eventToCallbackMap[evt];
				if (callbackFnArray && callbackFnArray.length) {
					for (var i = 0; i < callbackFnArray.length; i++) {
						var callbackFn = callbackFnArray[i];
						callbackFn(val);
					}
				}

				/* If JQuery exists, trigger JQuery events */
				if ($) {
					this._triggerJQueryEvent(evt, val);
				}
			},
			_triggerJQueryEvent: function _triggerJQueryEvent(evt, val) {
				var eventData = {
					type: evt,
					value: val
				};
				this.$element.trigger(eventData);
				this.$sliderElem.trigger(eventData);
			},
			_unbindJQueryEventHandlers: function _unbindJQueryEventHandlers() {
				this.$element.off();
				this.$sliderElem.off();
			},
			_setText: function _setText(element, text) {
				if (typeof element.textContent !== "undefined") {
					element.textContent = text;
				} else if (typeof element.innerText !== "undefined") {
					element.innerText = text;
				}
			},
			_removeClass: function _removeClass(element, classString) {
				var classes = classString.split(" ");
				var newClasses = element.className;

				for (var i = 0; i < classes.length; i++) {
					var classTag = classes[i];
					var regex = new RegExp("(?:\\s|^)" + classTag + "(?:\\s|$)");
					newClasses = newClasses.replace(regex, " ");
				}

				element.className = newClasses.trim();
			},
			_addClass: function _addClass(element, classString) {
				var classes = classString.split(" ");
				var newClasses = element.className;

				for (var i = 0; i < classes.length; i++) {
					var classTag = classes[i];
					var regex = new RegExp("(?:\\s|^)" + classTag + "(?:\\s|$)");
					var ifClassExists = regex.test(newClasses);

					if (!ifClassExists) {
						newClasses += " " + classTag;
					}
				}

				element.className = newClasses.trim();
			},
			_offsetLeft: function _offsetLeft(obj) {
				return obj.getBoundingClientRect().left;
			},
			_offsetTop: function _offsetTop(obj) {
				var offsetTop = obj.offsetTop;
				while ((obj = obj.offsetParent) && !isNaN(obj.offsetTop)) {
					offsetTop += obj.offsetTop;
					if (obj.tagName !== 'BODY') {
						offsetTop -= obj.scrollTop;
					}
				}
				return offsetTop;
			},
			_offset: function _offset(obj) {
				return {
					left: this._offsetLeft(obj),
					top: this._offsetTop(obj)
				};
			},
			_css: function _css(elementRef, styleName, value) {
				if ($) {
					$.style(elementRef, styleName, value);
				} else {
					var style = styleName.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function (all, letter) {
						return letter.toUpperCase();
					});
					elementRef.style[style] = value;
				}
			},
			_toValue: function _toValue(percentage) {
				return this.options.scale.toValue.apply(this, [percentage]);
			},
			_toPercentage: function _toPercentage(value) {
				return this.options.scale.toPercentage.apply(this, [value]);
			},
			_setTooltipPosition: function _setTooltipPosition() {
				var tooltips = [this.tooltip, this.tooltip_min, this.tooltip_max];
				if (this.options.orientation === 'vertical') {
					var tooltipPos = this.options.tooltip_position || 'right';
					var oppositeSide = tooltipPos === 'left' ? 'right' : 'left';
					tooltips.forEach((function (tooltip) {
						this._addClass(tooltip, tooltipPos);
						tooltip.style[oppositeSide] = '100%';
					}).bind(this));
				} else if (this.options.tooltip_position === 'bottom') {
					tooltips.forEach((function (tooltip) {
						this._addClass(tooltip, 'bottom');
						tooltip.style.top = 22 + 'px';
					}).bind(this));
				} else {
					tooltips.forEach((function (tooltip) {
						this._addClass(tooltip, 'top');
						tooltip.style.top = -this.tooltip.outerHeight - 14 + 'px';
					}).bind(this));
				}
			}
		};

		/*********************************
  		Attach to global namespace
  	*********************************/
		if ($) {
			(function () {
				var autoRegisterNamespace = undefined;

				if (!$.fn.slider) {
					$.bridget(NAMESPACE_MAIN, Slider);
					autoRegisterNamespace = NAMESPACE_MAIN;
				} else {
					if (windowIsDefined) {
						window.console.warn("bootstrap-slider.js - WARNING: $.fn.slider namespace is already bound. Use the $.fn.bootstrapSlider namespace instead.");
					}
					autoRegisterNamespace = NAMESPACE_ALTERNATE;
				}
				$.bridget(NAMESPACE_ALTERNATE, Slider);

				// Auto-Register data-provide="slider" Elements
				$(function () {
					$("input[data-provide=slider]")[autoRegisterNamespace]();
				});
			})();
		}
	})($);

	return Slider;
});
;
/* ========================================================================
 * bootstrap-switch 
 * http://www.bootstrap-switch.org
 * ========================================================================
 * Copyright 2012-2013 Mattia Larentis
 *
 * ========================================================================
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================================
 */

(function () {
    (function ($) {
        $.fn.bootstrapSwitch = function (method) {
            var methods;
            methods = {
                init: function () {
                    return this.each(function () {
                        var $div, $element, $form, $label, $switchLeft, $switchRight, $wrapper, changeState;
                        $element = $(this);
                        $switchLeft = $("<span>", {
                            "class": "switch-left",
                            html: function () {
                                var html, label;
                                html = "ON";
                                label = $element.data("on-label");
                                if (label != null) {
                                    html = label;
                                }
                                return html;
                            }
                        });
                        $switchRight = $("<span>", {
                            "class": "switch-right",
                            html: function () {
                                var html, label;
                                html = "OFF";
                                label = $element.data("off-label");
                                if (label != null) {
                                    html = label;
                                }
                                return html;
                            }
                        });
                        $label = $("<label>", {
                            "for": $element.attr("id"),
                            html: function () {
                                var html, icon, label;
                                html = "&nbsp;";
                                icon = $element.data("label-icon");
                                label = $element.data("text-label");
                                if (icon != null) {
                                    html = "<i class=\"icon " + icon + "\"></i>";
                                }
                                if (label != null) {
                                    html = label;
                                }
                                return html;
                            }
                        });
                        $div = $("<div>");
                        $wrapper = $("<div>", {
                            "class": "has-switch",
                            tabindex: 0
                        });
                        $form = $element.closest("form");
                        changeState = function () {
                            if ($label.hasClass("label-change-switch")) {
                                return;
                            }
                            return $label.trigger("mousedown").trigger("mouseup").trigger("click");
                        };
                        $element.data("bootstrap-switch", true);
                        if ($element.data("on") != null) {
                            $switchLeft.addClass("switch-" + $element.data("on"));
                        }
                        if ($element.data("off") != null) {
                            $switchRight.addClass("switch-" + $element.data("off"));
                        }
                        $wrapper.data("animated", false);
                        if ($element.data("animated") !== false) {
                            $wrapper.addClass("switch-animate").data("animated", true);
                        }
                        $div = $element.wrap($div).parent();
                        $wrapper = $div.wrap($wrapper).parent();
                        if ($element.attr("class")) {
                            $.each(["switch-mini", "switch-small", "switch-large"], function (i, cls) {
                                if ($element.attr("class").indexOf(cls) >= 0) {
                                    return $wrapper.addClass(cls);
                                }
                            });
                        }
                        $element.before($switchLeft).before($label).before($switchRight);
                        $wrapper.addClass($element.is(":checked") ? "switch-on" : "switch-off");
                        if ($element.is(":disabled") || $element.is("[readonly]")) {
                            $wrapper.addClass("disabled");
                        }
                        $element.on("keydown", function (e) {
                            if (e.keyCode !== 32) {
                                return;
                            }
                            e.stopImmediatePropagation();
                            e.preventDefault();
                            return changeState();
                        }).on("change", function (e, skip) {
                            var isChecked, state;
                            isChecked = $element.is(":checked");
                            state = $wrapper.hasClass("switch-off");
                            e.preventDefault();
                            $div.css("left", "");
                            if (state !== isChecked) {
                                return;
                            }
                            if (isChecked) {
                                $wrapper.removeClass("switch-off").addClass("switch-on");
                            } else {
                                $wrapper.removeClass("switch-on").addClass("switch-off");
                            }
                            if ($wrapper.data("animated") !== false) {
                                $wrapper.addClass("switch-animate");
                            }
                            if (typeof skip === "boolean" && skip) {
                                return;
                            }
                            return $element.trigger("switch-change", {
                                el: $element,
                                value: isChecked
                            });
                        });
                        $wrapper.on("keydown", function (e) {
                            if (!e.which || $element.is(":disabled") || $element.is("[readonly]")) {
                                return;
                            }
                            switch (e.which) {
                                case 32:
                                    e.preventDefault();
                                    return changeState();
                                case 37:
                                    e.preventDefault();
                                    if ($element.is(":checked")) {
                                        return changeState();
                                    }
                                    break;
                                case 39:
                                    e.preventDefault();
                                    if (!$element.is(":checked")) {
                                        return changeState();
                                    }
                            }
                        });
                        $switchLeft.on("click", function () {
                            return changeState();
                        });
                        $switchRight.on("click", function () {
                            return changeState();
                        });
                        $label.on("mousedown touchstart", function (e) {
                            var moving;
                            moving = false;
                            e.preventDefault();
                            e.stopImmediatePropagation();
                            $wrapper.removeClass("switch-animate");
                            if ($element.is(":disabled") || $element.is("[readonly]") || $element.hasClass("radio-no-uncheck")) {
                                return $label.unbind("click");
                            }
                            return $label.on("mousemove touchmove", function (e) {
                                var left, percent, relativeX, right;
                                relativeX = (e.pageX || e.originalEvent.targetTouches[0].pageX) - $wrapper.offset().left;
                                percent = (relativeX / $wrapper.width()) * 100;
                                left = 25;
                                right = 75;
                                moving = true;
                                if (percent < left) {
                                    percent = left;
                                } else if (percent > right) {
                                    percent = right;
                                }
                                return $div.css("left", (percent - right) + "%");
                            }).on("click touchend", function (e) {
                                e.stopImmediatePropagation();
                                e.preventDefault();
                                $label.unbind("mouseleave");
                                if (moving) {
                                    $element.prop("checked", parseInt($label.parent().css("left"), 10) > -25);
                                } else {
                                    $element.prop("checked", !$element.is(":checked"));
                                }
                                moving = false;
                                return $element.trigger("change");
                            }).on("mouseleave", function (e) {
                                e.preventDefault();
                                e.stopImmediatePropagation();
                                $label.unbind("mouseleave mousemove").trigger("mouseup");
                                return $element.prop("checked", parseInt($label.parent().css("left"), 10) > -25).trigger("change");
                            }).on("mouseup", function (e) {
                                e.stopImmediatePropagation();
                                e.preventDefault();
                                return $label.trigger("mouseleave");
                            });
                        });
                        if (!$form.data("bootstrap-switch")) {
                            return $form.bind("reset", function () {
                                return window.setTimeout(function () {
                                    return $form.find(".has-switch").each(function () {
                                        var $input;
                                        $input = $(this).find("input");
                                        return $input.prop("checked", $input.is(":checked")).trigger("change");
                                    });
                                }, 1);
                            }).data("bootstrap-switch", true);
                        }
                    });
                },
                setDisabled: function (disabled) {
                    var $element, $wrapper;
                    $element = $(this);
                    $wrapper = $element.parents(".has-switch");
                    if (disabled) {
                        $wrapper.addClass("disabled");
                        $element.prop("disabled", true);
                    } else {
                        $wrapper.removeClass("disabled");
                        $element.prop("disabled", false);
                    }
                    return $element;
                },
                toggleDisabled: function () {
                    var $element;
                    $element = $(this);
                    $element.prop("disabled", !$element.is(":disabled")).parents(".has-switch").toggleClass("disabled");
                    return $element;
                },
                isDisabled: function () {
                    return $(this).is(":disabled");
                },
                setReadOnly: function (readonly) {
                    var $element, $wrapper;
                    $element = $(this);
                    $wrapper = $element.parents(".has-switch");
                    if (readonly) {
                        $wrapper.addClass("disabled");
                        $element.prop("readonly", true);
                    } else {
                        $wrapper.removeClass("disabled");
                        $element.prop("readonly", false);
                    }
                    return $element;
                },
                toggleReadOnly: function () {
                    var $element;
                    $element = $(this);
                    $element.prop("readonly", !$element.is("[readonly]")).parents(".has-switch").toggleClass("disabled");
                    return $element;
                },
                isReadOnly: function () {
                    return $(this).is("[readonly]");
                },
                toggleState: function (skip) {
                    var $element;
                    $element = $(this);
                    $element.prop("checked", !$element.is(":checked")).trigger("change", skip);
                    return $element;
                },
                toggleRadioState: function (skip) {
                    var $element;
                    $element = $(this);
                    $element.not(":checked").prop("checked", !$element.is(":checked")).trigger("change", skip);
                    return $element;
                },
                toggleRadioStateAllowUncheck: function (uncheck, skip) {
                    var $element;
                    $element = $(this);
                    if (uncheck) {
                        $element.not(":checked").trigger("change", skip);
                    } else {
                        $element.not(":checked").prop("checked", !$element.is(":checked")).trigger("change", skip);
                    }
                    return $element;
                },
                setState: function (value, skip) {
                    var $element;
                    $element = $(this);
                    $element.prop("checked", value).trigger("change", skip);
                    return $element;
                },
                setOnLabel: function (value) {
                    var $element;
                    $element = $(this);
                    $element.siblings(".switch-left").html(value);
                    return $element;
                },
                setOffLabel: function (value) {
                    var $element;
                    $element = $(this);
                    $element.siblings(".switch-right").html(value);
                    return $element;
                },
                setOnClass: function (value) {
                    var $element, $switchLeft, cls;
                    $element = $(this);
                    $switchLeft = $element.siblings(".switch-left");
                    cls = $element.attr("data-on");
                    if (value == null) {
                        return;
                    }
                    if (cls != null) {
                        $switchLeft.removeClass("switch-" + cls);
                    }
                    $switchLeft.addClass("switch-" + value);
                    return $element;
                },
                setOffClass: function (value) {
                    var $element, $switchRight, cls;
                    $element = $(this);
                    $switchRight = $element.siblings(".switch-right");
                    cls = $element.attr("data-off");
                    if (value == null) {
                        return;
                    }
                    if (cls != null) {
                        $switchRight.removeClass("switch-" + cls);
                    }
                    $switchRight.addClass("switch-" + value);
                    return $element;
                },
                setAnimated: function (value) {
                    var $element, $wrapper;
                    $element = $(this);
                    $wrapper = $element.parents(".has-switch");
                    if (value == null) {
                        value = false;
                    }
                    $wrapper.data("animated", value).attr("data-animated", value)[$wrapper.data("animated") !== false ? "addClass" : "removeClass"]("switch-animate");
                    return $element;
                },
                setSizeClass: function (value) {
                    var $element, $wrapper;
                    $element = $(this);
                    $wrapper = $element.parents(".has-switch");
                    $.each(["switch-mini", "switch-small", "switch-large"], function (i, cls) {
                        return $wrapper[cls !== value ? "removeClass" : "addClass"](cls);
                    });
                    return $element;
                },
                setTextLabel: function (value) {
                    var $element;
                    $element = $(this);
                    $element.siblings("label").html(value || "&nbsp");
                    return $element;
                },
                setTextIcon: function (value) {
                    var $element;
                    $element = $(this);
                    $element.siblings("label").html(value ? "<i class=\"icon " + value + "\"></i>" : "&nbsp;");
                    return $element;
                },
                state: function () {
                    return $(this).is(":checked");
                },
                destroy: function () {
                    var $div, $element, $form;
                    $element = $(this);
                    $div = $element.parent();
                    $form = $div.closest("form");
                    $div.children().not($element).remove();
                    $element.unwrap().unwrap().off("change");
                    if ($form.length) {
                        $form.off("reset").removeData("bootstrap-switch");
                    }
                    return $element;
                }
            };
            if (methods[method]) {
                return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
            }
            if (typeof method === "object" || !method) {
                return methods.init.apply(this, arguments);
            }
            return $.error("Method " + method + " does not exist!");
        };
        return this;
    })(jQuery);

}).call(this);
;
/*
 * Gritter for jQuery
 * http://www.boedesign.com/
 *
 * Copyright (c) 2012 Jordan Boesch
 * Dual licensed under the MIT and GPL licenses.
 *
 * Date: February 24, 2012
 */

(function($){
    
    /**
    * Set it up as an object under the jQuery namespace
    */
    $.gritter = {};
    
    /**
    * Set up global options that the user can over-ride
    */
    $.gritter.options = {
        position: '',
        class_name: '', // could be set to 'gritter-light' to use white notifications
        fade_in_speed: 'medium', // how fast notifications fade in
        fade_out_speed: 1000, // how fast the notices fade out
        time: 6000 // hang on the screen for...
    }
    
    /**
    * Add a gritter notification to the screen
    * @see Gritter#add();
    */
    $.gritter.add = function(params){

        try {
            return Gritter.add(params || {});
        } catch(e) {
        
            var err = 'Gritter Error: ' + e;
            (typeof(console) != 'undefined' && console.error) ? 
                console.error(err, params) : 
                alert(err);
                
        }
        
    }
    
    /**
    * Remove a gritter notification from the screen
    * @see Gritter#removeSpecific();
    */
    $.gritter.remove = function(id, params){
        Gritter.removeSpecific(id, params || {});
    }
    
    /**
    * Remove all notifications
    * @see Gritter#stop();
    */
    $.gritter.removeAll = function(params){
        Gritter.stop(params || {});
    }
    
    /**
    * Big fat Gritter object
    * @constructor (not really since its object literal)
    */
    var Gritter = {
        
        // Public - options to over-ride with $.gritter.options in "add"
        position: '',
        fade_in_speed: '',
        fade_out_speed: '',
        time: '',
        
        // Private - no touchy the private parts
        _custom_timer: 0,
        _item_count: 0,
        _is_setup: 0,
        _tpl_close: '<div class="gritter-close"></div>',
        _tpl_title: '<span class="gritter-title">[[title]]</span>',
        _tpl_item: '<div id="gritter-item-[[number]]" class="gritter-item-wrapper [[item_class]]" style="display:none"><div class="gritter-top"></div><div class="gritter-item">[[close]][[image]]<div class="[[class_name]]">[[title]]<p>[[text]]</p></div><div style="clear:both"></div></div><div class="gritter-bottom"></div></div>',
        _tpl_wrap: '<div id="gritter-notice-wrapper"></div>',
        
        /**
        * Add a gritter notification to the screen
        * @param {Object} params The object that contains all the options for drawing the notification
        * @return {Integer} The specific numeric id to that gritter notification
        */
        add: function(params){
            // Handle straight text
            if(typeof(params) == 'string'){
                params = {text:params};
            }

            // We might have some issues if we don't have a title or text!
            if(params.text === null){
                throw 'You must supply "text" parameter.'; 
            }
            
            // Check the options and set them once
            if(!this._is_setup){
                this._runSetup();
            }
            
            // Basics
            var title = params.title, 
                text = params.text,
                image = params.image || '',
                sticky = params.sticky || false,
                item_class = params.class_name || $.gritter.options.class_name,
                position = $.gritter.options.position,
                time_alive = params.time || '';

            this._verifyWrapper();
            
            this._item_count++;
            var number = this._item_count, 
                tmp = this._tpl_item;
            
            // Assign callbacks
            $(['before_open', 'after_open', 'before_close', 'after_close']).each(function(i, val){
                Gritter['_' + val + '_' + number] = ($.isFunction(params[val])) ? params[val] : function(){}
            });

            // Reset
            this._custom_timer = 0;
            
            // A custom fade time set
            if(time_alive){
                this._custom_timer = time_alive;
            }
            
            var image_str = (image != '') ? '<img src="' + image + '" class="gritter-image" />' : '',
                class_name = (image != '') ? 'gritter-with-image' : 'gritter-without-image';
            
            // String replacements on the template
            if(title){
                title = this._str_replace('[[title]]',title,this._tpl_title);
            }else{
                title = '';
            }
            
            tmp = this._str_replace(
                ['[[title]]', '[[text]]', '[[close]]', '[[image]]', '[[number]]', '[[class_name]]', '[[item_class]]'],
                [title, text, this._tpl_close, image_str, this._item_count, class_name, item_class], tmp
            );

            // If it's false, don't show another gritter message
            if(this['_before_open_' + number]() === false){
                return false;
            }

            $('#gritter-notice-wrapper').addClass(position).append(tmp);
            
            var item = $('#gritter-item-' + this._item_count);
            
            item.fadeIn(this.fade_in_speed, function(){
                Gritter['_after_open_' + number]($(this));
            });
            
            if(!sticky){
                this._setFadeTimer(item, number);
            }
            
            // Bind the hover/unhover states
            $(item).bind('mouseenter mouseleave', function(event){
                if(event.type == 'mouseenter'){
                    if(!sticky){ 
                        Gritter._restoreItemIfFading($(this), number);
                    }
                }
                else {
                    if(!sticky){
                        Gritter._setFadeTimer($(this), number);
                    }
                }
                Gritter._hoverState($(this), event.type);
            });
            
            // Clicking (X) makes the perdy thing close
            $(item).find('.gritter-close').click(function(){
                Gritter.removeSpecific(number, {}, null, true);
            });
            
            return number;
        
        },
        
        /**
        * If we don't have any more gritter notifications, get rid of the wrapper using this check
        * @private
        * @param {Integer} unique_id The ID of the element that was just deleted, use it for a callback
        * @param {Object} e The jQuery element that we're going to perform the remove() action on
        * @param {Boolean} manual_close Did we close the gritter dialog with the (X) button
        */
        _countRemoveWrapper: function(unique_id, e, manual_close){
            
            // Remove it then run the callback function
            e.remove();
            this['_after_close_' + unique_id](e, manual_close);
            
            // Check if the wrapper is empty, if it is.. remove the wrapper
            if($('.gritter-item-wrapper').length == 0){
                $('#gritter-notice-wrapper').remove();
            }
        
        },
        
        /**
        * Fade out an element after it's been on the screen for x amount of time
        * @private
        * @param {Object} e The jQuery element to get rid of
        * @param {Integer} unique_id The id of the element to remove
        * @param {Object} params An optional list of params to set fade speeds etc.
        * @param {Boolean} unbind_events Unbind the mouseenter/mouseleave events if they click (X)
        */
        _fade: function(e, unique_id, params, unbind_events){

            var params = params || {},
                fade = (typeof(params.fade) != 'undefined') ? params.fade : true,
                fade_out_speed = params.speed || this.fade_out_speed,
                manual_close = unbind_events;

            this['_before_close_' + unique_id](e, manual_close);
            
            // If this is true, then we are coming from clicking the (X)
            if(unbind_events){
                e.unbind('mouseenter mouseleave');
            }
            
            // Fade it out or remove it
            if(fade){
            
                e.animate({
                    opacity: 0
                }, fade_out_speed, function(){
                    e.animate({ height: 0 }, 300, function(){
                        Gritter._countRemoveWrapper(unique_id, e, manual_close);
                    })
                })
                
            }
            else {
                
                this._countRemoveWrapper(unique_id, e);
                
            }
                        
        },
        
        /**
        * Perform actions based on the type of bind (mouseenter, mouseleave) 
        * @private
        * @param {Object} e The jQuery element
        * @param {String} type The type of action we're performing: mouseenter or mouseleave
        */
        _hoverState: function(e, type){
            
            // Change the border styles and add the (X) close button when you hover
            if(type == 'mouseenter'){
                
                e.addClass('hover');
                
                // Show close button
                e.find('.gritter-close').show();
                        
            }
            // Remove the border styles and hide (X) close button when you mouse out
            else {
                
                e.removeClass('hover');
                
                // Hide close button
                e.find('.gritter-close').hide();
                
            }
            
        },
        
        /**
        * Remove a specific notification based on an ID
        * @param {Integer} unique_id The ID used to delete a specific notification
        * @param {Object} params A set of options passed in to determine how to get rid of it
        * @param {Object} e The jQuery element that we're "fading" then removing
        * @param {Boolean} unbind_events If we clicked on the (X) we set this to true to unbind mouseenter/mouseleave
        */
        removeSpecific: function(unique_id, params, e, unbind_events){
            
            if(!e){
                var e = $('#gritter-item-' + unique_id);
            }

            // We set the fourth param to let the _fade function know to 
            // unbind the "mouseleave" event.  Once you click (X) there's no going back!
            this._fade(e, unique_id, params || {}, unbind_events);
            
        },
        
        /**
        * If the item is fading out and we hover over it, restore it!
        * @private
        * @param {Object} e The HTML element to remove
        * @param {Integer} unique_id The ID of the element
        */
        _restoreItemIfFading: function(e, unique_id){
            
            clearTimeout(this['_int_id_' + unique_id]);
            e.stop().css({ opacity: '', height: '' });
            
        },
        
        /**
        * Setup the global options - only once
        * @private
        */
        _runSetup: function(){
        
            for(opt in $.gritter.options){
                this[opt] = $.gritter.options[opt];
            }
            this._is_setup = 1;
            
        },
        
        /**
        * Set the notification to fade out after a certain amount of time
        * @private
        * @param {Object} item The HTML element we're dealing with
        * @param {Integer} unique_id The ID of the element
        */
        _setFadeTimer: function(e, unique_id){
            
            var timer_str = (this._custom_timer) ? this._custom_timer : this.time;
            this['_int_id_' + unique_id] = setTimeout(function(){ 
                Gritter._fade(e, unique_id);
            }, timer_str);
        
        },
        
        /**
        * Bring everything to a halt
        * @param {Object} params A list of callback functions to pass when all notifications are removed
        */  
        stop: function(params){
            
            // callbacks (if passed)
            var before_close = ($.isFunction(params.before_close)) ? params.before_close : function(){};
            var after_close = ($.isFunction(params.after_close)) ? params.after_close : function(){};
            
            var wrap = $('#gritter-notice-wrapper');
            before_close(wrap);

            if (wrap.length > 0) {
                wrap.fadeOut(function() {
                    $(this).remove();
                    after_close();
                });
            } else {
                after_close();
            }

        },
        
        /**
        * An extremely handy PHP function ported to JS, works well for templating
        * @private
        * @param {String/Array} search A list of things to search for
        * @param {String/Array} replace A list of things to replace the searches with
        * @return {String} sa The output
        */  
        _str_replace: function(search, replace, subject, count){
        
            var i = 0, j = 0, temp = '', repl = '', sl = 0, fl = 0,
                f = [].concat(search),
                r = [].concat(replace),
                s = subject,
                ra = r instanceof Array, sa = s instanceof Array;
            s = [].concat(s);
            
            if(count){
                this.window[count] = 0;
            }
        
            for(i = 0, sl = s.length; i < sl; i++){
                
                if(s[i] === ''){
                    continue;
                }
                
                for (j = 0, fl = f.length; j < fl; j++){
                    
                    temp = s[i] + '';
                    repl = ra ? (r[j] !== undefined ? r[j] : '') : r[0];
                    s[i] = (temp).split(f[j]).join(repl);
                    
                    if(count && s[i] !== temp){
                        this.window[count] += (temp.length-s[i].length) / f[j].length;
                    }
                    
                }
            }
            
            return sa ? s : s[0];
            
        },
        
        /**
        * A check to make sure we have something to wrap our notices with
        * @private
        */  
        _verifyWrapper: function(){
          
            if($('#gritter-notice-wrapper').length == 0){
                $('body').append(this._tpl_wrap);
            }
        
        }
        
    }
    
})(jQuery);
;
/*!
 * Nestable jQuery Plugin - Copyright (c) 2012 David Bushell - http://dbushell.com/
 * Dual-licensed under the BSD or MIT licenses
 */
; (function ($, window, document, undefined) {
    var hasTouch = 'ontouchstart' in window;

    /**
     * Detect CSS pointer-events property
     * events are normally disabled on the dragging element to avoid conflicts
     * https://github.com/ausi/Feature-detection-technique-for-pointer-events/blob/master/modernizr-pointerevents.js
     */
    var hasPointerEvents = (function () {
        var el = document.createElement('div'),
            docEl = document.documentElement;
        if (!('pointerEvents' in el.style)) {
            return false;
        }
        el.style.pointerEvents = 'auto';
        el.style.pointerEvents = 'x';
        docEl.appendChild(el);
        var supports = window.getComputedStyle && window.getComputedStyle(el, '').pointerEvents === 'auto';
        docEl.removeChild(el);
        return !!supports;
    })();

    var eStart = hasTouch ? 'touchstart' : 'mousedown',
        eMove = hasTouch ? 'touchmove' : 'mousemove',
        eEnd = hasTouch ? 'touchend' : 'mouseup';
    eCancel = hasTouch ? 'touchcancel' : 'mouseup';

    var defaults = {
        listNodeName: 'ol',
        itemNodeName: 'li',
        rootClass: 'dd',
        listClass: 'dd-list',
        itemClass: 'dd-item',
        dragClass: 'dd-dragel',
        handleClass: 'dd-handle',
        collapsedClass: 'dd-collapsed',
        placeClass: 'dd-placeholder',
        noDragClass: 'dd-nodrag',
        emptyClass: 'dd-empty',
        expandBtnHTML: '<button data-action="expand" type="button">Expand</button>',
        collapseBtnHTML: '<button data-action="collapse" type="button">Collapse</button>',
        group: 0,
        maxDepth: 5,
        threshold: 20
    };

    function Plugin(element, options) {
        this.w = $(window);
        this.el = $(element);
        this.options = $.extend({}, defaults, options);
        this.init();
    }

    Plugin.prototype = {

        init: function () {
            var list = this;

            list.reset();

            list.el.data('nestable-group', this.options.group);

            list.placeEl = $('<div class="' + list.options.placeClass + '"/>');

            $.each(this.el.find(list.options.itemNodeName), function (k, el) {
                list.setParent($(el));
            });

            list.el.on('click', 'button', function (e) {
                if (list.dragEl || (!hasTouch && e.button !== 0)) {
                    return;
                }
                var target = $(e.currentTarget),
                    action = target.data('action'),
                    item = target.parent(list.options.itemNodeName);
                if (action === 'collapse') {
                    list.collapseItem(item);
                }
                if (action === 'expand') {
                    list.expandItem(item);
                }
            });

            var onStartEvent = function (e) {
                var handle = $(e.target);
                if (!handle.hasClass(list.options.handleClass)) {
                    if (handle.closest('.' + list.options.noDragClass).length) {
                        return;
                    }
                    handle = handle.closest('.' + list.options.handleClass);
                }
                if (!handle.length || list.dragEl || (!hasTouch && e.button !== 0) || (hasTouch && e.touches.length !== 1)) {
                    return;
                }
                e.preventDefault();
                list.dragStart(hasTouch ? e.touches[0] : e);
            };

            var onMoveEvent = function (e) {
                if (list.dragEl) {
                    e.preventDefault();
                    list.dragMove(hasTouch ? e.touches[0] : e);
                }
            };

            var onEndEvent = function (e) {
                if (list.dragEl) {
                    e.preventDefault();
                    list.dragStop(hasTouch ? e.touches[0] : e);
                }
            };

            if (hasTouch) {
                list.el[0].addEventListener(eStart, onStartEvent, false);
                window.addEventListener(eMove, onMoveEvent, false);
                window.addEventListener(eEnd, onEndEvent, false);
                window.addEventListener(eCancel, onEndEvent, false);
            } else {
                list.el.on(eStart, onStartEvent);
                list.w.on(eMove, onMoveEvent);
                list.w.on(eEnd, onEndEvent);
            }

        },

        serialize: function () {
            var data,
                depth = 0,
                list = this;
            step = function (level, depth) {
                var array = [],
                    items = level.children(list.options.itemNodeName);
                items.each(function () {
                    var li = $(this),
                        item = $.extend({}, li.data()),
                        sub = li.children(list.options.listNodeName);
                    if (sub.length) {
                        item.children = step(sub, depth + 1);
                    }
                    array.push(item);
                });
                return array;
            };
            data = step(list.el.find(list.options.listNodeName).first(), depth);
            return data;
        },

        serialise: function () {
            return this.serialize();
        },

        reset: function () {
            this.mouse = {
                offsetX: 0,
                offsetY: 0,
                startX: 0,
                startY: 0,
                lastX: 0,
                lastY: 0,
                nowX: 0,
                nowY: 0,
                distX: 0,
                distY: 0,
                dirAx: 0,
                dirX: 0,
                dirY: 0,
                lastDirX: 0,
                lastDirY: 0,
                distAxX: 0,
                distAxY: 0
            };
            this.moving = false;
            this.dragEl = null;
            this.dragRootEl = null;
            this.dragDepth = 0;
            this.hasNewRoot = false;
            this.pointEl = null;
        },

        expandItem: function (li) {
            li.removeClass(this.options.collapsedClass);
            li.children('[data-action="expand"]').hide();
            li.children('[data-action="collapse"]').show();
            li.children(this.options.listNodeName).show();
        },

        collapseItem: function (li) {
            var lists = li.children(this.options.listNodeName);
            if (lists.length) {
                li.addClass(this.options.collapsedClass);
                li.children('[data-action="collapse"]').hide();
                li.children('[data-action="expand"]').show();
                li.children(this.options.listNodeName).hide();
            }
        },

        expandAll: function () {
            var list = this;
            list.el.find(list.options.itemNodeName).each(function () {
                list.expandItem($(this));
            });
        },

        collapseAll: function () {
            var list = this;
            list.el.find(list.options.itemNodeName).each(function () {
                list.collapseItem($(this));
            });
        },

        setParent: function (li) {
            if (li.children(this.options.listNodeName).length) {
                li.prepend($(this.options.expandBtnHTML));
                li.prepend($(this.options.collapseBtnHTML));
            }
            li.children('[data-action="expand"]').hide();
        },

        unsetParent: function (li) {
            li.removeClass(this.options.collapsedClass);
            li.children('[data-action]').remove();
            li.children(this.options.listNodeName).remove();
        },

        dragStart: function (e) {
            var mouse = this.mouse,
                target = $(e.target),
                dragItem = target.closest(this.options.itemNodeName);

            this.placeEl.css('height', dragItem.height());

            mouse.offsetX = e.offsetX !== undefined ? e.offsetX : e.pageX - target.offset().left;
            mouse.offsetY = e.offsetY !== undefined ? e.offsetY : e.pageY - target.offset().top;
            mouse.startX = mouse.lastX = e.pageX;
            mouse.startY = mouse.lastY = e.pageY;

            this.dragRootEl = this.el;

            this.dragEl = $(document.createElement(this.options.listNodeName)).addClass(this.options.listClass + ' ' + this.options.dragClass);
            this.dragEl.css('width', dragItem.width());

            // fix for zepto.js
            //dragItem.after(this.placeEl).detach().appendTo(this.dragEl);
            dragItem.after(this.placeEl);
            dragItem[0].parentNode.removeChild(dragItem[0]);
            dragItem.appendTo(this.dragEl);

            $(document.body).append(this.dragEl);
            this.dragEl.css({
                'left': e.pageX - mouse.offsetX,
                'top': e.pageY - mouse.offsetY
            });
            // total depth of dragging item
            var i, depth,
                items = this.dragEl.find(this.options.itemNodeName);
            for (i = 0; i < items.length; i++) {
                depth = $(items[i]).parents(this.options.listNodeName).length;
                if (depth > this.dragDepth) {
                    this.dragDepth = depth;
                }
            }
        },

        dragStop: function (e) {
            // fix for zepto.js
            //this.placeEl.replaceWith(this.dragEl.children(this.options.itemNodeName + ':first').detach());
            var el = this.dragEl.children(this.options.itemNodeName).first();
            el[0].parentNode.removeChild(el[0]);
            this.placeEl.replaceWith(el);

            this.dragEl.remove();
            this.el.trigger('change');
            if (this.hasNewRoot) {
                this.dragRootEl.trigger('change');
            }
            this.reset();
        },

        dragMove: function (e) {
            var list, parent, prev, next, depth,
                opt = this.options,
                mouse = this.mouse;

            this.dragEl.css({
                'left': e.pageX - mouse.offsetX,
                'top': e.pageY - mouse.offsetY
            });

            // mouse position last events
            mouse.lastX = mouse.nowX;
            mouse.lastY = mouse.nowY;
            // mouse position this events
            mouse.nowX = e.pageX;
            mouse.nowY = e.pageY;
            // distance mouse moved between events
            mouse.distX = mouse.nowX - mouse.lastX;
            mouse.distY = mouse.nowY - mouse.lastY;
            // direction mouse was moving
            mouse.lastDirX = mouse.dirX;
            mouse.lastDirY = mouse.dirY;
            // direction mouse is now moving (on both axis)
            mouse.dirX = mouse.distX === 0 ? 0 : mouse.distX > 0 ? 1 : -1;
            mouse.dirY = mouse.distY === 0 ? 0 : mouse.distY > 0 ? 1 : -1;
            // axis mouse is now moving on
            var newAx = Math.abs(mouse.distX) > Math.abs(mouse.distY) ? 1 : 0;

            // do nothing on first move
            if (!mouse.moving) {
                mouse.dirAx = newAx;
                mouse.moving = true;
                return;
            }

            // calc distance moved on this axis (and direction)
            if (mouse.dirAx !== newAx) {
                mouse.distAxX = 0;
                mouse.distAxY = 0;
            } else {
                mouse.distAxX += Math.abs(mouse.distX);
                if (mouse.dirX !== 0 && mouse.dirX !== mouse.lastDirX) {
                    mouse.distAxX = 0;
                }
                mouse.distAxY += Math.abs(mouse.distY);
                if (mouse.dirY !== 0 && mouse.dirY !== mouse.lastDirY) {
                    mouse.distAxY = 0;
                }
            }
            mouse.dirAx = newAx;

            /**
             * move horizontal
             */
            if (mouse.dirAx && mouse.distAxX >= opt.threshold) {
                // reset move distance on x-axis for new phase
                mouse.distAxX = 0;
                prev = this.placeEl.prev(opt.itemNodeName);
                // increase horizontal level if previous sibling exists and is not collapsed
                if (mouse.distX > 0 && prev.length && !prev.hasClass(opt.collapsedClass)) {
                    // cannot increase level when item above is collapsed
                    list = prev.find(opt.listNodeName).last();
                    // check if depth limit has reached
                    depth = this.placeEl.parents(opt.listNodeName).length;
                    if (depth + this.dragDepth <= opt.maxDepth) {
                        // create new sub-level if one doesn't exist
                        if (!list.length) {
                            list = $('<' + opt.listNodeName + '/>').addClass(opt.listClass);
                            list.append(this.placeEl);
                            prev.append(list);
                            this.setParent(prev);
                        } else {
                            // else append to next level up
                            list = prev.children(opt.listNodeName).last();
                            list.append(this.placeEl);
                        }
                    }
                }
                // decrease horizontal level
                if (mouse.distX < 0) {
                    // we can't decrease a level if an item preceeds the current one
                    next = this.placeEl.next(opt.itemNodeName);
                    if (!next.length) {
                        parent = this.placeEl.parent();
                        this.placeEl.closest(opt.itemNodeName).after(this.placeEl);
                        if (!parent.children().length) {
                            this.unsetParent(parent.parent());
                        }
                    }
                }
            }

            var isEmpty = false;

            // find list item under cursor
            if (!hasPointerEvents) {
                this.dragEl[0].style.visibility = 'hidden';
            }
            this.pointEl = $(document.elementFromPoint(e.pageX - document.body.scrollLeft, e.pageY - (window.pageYOffset || document.documentElement.scrollTop)));
            if (!hasPointerEvents) {
                this.dragEl[0].style.visibility = 'visible';
            }
            if (this.pointEl.hasClass(opt.handleClass)) {
                this.pointEl = this.pointEl.parent(opt.itemNodeName);
            }
            if (this.pointEl.hasClass(opt.emptyClass)) {
                isEmpty = true;
            }
            else if (!this.pointEl.length || !this.pointEl.hasClass(opt.itemClass)) {
                return;
            }

            // find parent list of item under cursor
            var pointElRoot = this.pointEl.closest('.' + opt.rootClass),
                isNewRoot = this.dragRootEl.data('nestable-id') !== pointElRoot.data('nestable-id');

            /**
             * move vertical
             */
            if (!mouse.dirAx || isNewRoot || isEmpty) {
                // check if groups match if dragging over new root
                if (isNewRoot && opt.group !== pointElRoot.data('nestable-group')) {
                    return;
                }
                // check depth limit
                depth = this.dragDepth - 1 + this.pointEl.parents(opt.listNodeName).length;
                if (depth > opt.maxDepth) {
                    return;
                }
                var before = e.pageY < (this.pointEl.offset().top + this.pointEl.height() / 2);
                parent = this.placeEl.parent();
                // if empty create new list to replace empty placeholder
                if (isEmpty) {
                    list = $(document.createElement(opt.listNodeName)).addClass(opt.listClass);
                    list.append(this.placeEl);
                    this.pointEl.replaceWith(list);
                }
                else if (before) {
                    this.pointEl.before(this.placeEl);
                }
                else {
                    this.pointEl.after(this.placeEl);
                }
                if (!parent.children().length) {
                    this.unsetParent(parent.parent());
                }
                if (!this.dragRootEl.find(opt.itemNodeName).length) {
                    this.dragRootEl.append('<div class="' + opt.emptyClass + '"/>');
                }
                // parent root list has changed
                if (isNewRoot) {
                    this.dragRootEl = pointElRoot;
                    this.hasNewRoot = this.el[0] !== this.dragRootEl[0];
                }
            }
        }

    };

    $.fn.nestable = function (params) {
        var lists = this,
            retval = this;

        lists.each(function () {
            var plugin = $(this).data("nestable");

            if (!plugin) {
                $(this).data("nestable", new Plugin(this, params));
                $(this).data("nestable-id", new Date().getTime());
            } else {
                if (typeof params === 'string' && typeof plugin[params] === 'function') {
                    retval = plugin[params]();
                }
            }
        });

        return retval || lists;
    };

})(window.jQuery || window.Zepto, window, document);;
/*
Copyright 2014 Igor Vaynberg

Version: 3.5.4 Timestamp: Sun Aug 30 13:30:32 EDT 2015

This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
General Public License version 2 (the "GPL License"). You may choose either license to govern your
use of this software only upon the condition that you accept all of the terms of either the Apache
License or the GPL License.

You may obtain a copy of the Apache License and the GPL License at:

http://www.apache.org/licenses/LICENSE-2.0
http://www.gnu.org/licenses/gpl-2.0.html

Unless required by applicable law or agreed to in writing, software distributed under the Apache License
or the GPL License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
either express or implied. See the Apache License and the GPL License for the specific language governing
permissions and limitations under the Apache License and the GPL License.
*/
!function(a){"undefined"==typeof a.fn.each2&&a.extend(a.fn,{each2:function(b){for(var c=a([0]),d=-1,e=this.length;++d<e&&(c.context=c[0]=this[d])&&b.call(c[0],d,c)!==!1;);return this}})}(jQuery),function(a,b){"use strict";function n(b){var c=a(document.createTextNode(""));b.before(c),c.before(b),c.remove()}function o(a){function b(a){return m[a]||a}return a.replace(/[^\u0000-\u007E]/g,b)}function p(a,b){for(var c=0,d=b.length;d>c;c+=1)if(r(a,b[c]))return c;return-1}function q(){var b=a(l);b.appendTo(document.body);var c={width:b.width()-b[0].clientWidth,height:b.height()-b[0].clientHeight};return b.remove(),c}function r(a,c){return a===c?!0:a===b||c===b?!1:null===a||null===c?!1:a.constructor===String?a+""==c+"":c.constructor===String?c+""==a+"":!1}function s(a,b,c){var d,e,f;if(null===a||a.length<1)return[];for(d=a.split(b),e=0,f=d.length;f>e;e+=1)d[e]=c(d[e]);return d}function t(a){return a.outerWidth(!1)-a.width()}function u(c){var d="keyup-change-value";c.on("keydown",function(){a.data(c,d)===b&&a.data(c,d,c.val())}),c.on("keyup",function(){var e=a.data(c,d);e!==b&&c.val()!==e&&(a.removeData(c,d),c.trigger("keyup-change"))})}function v(c){c.on("mousemove",function(c){var d=h;(d===b||d.x!==c.pageX||d.y!==c.pageY)&&a(c.target).trigger("mousemove-filtered",c)})}function w(a,c,d){d=d||b;var e;return function(){var b=arguments;window.clearTimeout(e),e=window.setTimeout(function(){c.apply(d,b)},a)}}function x(a,b){var c=w(a,function(a){b.trigger("scroll-debounced",a)});b.on("scroll",function(a){p(a.target,b.get())>=0&&c(a)})}function y(a){a[0]!==document.activeElement&&window.setTimeout(function(){var d,b=a[0],c=a.val().length;a.focus();var e=b.offsetWidth>0||b.offsetHeight>0;e&&b===document.activeElement&&(b.setSelectionRange?b.setSelectionRange(c,c):b.createTextRange&&(d=b.createTextRange(),d.collapse(!1),d.select()))},0)}function z(b){b=a(b)[0];var c=0,d=0;if("selectionStart"in b)c=b.selectionStart,d=b.selectionEnd-c;else if("selection"in document){b.focus();var e=document.selection.createRange();d=document.selection.createRange().text.length,e.moveStart("character",-b.value.length),c=e.text.length-d}return{offset:c,length:d}}function A(a){a.preventDefault(),a.stopPropagation()}function B(a){a.preventDefault(),a.stopImmediatePropagation()}function C(b){if(!g){var c=b[0].currentStyle||window.getComputedStyle(b[0],null);g=a(document.createElement("div")).css({position:"absolute",left:"-10000px",top:"-10000px",display:"none",fontSize:c.fontSize,fontFamily:c.fontFamily,fontStyle:c.fontStyle,fontWeight:c.fontWeight,letterSpacing:c.letterSpacing,textTransform:c.textTransform,whiteSpace:"nowrap"}),g.attr("class","select2-sizer"),a(document.body).append(g)}return g.text(b.val()),g.width()}function D(b,c,d){var e,g,f=[];e=a.trim(b.attr("class")),e&&(e=""+e,a(e.split(/\s+/)).each2(function(){0===this.indexOf("select2-")&&f.push(this)})),e=a.trim(c.attr("class")),e&&(e=""+e,a(e.split(/\s+/)).each2(function(){0!==this.indexOf("select2-")&&(g=d(this),g&&f.push(g))})),b.attr("class",f.join(" "))}function E(a,b,c,d){var e=o(a.toUpperCase()).indexOf(o(b.toUpperCase())),f=b.length;return 0>e?void c.push(d(a)):(c.push(d(a.substring(0,e))),c.push("<span class='select2-match'>"),c.push(d(a.substring(e,e+f))),c.push("</span>"),void c.push(d(a.substring(e+f,a.length))))}function F(a){var b={"\\":"&#92;","&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#47;"};return String(a).replace(/[&<>"'\/\\]/g,function(a){return b[a]})}function G(c){var d,e=null,f=c.quietMillis||100,g=c.url,h=this;return function(i){window.clearTimeout(d),d=window.setTimeout(function(){var d=c.data,f=g,j=c.transport||a.fn.select2.ajaxDefaults.transport,k={type:c.type||"GET",cache:c.cache||!1,jsonpCallback:c.jsonpCallback||b,dataType:c.dataType||"json"},l=a.extend({},a.fn.select2.ajaxDefaults.params,k);d=d?d.call(h,i.term,i.page,i.context):null,f="function"==typeof f?f.call(h,i.term,i.page,i.context):f,e&&"function"==typeof e.abort&&e.abort(),c.params&&(a.isFunction(c.params)?a.extend(l,c.params.call(h)):a.extend(l,c.params)),a.extend(l,{url:f,dataType:c.dataType,data:d,success:function(a){var b=c.results(a,i.page,i);i.callback(b)},error:function(a,b,c){var d={hasError:!0,jqXHR:a,textStatus:b,errorThrown:c};i.callback(d)}}),e=j.call(h,l)},f)}}function H(b){var d,e,c=b,f=function(a){return""+a.text};a.isArray(c)&&(e=c,c={results:e}),a.isFunction(c)===!1&&(e=c,c=function(){return e});var g=c();return g.text&&(f=g.text,a.isFunction(f)||(d=g.text,f=function(a){return a[d]})),function(b){var g,d=b.term,e={results:[]};return""===d?void b.callback(c()):(g=function(c,e){var h,i;if(c=c[0],c.children){h={};for(i in c)c.hasOwnProperty(i)&&(h[i]=c[i]);h.children=[],a(c.children).each2(function(a,b){g(b,h.children)}),(h.children.length||b.matcher(d,f(h),c))&&e.push(h)}else b.matcher(d,f(c),c)&&e.push(c)},a(c().results).each2(function(a,b){g(b,e.results)}),void b.callback(e))}}function I(c){var d=a.isFunction(c);return function(e){var f=e.term,g={results:[]},h=d?c(e):c;a.isArray(h)&&(a(h).each(function(){var a=this.text!==b,c=a?this.text:this;(""===f||e.matcher(f,c))&&g.results.push(a?this:{id:this,text:this})}),e.callback(g))}}function J(b,c){if(a.isFunction(b))return!0;if(!b)return!1;if("string"==typeof b)return!0;throw new Error(c+" must be a string, function, or falsy value")}function K(b,c){if(a.isFunction(b)){var d=Array.prototype.slice.call(arguments,2);return b.apply(c,d)}return b}function L(b){var c=0;return a.each(b,function(a,b){b.children?c+=L(b.children):c++}),c}function M(a,c,d,e){var h,i,j,k,l,f=a,g=!1;if(!e.createSearchChoice||!e.tokenSeparators||e.tokenSeparators.length<1)return b;for(;;){for(i=-1,j=0,k=e.tokenSeparators.length;k>j&&(l=e.tokenSeparators[j],i=a.indexOf(l),!(i>=0));j++);if(0>i)break;if(h=a.substring(0,i),a=a.substring(i+l.length),h.length>0&&(h=e.createSearchChoice.call(this,h,c),h!==b&&null!==h&&e.id(h)!==b&&null!==e.id(h))){for(g=!1,j=0,k=c.length;k>j;j++)if(r(e.id(h),e.id(c[j]))){g=!0;break}g||d(h)}}return f!==a?a:void 0}function N(){var b=this;a.each(arguments,function(a,c){b[c].remove(),b[c]=null})}function O(b,c){var d=function(){};return d.prototype=new b,d.prototype.constructor=d,d.prototype.parent=b.prototype,d.prototype=a.extend(d.prototype,c),d}if(window.Select2===b){var c,d,e,f,g,i,j,h={x:0,y:0},k={TAB:9,ENTER:13,ESC:27,SPACE:32,LEFT:37,UP:38,RIGHT:39,DOWN:40,SHIFT:16,CTRL:17,ALT:18,PAGE_UP:33,PAGE_DOWN:34,HOME:36,END:35,BACKSPACE:8,DELETE:46,isArrow:function(a){switch(a=a.which?a.which:a){case k.LEFT:case k.RIGHT:case k.UP:case k.DOWN:return!0}return!1},isControl:function(a){var b=a.which;switch(b){case k.SHIFT:case k.CTRL:case k.ALT:return!0}return a.metaKey?!0:!1},isFunctionKey:function(a){return a=a.which?a.which:a,a>=112&&123>=a}},l="<div class='select2-measure-scrollbar'></div>",m={"\u24b6":"A","\uff21":"A","\xc0":"A","\xc1":"A","\xc2":"A","\u1ea6":"A","\u1ea4":"A","\u1eaa":"A","\u1ea8":"A","\xc3":"A","\u0100":"A","\u0102":"A","\u1eb0":"A","\u1eae":"A","\u1eb4":"A","\u1eb2":"A","\u0226":"A","\u01e0":"A","\xc4":"A","\u01de":"A","\u1ea2":"A","\xc5":"A","\u01fa":"A","\u01cd":"A","\u0200":"A","\u0202":"A","\u1ea0":"A","\u1eac":"A","\u1eb6":"A","\u1e00":"A","\u0104":"A","\u023a":"A","\u2c6f":"A","\ua732":"AA","\xc6":"AE","\u01fc":"AE","\u01e2":"AE","\ua734":"AO","\ua736":"AU","\ua738":"AV","\ua73a":"AV","\ua73c":"AY","\u24b7":"B","\uff22":"B","\u1e02":"B","\u1e04":"B","\u1e06":"B","\u0243":"B","\u0182":"B","\u0181":"B","\u24b8":"C","\uff23":"C","\u0106":"C","\u0108":"C","\u010a":"C","\u010c":"C","\xc7":"C","\u1e08":"C","\u0187":"C","\u023b":"C","\ua73e":"C","\u24b9":"D","\uff24":"D","\u1e0a":"D","\u010e":"D","\u1e0c":"D","\u1e10":"D","\u1e12":"D","\u1e0e":"D","\u0110":"D","\u018b":"D","\u018a":"D","\u0189":"D","\ua779":"D","\u01f1":"DZ","\u01c4":"DZ","\u01f2":"Dz","\u01c5":"Dz","\u24ba":"E","\uff25":"E","\xc8":"E","\xc9":"E","\xca":"E","\u1ec0":"E","\u1ebe":"E","\u1ec4":"E","\u1ec2":"E","\u1ebc":"E","\u0112":"E","\u1e14":"E","\u1e16":"E","\u0114":"E","\u0116":"E","\xcb":"E","\u1eba":"E","\u011a":"E","\u0204":"E","\u0206":"E","\u1eb8":"E","\u1ec6":"E","\u0228":"E","\u1e1c":"E","\u0118":"E","\u1e18":"E","\u1e1a":"E","\u0190":"E","\u018e":"E","\u24bb":"F","\uff26":"F","\u1e1e":"F","\u0191":"F","\ua77b":"F","\u24bc":"G","\uff27":"G","\u01f4":"G","\u011c":"G","\u1e20":"G","\u011e":"G","\u0120":"G","\u01e6":"G","\u0122":"G","\u01e4":"G","\u0193":"G","\ua7a0":"G","\ua77d":"G","\ua77e":"G","\u24bd":"H","\uff28":"H","\u0124":"H","\u1e22":"H","\u1e26":"H","\u021e":"H","\u1e24":"H","\u1e28":"H","\u1e2a":"H","\u0126":"H","\u2c67":"H","\u2c75":"H","\ua78d":"H","\u24be":"I","\uff29":"I","\xcc":"I","\xcd":"I","\xce":"I","\u0128":"I","\u012a":"I","\u012c":"I","\u0130":"I","\xcf":"I","\u1e2e":"I","\u1ec8":"I","\u01cf":"I","\u0208":"I","\u020a":"I","\u1eca":"I","\u012e":"I","\u1e2c":"I","\u0197":"I","\u24bf":"J","\uff2a":"J","\u0134":"J","\u0248":"J","\u24c0":"K","\uff2b":"K","\u1e30":"K","\u01e8":"K","\u1e32":"K","\u0136":"K","\u1e34":"K","\u0198":"K","\u2c69":"K","\ua740":"K","\ua742":"K","\ua744":"K","\ua7a2":"K","\u24c1":"L","\uff2c":"L","\u013f":"L","\u0139":"L","\u013d":"L","\u1e36":"L","\u1e38":"L","\u013b":"L","\u1e3c":"L","\u1e3a":"L","\u0141":"L","\u023d":"L","\u2c62":"L","\u2c60":"L","\ua748":"L","\ua746":"L","\ua780":"L","\u01c7":"LJ","\u01c8":"Lj","\u24c2":"M","\uff2d":"M","\u1e3e":"M","\u1e40":"M","\u1e42":"M","\u2c6e":"M","\u019c":"M","\u24c3":"N","\uff2e":"N","\u01f8":"N","\u0143":"N","\xd1":"N","\u1e44":"N","\u0147":"N","\u1e46":"N","\u0145":"N","\u1e4a":"N","\u1e48":"N","\u0220":"N","\u019d":"N","\ua790":"N","\ua7a4":"N","\u01ca":"NJ","\u01cb":"Nj","\u24c4":"O","\uff2f":"O","\xd2":"O","\xd3":"O","\xd4":"O","\u1ed2":"O","\u1ed0":"O","\u1ed6":"O","\u1ed4":"O","\xd5":"O","\u1e4c":"O","\u022c":"O","\u1e4e":"O","\u014c":"O","\u1e50":"O","\u1e52":"O","\u014e":"O","\u022e":"O","\u0230":"O","\xd6":"O","\u022a":"O","\u1ece":"O","\u0150":"O","\u01d1":"O","\u020c":"O","\u020e":"O","\u01a0":"O","\u1edc":"O","\u1eda":"O","\u1ee0":"O","\u1ede":"O","\u1ee2":"O","\u1ecc":"O","\u1ed8":"O","\u01ea":"O","\u01ec":"O","\xd8":"O","\u01fe":"O","\u0186":"O","\u019f":"O","\ua74a":"O","\ua74c":"O","\u01a2":"OI","\ua74e":"OO","\u0222":"OU","\u24c5":"P","\uff30":"P","\u1e54":"P","\u1e56":"P","\u01a4":"P","\u2c63":"P","\ua750":"P","\ua752":"P","\ua754":"P","\u24c6":"Q","\uff31":"Q","\ua756":"Q","\ua758":"Q","\u024a":"Q","\u24c7":"R","\uff32":"R","\u0154":"R","\u1e58":"R","\u0158":"R","\u0210":"R","\u0212":"R","\u1e5a":"R","\u1e5c":"R","\u0156":"R","\u1e5e":"R","\u024c":"R","\u2c64":"R","\ua75a":"R","\ua7a6":"R","\ua782":"R","\u24c8":"S","\uff33":"S","\u1e9e":"S","\u015a":"S","\u1e64":"S","\u015c":"S","\u1e60":"S","\u0160":"S","\u1e66":"S","\u1e62":"S","\u1e68":"S","\u0218":"S","\u015e":"S","\u2c7e":"S","\ua7a8":"S","\ua784":"S","\u24c9":"T","\uff34":"T","\u1e6a":"T","\u0164":"T","\u1e6c":"T","\u021a":"T","\u0162":"T","\u1e70":"T","\u1e6e":"T","\u0166":"T","\u01ac":"T","\u01ae":"T","\u023e":"T","\ua786":"T","\ua728":"TZ","\u24ca":"U","\uff35":"U","\xd9":"U","\xda":"U","\xdb":"U","\u0168":"U","\u1e78":"U","\u016a":"U","\u1e7a":"U","\u016c":"U","\xdc":"U","\u01db":"U","\u01d7":"U","\u01d5":"U","\u01d9":"U","\u1ee6":"U","\u016e":"U","\u0170":"U","\u01d3":"U","\u0214":"U","\u0216":"U","\u01af":"U","\u1eea":"U","\u1ee8":"U","\u1eee":"U","\u1eec":"U","\u1ef0":"U","\u1ee4":"U","\u1e72":"U","\u0172":"U","\u1e76":"U","\u1e74":"U","\u0244":"U","\u24cb":"V","\uff36":"V","\u1e7c":"V","\u1e7e":"V","\u01b2":"V","\ua75e":"V","\u0245":"V","\ua760":"VY","\u24cc":"W","\uff37":"W","\u1e80":"W","\u1e82":"W","\u0174":"W","\u1e86":"W","\u1e84":"W","\u1e88":"W","\u2c72":"W","\u24cd":"X","\uff38":"X","\u1e8a":"X","\u1e8c":"X","\u24ce":"Y","\uff39":"Y","\u1ef2":"Y","\xdd":"Y","\u0176":"Y","\u1ef8":"Y","\u0232":"Y","\u1e8e":"Y","\u0178":"Y","\u1ef6":"Y","\u1ef4":"Y","\u01b3":"Y","\u024e":"Y","\u1efe":"Y","\u24cf":"Z","\uff3a":"Z","\u0179":"Z","\u1e90":"Z","\u017b":"Z","\u017d":"Z","\u1e92":"Z","\u1e94":"Z","\u01b5":"Z","\u0224":"Z","\u2c7f":"Z","\u2c6b":"Z","\ua762":"Z","\u24d0":"a","\uff41":"a","\u1e9a":"a","\xe0":"a","\xe1":"a","\xe2":"a","\u1ea7":"a","\u1ea5":"a","\u1eab":"a","\u1ea9":"a","\xe3":"a","\u0101":"a","\u0103":"a","\u1eb1":"a","\u1eaf":"a","\u1eb5":"a","\u1eb3":"a","\u0227":"a","\u01e1":"a","\xe4":"a","\u01df":"a","\u1ea3":"a","\xe5":"a","\u01fb":"a","\u01ce":"a","\u0201":"a","\u0203":"a","\u1ea1":"a","\u1ead":"a","\u1eb7":"a","\u1e01":"a","\u0105":"a","\u2c65":"a","\u0250":"a","\ua733":"aa","\xe6":"ae","\u01fd":"ae","\u01e3":"ae","\ua735":"ao","\ua737":"au","\ua739":"av","\ua73b":"av","\ua73d":"ay","\u24d1":"b","\uff42":"b","\u1e03":"b","\u1e05":"b","\u1e07":"b","\u0180":"b","\u0183":"b","\u0253":"b","\u24d2":"c","\uff43":"c","\u0107":"c","\u0109":"c","\u010b":"c","\u010d":"c","\xe7":"c","\u1e09":"c","\u0188":"c","\u023c":"c","\ua73f":"c","\u2184":"c","\u24d3":"d","\uff44":"d","\u1e0b":"d","\u010f":"d","\u1e0d":"d","\u1e11":"d","\u1e13":"d","\u1e0f":"d","\u0111":"d","\u018c":"d","\u0256":"d","\u0257":"d","\ua77a":"d","\u01f3":"dz","\u01c6":"dz","\u24d4":"e","\uff45":"e","\xe8":"e","\xe9":"e","\xea":"e","\u1ec1":"e","\u1ebf":"e","\u1ec5":"e","\u1ec3":"e","\u1ebd":"e","\u0113":"e","\u1e15":"e","\u1e17":"e","\u0115":"e","\u0117":"e","\xeb":"e","\u1ebb":"e","\u011b":"e","\u0205":"e","\u0207":"e","\u1eb9":"e","\u1ec7":"e","\u0229":"e","\u1e1d":"e","\u0119":"e","\u1e19":"e","\u1e1b":"e","\u0247":"e","\u025b":"e","\u01dd":"e","\u24d5":"f","\uff46":"f","\u1e1f":"f","\u0192":"f","\ua77c":"f","\u24d6":"g","\uff47":"g","\u01f5":"g","\u011d":"g","\u1e21":"g","\u011f":"g","\u0121":"g","\u01e7":"g","\u0123":"g","\u01e5":"g","\u0260":"g","\ua7a1":"g","\u1d79":"g","\ua77f":"g","\u24d7":"h","\uff48":"h","\u0125":"h","\u1e23":"h","\u1e27":"h","\u021f":"h","\u1e25":"h","\u1e29":"h","\u1e2b":"h","\u1e96":"h","\u0127":"h","\u2c68":"h","\u2c76":"h","\u0265":"h","\u0195":"hv","\u24d8":"i","\uff49":"i","\xec":"i","\xed":"i","\xee":"i","\u0129":"i","\u012b":"i","\u012d":"i","\xef":"i","\u1e2f":"i","\u1ec9":"i","\u01d0":"i","\u0209":"i","\u020b":"i","\u1ecb":"i","\u012f":"i","\u1e2d":"i","\u0268":"i","\u0131":"i","\u24d9":"j","\uff4a":"j","\u0135":"j","\u01f0":"j","\u0249":"j","\u24da":"k","\uff4b":"k","\u1e31":"k","\u01e9":"k","\u1e33":"k","\u0137":"k","\u1e35":"k","\u0199":"k","\u2c6a":"k","\ua741":"k","\ua743":"k","\ua745":"k","\ua7a3":"k","\u24db":"l","\uff4c":"l","\u0140":"l","\u013a":"l","\u013e":"l","\u1e37":"l","\u1e39":"l","\u013c":"l","\u1e3d":"l","\u1e3b":"l","\u017f":"l","\u0142":"l","\u019a":"l","\u026b":"l","\u2c61":"l","\ua749":"l","\ua781":"l","\ua747":"l","\u01c9":"lj","\u24dc":"m","\uff4d":"m","\u1e3f":"m","\u1e41":"m","\u1e43":"m","\u0271":"m","\u026f":"m","\u24dd":"n","\uff4e":"n","\u01f9":"n","\u0144":"n","\xf1":"n","\u1e45":"n","\u0148":"n","\u1e47":"n","\u0146":"n","\u1e4b":"n","\u1e49":"n","\u019e":"n","\u0272":"n","\u0149":"n","\ua791":"n","\ua7a5":"n","\u01cc":"nj","\u24de":"o","\uff4f":"o","\xf2":"o","\xf3":"o","\xf4":"o","\u1ed3":"o","\u1ed1":"o","\u1ed7":"o","\u1ed5":"o","\xf5":"o","\u1e4d":"o","\u022d":"o","\u1e4f":"o","\u014d":"o","\u1e51":"o","\u1e53":"o","\u014f":"o","\u022f":"o","\u0231":"o","\xf6":"o","\u022b":"o","\u1ecf":"o","\u0151":"o","\u01d2":"o","\u020d":"o","\u020f":"o","\u01a1":"o","\u1edd":"o","\u1edb":"o","\u1ee1":"o","\u1edf":"o","\u1ee3":"o","\u1ecd":"o","\u1ed9":"o","\u01eb":"o","\u01ed":"o","\xf8":"o","\u01ff":"o","\u0254":"o","\ua74b":"o","\ua74d":"o","\u0275":"o","\u01a3":"oi","\u0223":"ou","\ua74f":"oo","\u24df":"p","\uff50":"p","\u1e55":"p","\u1e57":"p","\u01a5":"p","\u1d7d":"p","\ua751":"p","\ua753":"p","\ua755":"p","\u24e0":"q","\uff51":"q","\u024b":"q","\ua757":"q","\ua759":"q","\u24e1":"r","\uff52":"r","\u0155":"r","\u1e59":"r","\u0159":"r","\u0211":"r","\u0213":"r","\u1e5b":"r","\u1e5d":"r","\u0157":"r","\u1e5f":"r","\u024d":"r","\u027d":"r","\ua75b":"r","\ua7a7":"r","\ua783":"r","\u24e2":"s","\uff53":"s","\xdf":"s","\u015b":"s","\u1e65":"s","\u015d":"s","\u1e61":"s","\u0161":"s","\u1e67":"s","\u1e63":"s","\u1e69":"s","\u0219":"s","\u015f":"s","\u023f":"s","\ua7a9":"s","\ua785":"s","\u1e9b":"s","\u24e3":"t","\uff54":"t","\u1e6b":"t","\u1e97":"t","\u0165":"t","\u1e6d":"t","\u021b":"t","\u0163":"t","\u1e71":"t","\u1e6f":"t","\u0167":"t","\u01ad":"t","\u0288":"t","\u2c66":"t","\ua787":"t","\ua729":"tz","\u24e4":"u","\uff55":"u","\xf9":"u","\xfa":"u","\xfb":"u","\u0169":"u","\u1e79":"u","\u016b":"u","\u1e7b":"u","\u016d":"u","\xfc":"u","\u01dc":"u","\u01d8":"u","\u01d6":"u","\u01da":"u","\u1ee7":"u","\u016f":"u","\u0171":"u","\u01d4":"u","\u0215":"u","\u0217":"u","\u01b0":"u","\u1eeb":"u","\u1ee9":"u","\u1eef":"u","\u1eed":"u","\u1ef1":"u","\u1ee5":"u","\u1e73":"u","\u0173":"u","\u1e77":"u","\u1e75":"u","\u0289":"u","\u24e5":"v","\uff56":"v","\u1e7d":"v","\u1e7f":"v","\u028b":"v","\ua75f":"v","\u028c":"v","\ua761":"vy","\u24e6":"w","\uff57":"w","\u1e81":"w","\u1e83":"w","\u0175":"w","\u1e87":"w","\u1e85":"w","\u1e98":"w","\u1e89":"w","\u2c73":"w","\u24e7":"x","\uff58":"x","\u1e8b":"x","\u1e8d":"x","\u24e8":"y","\uff59":"y","\u1ef3":"y","\xfd":"y","\u0177":"y","\u1ef9":"y","\u0233":"y","\u1e8f":"y","\xff":"y","\u1ef7":"y","\u1e99":"y","\u1ef5":"y","\u01b4":"y","\u024f":"y","\u1eff":"y","\u24e9":"z","\uff5a":"z","\u017a":"z","\u1e91":"z","\u017c":"z","\u017e":"z","\u1e93":"z","\u1e95":"z","\u01b6":"z","\u0225":"z","\u0240":"z","\u2c6c":"z","\ua763":"z","\u0386":"\u0391","\u0388":"\u0395","\u0389":"\u0397","\u038a":"\u0399","\u03aa":"\u0399","\u038c":"\u039f","\u038e":"\u03a5","\u03ab":"\u03a5","\u038f":"\u03a9","\u03ac":"\u03b1","\u03ad":"\u03b5","\u03ae":"\u03b7","\u03af":"\u03b9","\u03ca":"\u03b9","\u0390":"\u03b9","\u03cc":"\u03bf","\u03cd":"\u03c5","\u03cb":"\u03c5","\u03b0":"\u03c5","\u03c9":"\u03c9","\u03c2":"\u03c3"};i=a(document),f=function(){var a=1;return function(){return a++}}(),c=O(Object,{bind:function(a){var b=this;return function(){a.apply(b,arguments)}},init:function(c){var d,e,g=".select2-results";this.opts=c=this.prepareOpts(c),this.id=c.id,c.element.data("select2")!==b&&null!==c.element.data("select2")&&c.element.data("select2").destroy(),this.container=this.createContainer(),this.liveRegion=a(".select2-hidden-accessible"),0==this.liveRegion.length&&(this.liveRegion=a("<span>",{role:"status","aria-live":"polite"}).addClass("select2-hidden-accessible").appendTo(document.body)),this.containerId="s2id_"+(c.element.attr("id")||"autogen"+f()),this.containerEventName=this.containerId.replace(/([.])/g,"_").replace(/([;&,\-\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g,"\\$1"),this.container.attr("id",this.containerId),this.container.attr("title",c.element.attr("title")),this.body=a(document.body),D(this.container,this.opts.element,this.opts.adaptContainerCssClass),this.container.attr("style",c.element.attr("style")),this.container.css(K(c.containerCss,this.opts.element)),this.container.addClass(K(c.containerCssClass,this.opts.element)),this.elementTabIndex=this.opts.element.attr("tabindex"),this.opts.element.data("select2",this).attr("tabindex","-1").before(this.container).on("click.select2",A),this.container.data("select2",this),this.dropdown=this.container.find(".select2-drop"),D(this.dropdown,this.opts.element,this.opts.adaptDropdownCssClass),this.dropdown.addClass(K(c.dropdownCssClass,this.opts.element)),this.dropdown.data("select2",this),this.dropdown.on("click",A),this.results=d=this.container.find(g),this.search=e=this.container.find("input.select2-input"),this.queryCount=0,this.resultsPage=0,this.context=null,this.initContainer(),this.container.on("click",A),v(this.results),this.dropdown.on("mousemove-filtered",g,this.bind(this.highlightUnderEvent)),this.dropdown.on("touchstart touchmove touchend",g,this.bind(function(a){this._touchEvent=!0,this.highlightUnderEvent(a)})),this.dropdown.on("touchmove",g,this.bind(this.touchMoved)),this.dropdown.on("touchstart touchend",g,this.bind(this.clearTouchMoved)),this.dropdown.on("click",this.bind(function(a){this._touchEvent&&(this._touchEvent=!1,this.selectHighlighted())})),x(80,this.results),this.dropdown.on("scroll-debounced",g,this.bind(this.loadMoreIfNeeded)),a(this.container).on("change",".select2-input",function(a){a.stopPropagation()}),a(this.dropdown).on("change",".select2-input",function(a){a.stopPropagation()}),a.fn.mousewheel&&d.mousewheel(function(a,b,c,e){var f=d.scrollTop();e>0&&0>=f-e?(d.scrollTop(0),A(a)):0>e&&d.get(0).scrollHeight-d.scrollTop()+e<=d.height()&&(d.scrollTop(d.get(0).scrollHeight-d.height()),A(a))}),u(e),e.on("keyup-change input paste",this.bind(this.updateResults)),e.on("focus",function(){e.addClass("select2-focused")}),e.on("blur",function(){e.removeClass("select2-focused")}),this.dropdown.on("mouseup",g,this.bind(function(b){a(b.target).closest(".select2-result-selectable").length>0&&(this.highlightUnderEvent(b),this.selectHighlighted(b))})),this.dropdown.on("click mouseup mousedown touchstart touchend focusin",function(a){a.stopPropagation()}),this.lastSearchTerm=b,a.isFunction(this.opts.initSelection)&&(this.initSelection(),this.monitorSource()),null!==c.maximumInputLength&&this.search.attr("maxlength",c.maximumInputLength);var h=c.element.prop("disabled");h===b&&(h=!1),this.enable(!h);var i=c.element.prop("readonly");i===b&&(i=!1),this.readonly(i),j=j||q(),this.autofocus=c.element.prop("autofocus"),c.element.prop("autofocus",!1),this.autofocus&&this.focus(),this.search.attr("placeholder",c.searchInputPlaceholder)},destroy:function(){var a=this.opts.element,c=a.data("select2"),d=this;this.close(),a.length&&a[0].detachEvent&&d._sync&&a.each(function(){d._sync&&this.detachEvent("onpropertychange",d._sync)}),this.propertyObserver&&(this.propertyObserver.disconnect(),this.propertyObserver=null),this._sync=null,c!==b&&(c.container.remove(),c.liveRegion.remove(),c.dropdown.remove(),a.removeData("select2").off(".select2"),a.is("input[type='hidden']")?a.css("display",""):(a.show().prop("autofocus",this.autofocus||!1),this.elementTabIndex?a.attr({tabindex:this.elementTabIndex}):a.removeAttr("tabindex"),a.show())),N.call(this,"container","liveRegion","dropdown","results","search")},optionToData:function(a){return a.is("option")?{id:a.prop("value"),text:a.text(),element:a.get(),css:a.attr("class"),disabled:a.prop("disabled"),locked:r(a.attr("locked"),"locked")||r(a.data("locked"),!0)}:a.is("optgroup")?{text:a.attr("label"),children:[],element:a.get(),css:a.attr("class")}:void 0},prepareOpts:function(c){var d,e,g,h,i=this;if(d=c.element,"select"===d.get(0).tagName.toLowerCase()&&(this.select=e=c.element),e&&a.each(["id","multiple","ajax","query","createSearchChoice","initSelection","data","tags"],function(){if(this in c)throw new Error("Option '"+this+"' is not allowed for Select2 when attached to a <select> element.")}),c.debug=c.debug||a.fn.select2.defaults.debug,c.debug&&console&&console.warn&&(null!=c.id&&console.warn("Select2: The `id` option has been removed in Select2 4.0.0, consider renaming your `id` property or mapping the property before your data makes it to Select2. You can read more at https://select2.github.io/announcements-4.0.html#changed-id"),null!=c.text&&console.warn("Select2: The `text` option has been removed in Select2 4.0.0, consider renaming your `text` property or mapping the property before your data makes it to Select2. You can read more at https://select2.github.io/announcements-4.0.html#changed-id"),null!=c.sortResults&&console.warn("Select2: the `sortResults` option has been renamed to `sorter` in Select2 4.0.0. "),null!=c.selectOnBlur&&console.warn("Select2: The `selectOnBlur` option has been renamed to `selectOnClose` in Select2 4.0.0."),null!=c.ajax&&null!=c.ajax.results&&console.warn("Select2: The `ajax.results` option has been renamed to `ajax.processResults` in Select2 4.0.0."),null!=c.formatNoResults&&console.warn("Select2: The `formatNoResults` option has been renamed to `language.noResults` in Select2 4.0.0."),null!=c.formatSearching&&console.warn("Select2: The `formatSearching` option has been renamed to `language.searching` in Select2 4.0.0."),null!=c.formatInputTooShort&&console.warn("Select2: The `formatInputTooShort` option has been renamed to `language.inputTooShort` in Select2 4.0.0."),null!=c.formatInputTooLong&&console.warn("Select2: The `formatInputTooLong` option has been renamed to `language.inputTooLong` in Select2 4.0.0."),null!=c.formatLoading&&console.warn("Select2: The `formatLoading` option has been renamed to `language.loadingMore` in Select2 4.0.0."),null!=c.formatSelectionTooBig&&console.warn("Select2: The `formatSelectionTooBig` option has been renamed to `language.maximumSelected` in Select2 4.0.0."),c.element.data("select2Tags")&&console.warn("Select2: The `data-select2-tags` attribute has been renamed to `data-tags` in Select2 4.0.0.")),null!=c.element.data("tags")){var j=c.element.data("tags");a.isArray(j)||(j=[]),c.element.data("select2Tags",j)}if(null!=c.sorter&&(c.sortResults=c.sorter),null!=c.selectOnClose&&(c.selectOnBlur=c.selectOnClose),null!=c.ajax&&a.isFunction(c.ajax.processResults)&&(c.ajax.results=c.ajax.processResults),null!=c.language){var k=c.language;a.isFunction(k.noMatches)&&(c.formatNoMatches=k.noMatches),a.isFunction(k.searching)&&(c.formatSearching=k.searching),a.isFunction(k.inputTooShort)&&(c.formatInputTooShort=k.inputTooShort),a.isFunction(k.inputTooLong)&&(c.formatInputTooLong=k.inputTooLong),a.isFunction(k.loadingMore)&&(c.formatLoading=k.loadingMore),a.isFunction(k.maximumSelected)&&(c.formatSelectionTooBig=k.maximumSelected)}if(c=a.extend({},{populateResults:function(d,e,g){var h,j=this.opts.id,k=this.liveRegion;(h=function(d,e,l){var m,n,o,p,q,r,s,t,u,v;d=c.sortResults(d,e,g);var w=[];for(m=0,n=d.length;n>m;m+=1)o=d[m],q=o.disabled===!0,p=!q&&j(o)!==b,r=o.children&&o.children.length>0,s=a("<li></li>"),s.addClass("select2-results-dept-"+l),s.addClass("select2-result"),s.addClass(p?"select2-result-selectable":"select2-result-unselectable"),q&&s.addClass("select2-disabled"),r&&s.addClass("select2-result-with-children"),s.addClass(i.opts.formatResultCssClass(o)),s.attr("role","presentation"),t=a(document.createElement("div")),t.addClass("select2-result-label"),t.attr("id","select2-result-label-"+f()),t.attr("role","option"),v=c.formatResult(o,t,g,i.opts.escapeMarkup),v!==b&&(t.html(v),s.append(t)),r&&(u=a("<ul></ul>"),u.addClass("select2-result-sub"),h(o.children,u,l+1),s.append(u)),s.data("select2-data",o),w.push(s[0]);e.append(w),k.text(c.formatMatches(d.length))})(e,d,0)}},a.fn.select2.defaults,c),"function"!=typeof c.id&&(g=c.id,c.id=function(a){return a[g]}),a.isArray(c.element.data("select2Tags"))){if("tags"in c)throw"tags specified as both an attribute 'data-select2-tags' and in options of Select2 "+c.element.attr("id");c.tags=c.element.data("select2Tags")}if(e?(c.query=this.bind(function(a){var f,g,h,c={results:[],more:!1},e=a.term;h=function(b,c){var d;b.is("option")?a.matcher(e,b.text(),b)&&c.push(i.optionToData(b)):b.is("optgroup")&&(d=i.optionToData(b),b.children().each2(function(a,b){h(b,d.children)}),d.children.length>0&&c.push(d))},f=d.children(),this.getPlaceholder()!==b&&f.length>0&&(g=this.getPlaceholderOption(),g&&(f=f.not(g))),f.each2(function(a,b){h(b,c.results)}),a.callback(c)}),c.id=function(a){return a.id}):"query"in c||("ajax"in c?(h=c.element.data("ajax-url"),h&&h.length>0&&(c.ajax.url=h),c.query=G.call(c.element,c.ajax)):"data"in c?c.query=H(c.data):"tags"in c&&(c.query=I(c.tags),c.createSearchChoice===b&&(c.createSearchChoice=function(b){return{id:a.trim(b),text:a.trim(b)}}),c.initSelection===b&&(c.initSelection=function(b,d){var e=[];a(s(b.val(),c.separator,c.transformVal)).each(function(){var b={id:this,text:this},d=c.tags;a.isFunction(d)&&(d=d()),a(d).each(function(){return r(this.id,b.id)?(b=this,!1):void 0}),e.push(b)}),d(e)}))),"function"!=typeof c.query)throw"query function not defined for Select2 "+c.element.attr("id");if("top"===c.createSearchChoicePosition)c.createSearchChoicePosition=function(a,b){a.unshift(b)};else if("bottom"===c.createSearchChoicePosition)c.createSearchChoicePosition=function(a,b){a.push(b)};else if("function"!=typeof c.createSearchChoicePosition)throw"invalid createSearchChoicePosition option must be 'top', 'bottom' or a custom function";return c},monitorSource:function(){var d,c=this.opts.element,e=this;c.on("change.select2",this.bind(function(a){this.opts.element.data("select2-change-triggered")!==!0&&this.initSelection()})),this._sync=this.bind(function(){var a=c.prop("disabled");a===b&&(a=!1),this.enable(!a);var d=c.prop("readonly");d===b&&(d=!1),this.readonly(d),this.container&&(D(this.container,this.opts.element,this.opts.adaptContainerCssClass),this.container.addClass(K(this.opts.containerCssClass,this.opts.element))),this.dropdown&&(D(this.dropdown,this.opts.element,this.opts.adaptDropdownCssClass),this.dropdown.addClass(K(this.opts.dropdownCssClass,this.opts.element)))}),c.length&&c[0].attachEvent&&c.each(function(){this.attachEvent("onpropertychange",e._sync)}),d=window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver,d!==b&&(this.propertyObserver&&(delete this.propertyObserver,this.propertyObserver=null),this.propertyObserver=new d(function(b){a.each(b,e._sync)}),this.propertyObserver.observe(c.get(0),{attributes:!0,subtree:!1}))},triggerSelect:function(b){var c=a.Event("select2-selecting",{val:this.id(b),object:b,choice:b});return this.opts.element.trigger(c),!c.isDefaultPrevented()},triggerChange:function(b){b=b||{},b=a.extend({},b,{type:"change",val:this.val()}),this.opts.element.data("select2-change-triggered",!0),this.opts.element.trigger(b),this.opts.element.data("select2-change-triggered",!1),this.opts.element.click(),this.opts.blurOnChange&&this.opts.element.blur()},isInterfaceEnabled:function(){return this.enabledInterface===!0},enableInterface:function(){var a=this._enabled&&!this._readonly,b=!a;return a===this.enabledInterface?!1:(this.container.toggleClass("select2-container-disabled",b),this.close(),this.enabledInterface=a,!0)},enable:function(a){a===b&&(a=!0),this._enabled!==a&&(this._enabled=a,this.opts.element.prop("disabled",!a),this.enableInterface())},disable:function(){this.enable(!1)},readonly:function(a){a===b&&(a=!1),this._readonly!==a&&(this._readonly=a,this.opts.element.prop("readonly",a),this.enableInterface())},opened:function(){return this.container?this.container.hasClass("select2-dropdown-open"):!1},positionDropdown:function(){var v,w,x,y,z,b=this.dropdown,c=this.container,d=c.offset(),e=c.outerHeight(!1),f=c.outerWidth(!1),g=b.outerHeight(!1),h=a(window),i=h.width(),k=h.height(),l=h.scrollLeft()+i,m=h.scrollTop()+k,n=d.top+e,o=d.left,p=m>=n+g,q=d.top-g>=h.scrollTop(),r=b.outerWidth(!1),s=function(){return l>=o+r},t=function(){return d.left+l+c.outerWidth(!1)>r},u=b.hasClass("select2-drop-above");u?(w=!0,!q&&p&&(x=!0,w=!1)):(w=!1,!p&&q&&(x=!0,w=!0)),x&&(b.hide(),d=this.container.offset(),e=this.container.outerHeight(!1),f=this.container.outerWidth(!1),g=b.outerHeight(!1),l=h.scrollLeft()+i,m=h.scrollTop()+k,n=d.top+e,o=d.left,r=b.outerWidth(!1),b.show(),this.focusSearch()),this.opts.dropdownAutoWidth?(z=a(".select2-results",b)[0],b.addClass("select2-drop-auto-width"),b.css("width",""),r=b.outerWidth(!1)+(z.scrollHeight===z.clientHeight?0:j.width),r>f?f=r:r=f,g=b.outerHeight(!1)):this.container.removeClass("select2-drop-auto-width"),"static"!==this.body.css("position")&&(v=this.body.offset(),n-=v.top,o-=v.left),!s()&&t()&&(o=d.left+this.container.outerWidth(!1)-r),y={left:o,width:f},w?(this.container.addClass("select2-drop-above"),b.addClass("select2-drop-above"),g=b.outerHeight(!1),y.top=d.top-g,y.bottom="auto"):(y.top=n,y.bottom="auto",this.container.removeClass("select2-drop-above"),b.removeClass("select2-drop-above")),y=a.extend(y,K(this.opts.dropdownCss,this.opts.element)),b.css(y)},shouldOpen:function(){var b;return this.opened()?!1:this._enabled===!1||this._readonly===!0?!1:(b=a.Event("select2-opening"),this.opts.element.trigger(b),!b.isDefaultPrevented())},clearDropdownAlignmentPreference:function(){this.container.removeClass("select2-drop-above"),
this.dropdown.removeClass("select2-drop-above")},open:function(){return this.shouldOpen()?(this.opening(),i.on("mousemove.select2Event",function(a){h.x=a.pageX,h.y=a.pageY}),!0):!1},opening:function(){var f,b=this.containerEventName,c="scroll."+b,d="resize."+b,e="orientationchange."+b;this.container.addClass("select2-dropdown-open").addClass("select2-container-active"),this.clearDropdownAlignmentPreference(),this.dropdown[0]!==this.body.children().last()[0]&&this.dropdown.detach().appendTo(this.body),f=a("#select2-drop-mask"),0===f.length&&(f=a(document.createElement("div")),f.attr("id","select2-drop-mask").attr("class","select2-drop-mask"),f.hide(),f.appendTo(this.body),f.on("mousedown touchstart click",function(b){n(f);var d,c=a("#select2-drop");c.length>0&&(d=c.data("select2"),d.opts.selectOnBlur&&d.selectHighlighted({noFocus:!0}),d.close(),b.preventDefault(),b.stopPropagation())})),this.dropdown.prev()[0]!==f[0]&&this.dropdown.before(f),a("#select2-drop").removeAttr("id"),this.dropdown.attr("id","select2-drop"),f.show(),this.positionDropdown(),this.dropdown.show(),this.positionDropdown(),this.dropdown.addClass("select2-drop-active");var g=this;this.container.parents().add(window).each(function(){a(this).on(d+" "+c+" "+e,function(a){g.opened()&&g.positionDropdown()})})},close:function(){if(this.opened()){var b=this.containerEventName,c="scroll."+b,d="resize."+b,e="orientationchange."+b;this.container.parents().add(window).each(function(){a(this).off(c).off(d).off(e)}),this.clearDropdownAlignmentPreference(),a("#select2-drop-mask").hide(),this.dropdown.removeAttr("id"),this.dropdown.hide(),this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active"),this.results.empty(),i.off("mousemove.select2Event"),this.clearSearch(),this.search.removeClass("select2-active"),this.search.removeAttr("aria-activedescendant"),this.opts.element.trigger(a.Event("select2-close"))}},externalSearch:function(a){this.open(),this.search.val(a),this.updateResults(!1)},clearSearch:function(){},prefillNextSearchTerm:function(){if(""!==this.search.val())return!1;var a=this.opts.nextSearchTerm(this.data(),this.lastSearchTerm);return a!==b?(this.search.val(a),this.search.select(),!0):!1},getMaximumSelectionSize:function(){return K(this.opts.maximumSelectionSize,this.opts.element)},ensureHighlightVisible:function(){var c,d,e,f,g,h,i,j,b=this.results;if(d=this.highlight(),!(0>d)){if(0==d)return void b.scrollTop(0);c=this.findHighlightableChoices().find(".select2-result-label"),e=a(c[d]),j=(e.offset()||{}).top||0,f=j+e.outerHeight(!0),d===c.length-1&&(i=b.find("li.select2-more-results"),i.length>0&&(f=i.offset().top+i.outerHeight(!0))),g=b.offset().top+b.outerHeight(!1),f>g&&b.scrollTop(b.scrollTop()+(f-g)),h=j-b.offset().top,0>h&&"none"!=e.css("display")&&b.scrollTop(b.scrollTop()+h)}},findHighlightableChoices:function(){return this.results.find(".select2-result-selectable:not(.select2-disabled):not(.select2-selected)")},moveHighlight:function(b){for(var c=this.findHighlightableChoices(),d=this.highlight();d>-1&&d<c.length;){d+=b;var e=a(c[d]);if(e.hasClass("select2-result-selectable")&&!e.hasClass("select2-disabled")&&!e.hasClass("select2-selected")){this.highlight(d);break}}},highlight:function(b){var d,e,c=this.findHighlightableChoices();return 0===arguments.length?p(c.filter(".select2-highlighted")[0],c.get()):(b>=c.length&&(b=c.length-1),0>b&&(b=0),this.removeHighlight(),d=a(c[b]),d.addClass("select2-highlighted"),this.search.attr("aria-activedescendant",d.find(".select2-result-label").attr("id")),this.ensureHighlightVisible(),this.liveRegion.text(d.text()),e=d.data("select2-data"),void(e&&this.opts.element.trigger({type:"select2-highlight",val:this.id(e),choice:e})))},removeHighlight:function(){this.results.find(".select2-highlighted").removeClass("select2-highlighted")},touchMoved:function(){this._touchMoved=!0},clearTouchMoved:function(){this._touchMoved=!1},countSelectableResults:function(){return this.findHighlightableChoices().length},highlightUnderEvent:function(b){var c=a(b.target).closest(".select2-result-selectable");if(c.length>0&&!c.is(".select2-highlighted")){var d=this.findHighlightableChoices();this.highlight(d.index(c))}else 0==c.length&&this.removeHighlight()},loadMoreIfNeeded:function(){var c,a=this.results,b=a.find("li.select2-more-results"),d=this.resultsPage+1,e=this,f=this.search.val(),g=this.context;0!==b.length&&(c=b.offset().top-a.offset().top-a.height(),c<=this.opts.loadMorePadding&&(b.addClass("select2-active"),this.opts.query({element:this.opts.element,term:f,page:d,context:g,matcher:this.opts.matcher,callback:this.bind(function(c){e.opened()&&(e.opts.populateResults.call(this,a,c.results,{term:f,page:d,context:g}),e.postprocessResults(c,!1,!1),c.more===!0?(b.detach().appendTo(a).html(e.opts.escapeMarkup(K(e.opts.formatLoadMore,e.opts.element,d+1))),window.setTimeout(function(){e.loadMoreIfNeeded()},10)):b.remove(),e.positionDropdown(),e.resultsPage=d,e.context=c.context,this.opts.element.trigger({type:"select2-loaded",items:c}))})})))},tokenize:function(){},updateResults:function(c){function m(){d.removeClass("select2-active"),h.positionDropdown(),e.find(".select2-no-results,.select2-selection-limit,.select2-searching").length?h.liveRegion.text(e.text()):h.liveRegion.text(h.opts.formatMatches(e.find('.select2-result-selectable:not(".select2-selected")').length))}function n(a){e.html(a),m()}var g,i,l,d=this.search,e=this.results,f=this.opts,h=this,j=d.val(),k=a.data(this.container,"select2-last-term");if((c===!0||!k||!r(j,k))&&(a.data(this.container,"select2-last-term",j),c===!0||this.showSearchInput!==!1&&this.opened())){l=++this.queryCount;var o=this.getMaximumSelectionSize();if(o>=1&&(g=this.data(),a.isArray(g)&&g.length>=o&&J(f.formatSelectionTooBig,"formatSelectionTooBig")))return void n("<li class='select2-selection-limit'>"+K(f.formatSelectionTooBig,f.element,o)+"</li>");if(d.val().length<f.minimumInputLength)return n(J(f.formatInputTooShort,"formatInputTooShort")?"<li class='select2-no-results'>"+K(f.formatInputTooShort,f.element,d.val(),f.minimumInputLength)+"</li>":""),void(c&&this.showSearch&&this.showSearch(!0));if(f.maximumInputLength&&d.val().length>f.maximumInputLength)return void n(J(f.formatInputTooLong,"formatInputTooLong")?"<li class='select2-no-results'>"+K(f.formatInputTooLong,f.element,d.val(),f.maximumInputLength)+"</li>":"");f.formatSearching&&0===this.findHighlightableChoices().length&&n("<li class='select2-searching'>"+K(f.formatSearching,f.element)+"</li>"),d.addClass("select2-active"),this.removeHighlight(),i=this.tokenize(),i!=b&&null!=i&&d.val(i),this.resultsPage=1,f.query({element:f.element,term:d.val(),page:this.resultsPage,context:null,matcher:f.matcher,callback:this.bind(function(g){var i;if(l==this.queryCount){if(!this.opened())return void this.search.removeClass("select2-active");if(g.hasError!==b&&J(f.formatAjaxError,"formatAjaxError"))return void n("<li class='select2-ajax-error'>"+K(f.formatAjaxError,f.element,g.jqXHR,g.textStatus,g.errorThrown)+"</li>");if(this.context=g.context===b?null:g.context,this.opts.createSearchChoice&&""!==d.val()&&(i=this.opts.createSearchChoice.call(h,d.val(),g.results),i!==b&&null!==i&&h.id(i)!==b&&null!==h.id(i)&&0===a(g.results).filter(function(){return r(h.id(this),h.id(i))}).length&&this.opts.createSearchChoicePosition(g.results,i)),0===g.results.length&&J(f.formatNoMatches,"formatNoMatches"))return n("<li class='select2-no-results'>"+K(f.formatNoMatches,f.element,d.val())+"</li>"),void(this.showSearch&&this.showSearch(d.val()));e.empty(),h.opts.populateResults.call(this,e,g.results,{term:d.val(),page:this.resultsPage,context:null}),g.more===!0&&J(f.formatLoadMore,"formatLoadMore")&&(e.append("<li class='select2-more-results'>"+f.escapeMarkup(K(f.formatLoadMore,f.element,this.resultsPage))+"</li>"),window.setTimeout(function(){h.loadMoreIfNeeded()},10)),this.postprocessResults(g,c),m(),this.opts.element.trigger({type:"select2-loaded",items:g})}})})}},cancel:function(){this.close()},blur:function(){this.opts.selectOnBlur&&this.selectHighlighted({noFocus:!0}),this.close(),this.container.removeClass("select2-container-active"),this.search[0]===document.activeElement&&this.search.blur(),this.clearSearch(),this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus")},focusSearch:function(){y(this.search)},selectHighlighted:function(a){if(this._touchMoved)return void this.clearTouchMoved();var b=this.highlight(),c=this.results.find(".select2-highlighted"),d=c.closest(".select2-result").data("select2-data");d?(this.highlight(b),this.onSelect(d,a)):a&&a.noFocus&&this.close()},getPlaceholder:function(){var a;return this.opts.element.attr("placeholder")||this.opts.element.attr("data-placeholder")||this.opts.element.data("placeholder")||this.opts.placeholder||((a=this.getPlaceholderOption())!==b?a.text():b)},getPlaceholderOption:function(){if(this.select){var c=this.select.children("option").first();if(this.opts.placeholderOption!==b)return"first"===this.opts.placeholderOption&&c||"function"==typeof this.opts.placeholderOption&&this.opts.placeholderOption(this.select);if(""===a.trim(c.text())&&""===c.val())return c}},initContainerWidth:function(){function b(){var b,c,d,e,f,g;if("off"===this.opts.width)return null;if("element"===this.opts.width)return 0===this.opts.element.outerWidth(!1)?"auto":this.opts.element.outerWidth(!1)+"px";if("copy"===this.opts.width||"resolve"===this.opts.width){if(b=this.opts.element.attr("style"),"string"==typeof b)for(c=b.split(";"),e=0,f=c.length;f>e;e+=1)if(g=c[e].replace(/\s/g,""),d=g.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i),null!==d&&d.length>=1)return d[1];return"resolve"===this.opts.width?(b=this.opts.element.css("width"),b.indexOf("%")>0?b:0===this.opts.element.outerWidth(!1)?"auto":this.opts.element.outerWidth(!1)+"px"):null}return a.isFunction(this.opts.width)?this.opts.width():this.opts.width}var c=b.call(this);null!==c&&this.container.css("width",c)}}),d=O(c,{createContainer:function(){var b=a(document.createElement("div")).attr({"class":"select2-container"}).html(["<a href='javascript:void(0)' class='select2-choice' tabindex='-1'>","   <span class='select2-chosen'>&#160;</span><abbr class='select2-search-choice-close'></abbr>","   <span class='select2-arrow' role='presentation'><b role='presentation'></b></span>","</a>","<label for='' class='select2-offscreen'></label>","<input class='select2-focusser select2-offscreen' type='text' aria-haspopup='true' role='button' />","<div class='select2-drop select2-display-none'>","   <div class='select2-search'>","       <label for='' class='select2-offscreen'></label>","       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input' role='combobox' aria-expanded='true'","       aria-autocomplete='list' />","   </div>","   <ul class='select2-results' role='listbox'>","   </ul>","</div>"].join(""));return b},enableInterface:function(){this.parent.enableInterface.apply(this,arguments)&&this.focusser.prop("disabled",!this.isInterfaceEnabled())},opening:function(){var b,c,d;this.opts.minimumResultsForSearch>=0&&this.showSearch(!0),this.parent.opening.apply(this,arguments),this.showSearchInput!==!1&&this.search.val(this.focusser.val()),this.opts.shouldFocusInput(this)&&(this.search.focus(),b=this.search.get(0),b.createTextRange?(c=b.createTextRange(),c.collapse(!1),c.select()):b.setSelectionRange&&(d=this.search.val().length,b.setSelectionRange(d,d))),this.prefillNextSearchTerm(),this.focusser.prop("disabled",!0).val(""),this.updateResults(!0),this.opts.element.trigger(a.Event("select2-open"))},close:function(){this.opened()&&(this.parent.close.apply(this,arguments),this.focusser.prop("disabled",!1),this.opts.shouldFocusInput(this)&&this.focusser.focus())},focus:function(){this.opened()?this.close():(this.focusser.prop("disabled",!1),this.opts.shouldFocusInput(this)&&this.focusser.focus())},isFocused:function(){return this.container.hasClass("select2-container-active")},cancel:function(){this.parent.cancel.apply(this,arguments),this.focusser.prop("disabled",!1),this.opts.shouldFocusInput(this)&&this.focusser.focus()},destroy:function(){a("label[for='"+this.focusser.attr("id")+"']").attr("for",this.opts.element.attr("id")),this.parent.destroy.apply(this,arguments),N.call(this,"selection","focusser")},initContainer:function(){var b,g,c=this.container,d=this.dropdown,e=f();this.opts.minimumResultsForSearch<0?this.showSearch(!1):this.showSearch(!0),this.selection=b=c.find(".select2-choice"),this.focusser=c.find(".select2-focusser"),b.find(".select2-chosen").attr("id","select2-chosen-"+e),this.focusser.attr("aria-labelledby","select2-chosen-"+e),this.results.attr("id","select2-results-"+e),this.search.attr("aria-owns","select2-results-"+e),this.focusser.attr("id","s2id_autogen"+e),g=a("label[for='"+this.opts.element.attr("id")+"']"),this.opts.element.on("focus.select2",this.bind(function(){this.focus()})),this.focusser.prev().text(g.text()).attr("for",this.focusser.attr("id"));var h=this.opts.element.attr("title");this.opts.element.attr("title",h||g.text()),this.focusser.attr("tabindex",this.elementTabIndex),this.search.attr("id",this.focusser.attr("id")+"_search"),this.search.prev().text(a("label[for='"+this.focusser.attr("id")+"']").text()).attr("for",this.search.attr("id")),this.search.on("keydown",this.bind(function(a){if(this.isInterfaceEnabled()&&229!=a.keyCode){if(a.which===k.PAGE_UP||a.which===k.PAGE_DOWN)return void A(a);switch(a.which){case k.UP:case k.DOWN:return this.moveHighlight(a.which===k.UP?-1:1),void A(a);case k.ENTER:return this.selectHighlighted(),void A(a);case k.TAB:return void this.selectHighlighted({noFocus:!0});case k.ESC:return this.cancel(a),void A(a)}}})),this.search.on("blur",this.bind(function(a){document.activeElement===this.body.get(0)&&window.setTimeout(this.bind(function(){this.opened()&&this.results&&this.results.length>1&&this.search.focus()}),0)})),this.focusser.on("keydown",this.bind(function(a){if(this.isInterfaceEnabled()&&a.which!==k.TAB&&!k.isControl(a)&&!k.isFunctionKey(a)&&a.which!==k.ESC){if(this.opts.openOnEnter===!1&&a.which===k.ENTER)return void A(a);if(a.which==k.DOWN||a.which==k.UP||a.which==k.ENTER&&this.opts.openOnEnter){if(a.altKey||a.ctrlKey||a.shiftKey||a.metaKey)return;return this.open(),void A(a)}return a.which==k.DELETE||a.which==k.BACKSPACE?(this.opts.allowClear&&this.clear(),void A(a)):void 0}})),u(this.focusser),this.focusser.on("keyup-change input",this.bind(function(a){if(this.opts.minimumResultsForSearch>=0){if(a.stopPropagation(),this.opened())return;this.open()}})),b.on("mousedown touchstart","abbr",this.bind(function(a){this.isInterfaceEnabled()&&(this.clear(),B(a),this.close(),this.selection&&this.selection.focus())})),b.on("mousedown touchstart",this.bind(function(c){n(b),this.container.hasClass("select2-container-active")||this.opts.element.trigger(a.Event("select2-focus")),this.opened()?this.close():this.isInterfaceEnabled()&&this.open(),A(c)})),d.on("mousedown touchstart",this.bind(function(){this.opts.shouldFocusInput(this)&&this.search.focus()})),b.on("focus",this.bind(function(a){A(a)})),this.focusser.on("focus",this.bind(function(){this.container.hasClass("select2-container-active")||this.opts.element.trigger(a.Event("select2-focus")),this.container.addClass("select2-container-active")})).on("blur",this.bind(function(){this.opened()||(this.container.removeClass("select2-container-active"),this.opts.element.trigger(a.Event("select2-blur")))})),this.search.on("focus",this.bind(function(){this.container.hasClass("select2-container-active")||this.opts.element.trigger(a.Event("select2-focus")),this.container.addClass("select2-container-active")})),this.initContainerWidth(),this.opts.element.hide(),this.setPlaceholder()},clear:function(b){var c=this.selection.data("select2-data");if(c){var d=a.Event("select2-clearing");if(this.opts.element.trigger(d),d.isDefaultPrevented())return;var e=this.getPlaceholderOption();this.opts.element.val(e?e.val():""),this.selection.find(".select2-chosen").empty(),this.selection.removeData("select2-data"),this.setPlaceholder(),b!==!1&&(this.opts.element.trigger({type:"select2-removed",val:this.id(c),choice:c}),this.triggerChange({removed:c}))}},initSelection:function(){if(this.isPlaceholderOptionSelected())this.updateSelection(null),this.close(),this.setPlaceholder();else{var c=this;this.opts.initSelection.call(null,this.opts.element,function(a){a!==b&&null!==a&&(c.updateSelection(a),c.close(),c.setPlaceholder(),c.lastSearchTerm=c.search.val())})}},isPlaceholderOptionSelected:function(){var a;return this.getPlaceholder()===b?!1:(a=this.getPlaceholderOption())!==b&&a.prop("selected")||""===this.opts.element.val()||this.opts.element.val()===b||null===this.opts.element.val()},prepareOpts:function(){var b=this.parent.prepareOpts.apply(this,arguments),c=this;return"select"===b.element.get(0).tagName.toLowerCase()?b.initSelection=function(a,b){var d=a.find("option").filter(function(){return this.selected&&!this.disabled});b(c.optionToData(d))}:"data"in b&&(b.initSelection=b.initSelection||function(c,d){var e=c.val(),f=null;b.query({matcher:function(a,c,d){var g=r(e,b.id(d));return g&&(f=d),g},callback:a.isFunction(d)?function(){d(f)}:a.noop})}),b},getPlaceholder:function(){return this.select&&this.getPlaceholderOption()===b?b:this.parent.getPlaceholder.apply(this,arguments)},setPlaceholder:function(){var a=this.getPlaceholder();if(this.isPlaceholderOptionSelected()&&a!==b){if(this.select&&this.getPlaceholderOption()===b)return;this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(a)),this.selection.addClass("select2-default"),this.container.removeClass("select2-allowclear")}},postprocessResults:function(a,b,c){var d=0,e=this;if(this.findHighlightableChoices().each2(function(a,b){return r(e.id(b.data("select2-data")),e.opts.element.val())?(d=a,!1):void 0}),c!==!1&&(b===!0&&d>=0?this.highlight(d):this.highlight(0)),b===!0){var g=this.opts.minimumResultsForSearch;g>=0&&this.showSearch(L(a.results)>=g)}},showSearch:function(b){this.showSearchInput!==b&&(this.showSearchInput=b,this.dropdown.find(".select2-search").toggleClass("select2-search-hidden",!b),this.dropdown.find(".select2-search").toggleClass("select2-offscreen",!b),a(this.dropdown,this.container).toggleClass("select2-with-searchbox",b))},onSelect:function(a,b){if(this.triggerSelect(a)){var c=this.opts.element.val(),d=this.data();this.opts.element.val(this.id(a)),this.updateSelection(a),this.opts.element.trigger({type:"select2-selected",val:this.id(a),choice:a}),this.lastSearchTerm=this.search.val(),this.close(),b&&b.noFocus||!this.opts.shouldFocusInput(this)||this.focusser.focus(),r(c,this.id(a))||this.triggerChange({added:a,removed:d})}},updateSelection:function(a){var d,e,c=this.selection.find(".select2-chosen");this.selection.data("select2-data",a),c.empty(),null!==a&&(d=this.opts.formatSelection(a,c,this.opts.escapeMarkup)),d!==b&&c.append(d),e=this.opts.formatSelectionCssClass(a,c),e!==b&&c.addClass(e),this.selection.removeClass("select2-default"),this.opts.allowClear&&this.getPlaceholder()!==b&&this.container.addClass("select2-allowclear")},val:function(){var a,c=!1,d=null,e=this,f=this.data();if(0===arguments.length)return this.opts.element.val();if(a=arguments[0],arguments.length>1&&(c=arguments[1],this.opts.debug&&console&&console.warn&&console.warn('Select2: The second option to `select2("val")` is not supported in Select2 4.0.0. The `change` event will always be triggered in 4.0.0.')),this.select)this.opts.debug&&console&&console.warn&&console.warn('Select2: Setting the value on a <select> using `select2("val")` is no longer supported in 4.0.0. You can use the `.val(newValue).trigger("change")` method provided by jQuery instead.'),this.select.val(a).find("option").filter(function(){return this.selected}).each2(function(a,b){return d=e.optionToData(b),!1}),this.updateSelection(d),this.setPlaceholder(),c&&this.triggerChange({added:d,removed:f});else{if(!a&&0!==a)return void this.clear(c);if(this.opts.initSelection===b)throw new Error("cannot call val() if initSelection() is not defined");this.opts.element.val(a),this.opts.initSelection(this.opts.element,function(a){e.opts.element.val(a?e.id(a):""),e.updateSelection(a),e.setPlaceholder(),c&&e.triggerChange({added:a,removed:f})})}},clearSearch:function(){this.search.val(""),this.focusser.val("")},data:function(a){var c,d=!1;return 0===arguments.length?(c=this.selection.data("select2-data"),c==b&&(c=null),c):(this.opts.debug&&console&&console.warn&&console.warn('Select2: The `select2("data")` method can no longer set selected values in 4.0.0, consider using the `.val()` method instead.'),arguments.length>1&&(d=arguments[1]),a?(c=this.data(),this.opts.element.val(a?this.id(a):""),this.updateSelection(a),d&&this.triggerChange({added:a,removed:c})):this.clear(d),void 0)}}),e=O(c,{createContainer:function(){var b=a(document.createElement("div")).attr({"class":"select2-container select2-container-multi"}).html(["<ul class='select2-choices'>","  <li class='select2-search-field'>","    <label for='' class='select2-offscreen'></label>","    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>","  </li>","</ul>","<div class='select2-drop select2-drop-multi select2-display-none'>","   <ul class='select2-results'>","   </ul>","</div>"].join(""));return b},prepareOpts:function(){var b=this.parent.prepareOpts.apply(this,arguments),c=this;return"select"===b.element.get(0).tagName.toLowerCase()?b.initSelection=function(a,b){var d=[];a.find("option").filter(function(){return this.selected&&!this.disabled}).each2(function(a,b){d.push(c.optionToData(b))}),b(d)}:"data"in b&&(b.initSelection=b.initSelection||function(c,d){var e=s(c.val(),b.separator,b.transformVal),f=[];b.query({matcher:function(c,d,g){var h=a.grep(e,function(a){return r(a,b.id(g))}).length;return h&&f.push(g),h},callback:a.isFunction(d)?function(){for(var a=[],c=0;c<e.length;c++)for(var g=e[c],h=0;h<f.length;h++){var i=f[h];if(r(g,b.id(i))){a.push(i),f.splice(h,1);break}}d(a)}:a.noop})}),b},selectChoice:function(a){var b=this.container.find(".select2-search-choice-focus");b.length&&a&&a[0]==b[0]||(b.length&&this.opts.element.trigger("choice-deselected",b),b.removeClass("select2-search-choice-focus"),a&&a.length&&(this.close(),a.addClass("select2-search-choice-focus"),this.opts.element.trigger("choice-selected",a)))},destroy:function(){a("label[for='"+this.search.attr("id")+"']").attr("for",this.opts.element.attr("id")),this.parent.destroy.apply(this,arguments),N.call(this,"searchContainer","selection")},initContainer:function(){var c,b=".select2-choices";this.searchContainer=this.container.find(".select2-search-field"),this.selection=c=this.container.find(b);var d=this;this.selection.on("click",".select2-container:not(.select2-container-disabled) .select2-search-choice:not(.select2-locked)",function(b){d.search[0].focus(),d.selectChoice(a(this))}),this.search.attr("id","s2id_autogen"+f()),this.search.prev().text(a("label[for='"+this.opts.element.attr("id")+"']").text()).attr("for",this.search.attr("id")),this.opts.element.on("focus.select2",this.bind(function(){this.focus()})),this.search.on("input paste",this.bind(function(){this.search.attr("placeholder")&&0==this.search.val().length||this.isInterfaceEnabled()&&(this.opened()||this.open())})),this.search.attr("tabindex",this.elementTabIndex),this.keydowns=0,this.search.on("keydown",this.bind(function(a){if(this.isInterfaceEnabled()){++this.keydowns;var b=c.find(".select2-search-choice-focus"),d=b.prev(".select2-search-choice:not(.select2-locked)"),e=b.next(".select2-search-choice:not(.select2-locked)"),f=z(this.search);if(b.length&&(a.which==k.LEFT||a.which==k.RIGHT||a.which==k.BACKSPACE||a.which==k.DELETE||a.which==k.ENTER)){var g=b;return a.which==k.LEFT&&d.length?g=d:a.which==k.RIGHT?g=e.length?e:null:a.which===k.BACKSPACE?this.unselect(b.first())&&(this.search.width(10),g=d.length?d:e):a.which==k.DELETE?this.unselect(b.first())&&(this.search.width(10),g=e.length?e:null):a.which==k.ENTER&&(g=null),this.selectChoice(g),A(a),void(g&&g.length||this.open())}if((a.which===k.BACKSPACE&&1==this.keydowns||a.which==k.LEFT)&&0==f.offset&&!f.length)return this.selectChoice(c.find(".select2-search-choice:not(.select2-locked)").last()),void A(a);if(this.selectChoice(null),this.opened())switch(a.which){case k.UP:case k.DOWN:return this.moveHighlight(a.which===k.UP?-1:1),void A(a);case k.ENTER:return this.selectHighlighted(),void A(a);case k.TAB:return this.selectHighlighted({noFocus:!0}),void this.close();case k.ESC:return this.cancel(a),void A(a)}if(a.which!==k.TAB&&!k.isControl(a)&&!k.isFunctionKey(a)&&a.which!==k.BACKSPACE&&a.which!==k.ESC){if(a.which===k.ENTER){if(this.opts.openOnEnter===!1)return;if(a.altKey||a.ctrlKey||a.shiftKey||a.metaKey)return}this.open(),(a.which===k.PAGE_UP||a.which===k.PAGE_DOWN)&&A(a),a.which===k.ENTER&&A(a)}}})),this.search.on("keyup",this.bind(function(a){this.keydowns=0,this.resizeSearch()})),this.search.on("blur",this.bind(function(b){this.container.removeClass("select2-container-active"),this.search.removeClass("select2-focused"),this.selectChoice(null),this.opened()||this.clearSearch(),b.stopImmediatePropagation(),this.opts.element.trigger(a.Event("select2-blur"))})),this.container.on("click",b,this.bind(function(b){this.isInterfaceEnabled()&&(a(b.target).closest(".select2-search-choice").length>0||(this.selectChoice(null),this.clearPlaceholder(),this.container.hasClass("select2-container-active")||this.opts.element.trigger(a.Event("select2-focus")),this.open(),this.focusSearch(),b.preventDefault()))})),this.container.on("focus",b,this.bind(function(){this.isInterfaceEnabled()&&(this.container.hasClass("select2-container-active")||this.opts.element.trigger(a.Event("select2-focus")),this.container.addClass("select2-container-active"),this.dropdown.addClass("select2-drop-active"),this.clearPlaceholder())})),this.initContainerWidth(),this.opts.element.hide(),this.clearSearch()},enableInterface:function(){this.parent.enableInterface.apply(this,arguments)&&this.search.prop("disabled",!this.isInterfaceEnabled())},initSelection:function(){if(""===this.opts.element.val()&&""===this.opts.element.text()&&(this.updateSelection([]),this.close(),this.clearSearch()),this.select||""!==this.opts.element.val()){var c=this;this.opts.initSelection.call(null,this.opts.element,function(a){a!==b&&null!==a&&(c.updateSelection(a),c.close(),c.clearSearch())})}},clearSearch:function(){var a=this.getPlaceholder(),c=this.getMaxSearchWidth();a!==b&&0===this.getVal().length&&this.search.hasClass("select2-focused")===!1?(this.search.val(a).addClass("select2-default"),this.search.width(c>0?c:this.container.css("width"))):this.search.val("").width(10)},clearPlaceholder:function(){this.search.hasClass("select2-default")&&this.search.val("").removeClass("select2-default")},opening:function(){this.clearPlaceholder(),this.resizeSearch(),this.parent.opening.apply(this,arguments),this.focusSearch(),this.prefillNextSearchTerm(),this.updateResults(!0),this.opts.shouldFocusInput(this)&&this.search.focus(),this.opts.element.trigger(a.Event("select2-open"))},close:function(){this.opened()&&this.parent.close.apply(this,arguments)},focus:function(){this.close(),this.search.focus()},isFocused:function(){return this.search.hasClass("select2-focused")},updateSelection:function(b){var c={},d=[],e=this;a(b).each(function(){e.id(this)in c||(c[e.id(this)]=0,d.push(this))}),this.selection.find(".select2-search-choice").remove(),this.addSelectedChoice(d),e.postprocessResults()},tokenize:function(){var a=this.search.val();a=this.opts.tokenizer.call(this,a,this.data(),this.bind(this.onSelect),this.opts),null!=a&&a!=b&&(this.search.val(a),a.length>0&&this.open())},onSelect:function(a,b){this.triggerSelect(a)&&""!==a.text&&(this.addSelectedChoice(a),this.opts.element.trigger({type:"selected",val:this.id(a),choice:a}),this.lastSearchTerm=this.search.val(),this.clearSearch(),this.updateResults(),(this.select||!this.opts.closeOnSelect)&&this.postprocessResults(a,!1,this.opts.closeOnSelect===!0),this.opts.closeOnSelect?(this.close(),this.search.width(10)):this.countSelectableResults()>0?(this.search.width(10),this.resizeSearch(),this.getMaximumSelectionSize()>0&&this.val().length>=this.getMaximumSelectionSize()?this.updateResults(!0):this.prefillNextSearchTerm()&&this.updateResults(),this.positionDropdown()):(this.close(),this.search.width(10)),this.triggerChange({added:a}),b&&b.noFocus||this.focusSearch())},cancel:function(){this.close(),this.focusSearch()},addSelectedChoice:function(b){var c=this.getVal(),d=this;a(b).each(function(){c.push(d.createChoice(this))}),this.setVal(c)},createChoice:function(c){var i,j,d=!c.locked,e=a("<li class='select2-search-choice'>    <div></div>    <a href='#' class='select2-search-choice-close' tabindex='-1'></a></li>"),f=a("<li class='select2-search-choice select2-locked'><div></div></li>"),g=d?e:f,h=this.id(c);return i=this.opts.formatSelection(c,g.find("div"),this.opts.escapeMarkup),i!=b&&g.find("div").replaceWith(a("<div></div>").html(i)),j=this.opts.formatSelectionCssClass(c,g.find("div")),j!=b&&g.addClass(j),d&&g.find(".select2-search-choice-close").on("mousedown",A).on("click dblclick",this.bind(function(b){this.isInterfaceEnabled()&&(this.unselect(a(b.target)),this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus"),A(b),this.close(),this.focusSearch())})).on("focus",this.bind(function(){this.isInterfaceEnabled()&&(this.container.addClass("select2-container-active"),this.dropdown.addClass("select2-drop-active"))})),g.data("select2-data",c),g.insertBefore(this.searchContainer),h},unselect:function(b){var d,e,c=this.getVal();if(b=b.closest(".select2-search-choice"),0===b.length)throw"Invalid argument: "+b+". Must be .select2-search-choice";if(d=b.data("select2-data")){var f=a.Event("select2-removing");if(f.val=this.id(d),f.choice=d,this.opts.element.trigger(f),f.isDefaultPrevented())return!1;for(;(e=p(this.id(d),c))>=0;)c.splice(e,1),this.setVal(c),this.select&&this.postprocessResults();return b.remove(),this.opts.element.trigger({type:"select2-removed",val:this.id(d),choice:d}),this.triggerChange({removed:d}),!0}},postprocessResults:function(a,b,c){var d=this.getVal(),e=this.results.find(".select2-result"),f=this.results.find(".select2-result-with-children"),g=this;e.each2(function(a,b){var c=g.id(b.data("select2-data"));p(c,d)>=0&&(b.addClass("select2-selected"),b.find(".select2-result-selectable").addClass("select2-selected"))}),f.each2(function(a,b){b.is(".select2-result-selectable")||0!==b.find(".select2-result-selectable:not(.select2-selected)").length||b.addClass("select2-selected")}),-1==this.highlight()&&c!==!1&&this.opts.closeOnSelect===!0&&g.highlight(0),!this.opts.createSearchChoice&&!e.filter(".select2-result:not(.select2-selected)").length>0&&(!a||a&&!a.more&&0===this.results.find(".select2-no-results").length)&&J(g.opts.formatNoMatches,"formatNoMatches")&&this.results.append("<li class='select2-no-results'>"+K(g.opts.formatNoMatches,g.opts.element,g.search.val())+"</li>")},getMaxSearchWidth:function(){return this.selection.width()-t(this.search)},resizeSearch:function(){var a,b,c,d,e,f=t(this.search);a=C(this.search)+10,b=this.search.offset().left,c=this.selection.width(),d=this.selection.offset().left,e=c-(b-d)-f,a>e&&(e=c-f),40>e&&(e=c-f),0>=e&&(e=a),this.search.width(Math.floor(e))},getVal:function(){var a;return this.select?(a=this.select.val(),null===a?[]:a):(a=this.opts.element.val(),s(a,this.opts.separator,this.opts.transformVal))},setVal:function(b){if(this.select)this.select.val(b);else{var c=[],d={};a(b).each(function(){this in d||(c.push(this),d[this]=0)}),this.opts.element.val(0===c.length?"":c.join(this.opts.separator))}},buildChangeDetails:function(a,b){
for(var b=b.slice(0),a=a.slice(0),c=0;c<b.length;c++)for(var d=0;d<a.length;d++)if(r(this.opts.id(b[c]),this.opts.id(a[d]))){b.splice(c,1),c--,a.splice(d,1);break}return{added:b,removed:a}},val:function(c,d){var e,f=this;if(0===arguments.length)return this.getVal();if(e=this.data(),e.length||(e=[]),!c&&0!==c)return this.opts.element.val(""),this.updateSelection([]),this.clearSearch(),void(d&&this.triggerChange({added:this.data(),removed:e}));if(this.setVal(c),this.select)this.opts.initSelection(this.select,this.bind(this.updateSelection)),d&&this.triggerChange(this.buildChangeDetails(e,this.data()));else{if(this.opts.initSelection===b)throw new Error("val() cannot be called if initSelection() is not defined");this.opts.initSelection(this.opts.element,function(b){var c=a.map(b,f.id);f.setVal(c),f.updateSelection(b),f.clearSearch(),d&&f.triggerChange(f.buildChangeDetails(e,f.data()))})}this.clearSearch()},onSortStart:function(){if(this.select)throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");this.search.width(0),this.searchContainer.hide()},onSortEnd:function(){var b=[],c=this;this.searchContainer.show(),this.searchContainer.appendTo(this.searchContainer.parent()),this.resizeSearch(),this.selection.find(".select2-search-choice").each(function(){b.push(c.opts.id(a(this).data("select2-data")))}),this.setVal(b),this.triggerChange()},data:function(b,c){var e,f,d=this;return 0===arguments.length?this.selection.children(".select2-search-choice").map(function(){return a(this).data("select2-data")}).get():(f=this.data(),b||(b=[]),e=a.map(b,function(a){return d.opts.id(a)}),this.setVal(e),this.updateSelection(b),this.clearSearch(),c&&this.triggerChange(this.buildChangeDetails(f,this.data())),void 0)}}),a.fn.select2=function(){var d,e,f,g,h,c=Array.prototype.slice.call(arguments,0),i=["val","destroy","opened","open","close","focus","isFocused","container","dropdown","onSortStart","onSortEnd","enable","disable","readonly","positionDropdown","data","search"],j=["opened","isFocused","container","dropdown"],k=["val","data"],l={search:"externalSearch"};return this.each(function(){if(0===c.length||"object"==typeof c[0])d=0===c.length?{}:a.extend({},c[0]),d.element=a(this),"select"===d.element.get(0).tagName.toLowerCase()?h=d.element.prop("multiple"):(h=d.multiple||!1,"tags"in d&&(d.multiple=h=!0)),e=h?new window.Select2["class"].multi:new window.Select2["class"].single,e.init(d);else{if("string"!=typeof c[0])throw"Invalid arguments to select2 plugin: "+c;if(p(c[0],i)<0)throw"Unknown method: "+c[0];if(g=b,e=a(this).data("select2"),e===b)return;if(f=c[0],"container"===f?g=e.container:"dropdown"===f?g=e.dropdown:(l[f]&&(f=l[f]),g=e[f].apply(e,c.slice(1))),p(c[0],j)>=0||p(c[0],k)>=0&&1==c.length)return!1}}),g===b?this:g},a.fn.select2.defaults={debug:!1,width:"copy",loadMorePadding:0,closeOnSelect:!0,openOnEnter:!0,containerCss:{},dropdownCss:{},containerCssClass:"",dropdownCssClass:"",formatResult:function(a,b,c,d){var e=[];return E(this.text(a),c.term,e,d),e.join("")},transformVal:function(b){return a.trim(b)},formatSelection:function(a,c,d){return a?d(this.text(a)):b},sortResults:function(a,b,c){return a},formatResultCssClass:function(a){return a.css},formatSelectionCssClass:function(a,c){return b},minimumResultsForSearch:0,minimumInputLength:0,maximumInputLength:null,maximumSelectionSize:0,id:function(a){return a==b?null:a.id},text:function(b){return b&&this.data&&this.data.text?a.isFunction(this.data.text)?this.data.text(b):b[this.data.text]:b.text},matcher:function(a,b){return o(""+b).toUpperCase().indexOf(o(""+a).toUpperCase())>=0},separator:",",tokenSeparators:[],tokenizer:M,escapeMarkup:F,blurOnChange:!1,selectOnBlur:!1,adaptContainerCssClass:function(a){return a},adaptDropdownCssClass:function(a){return null},nextSearchTerm:function(a,c){return b},searchInputPlaceholder:"",createSearchChoicePosition:"top",shouldFocusInput:function(a){var b="ontouchstart"in window||navigator.msMaxTouchPoints>0;return b&&a.opts.minimumResultsForSearch<0?!1:!0}},a.fn.select2.locales=[],a.fn.select2.locales.en={formatMatches:function(a){return 1===a?"One result is available, press enter to select it.":a+" results are available, use up and down arrow keys to navigate."},formatNoMatches:function(){return"No matches found"},formatAjaxError:function(a,b,c){return"Loading failed"},formatInputTooShort:function(a,b){var c=b-a.length;return"Please enter "+c+" or more character"+(1==c?"":"s")},formatInputTooLong:function(a,b){var c=a.length-b;return"Please delete "+c+" character"+(1==c?"":"s")},formatSelectionTooBig:function(a){return"You can only select "+a+" item"+(1==a?"":"s")},formatLoadMore:function(a){return"Loading more results\u2026"},formatSearching:function(){return"Searching\u2026"}},a.extend(a.fn.select2.defaults,a.fn.select2.locales.en),a.fn.select2.ajaxDefaults={transport:a.ajax,params:{type:"GET",cache:!1,dataType:"json"}},window.Select2={query:{ajax:G,local:H,tags:I},util:{debounce:w,markMatch:E,escapeMarkup:F,stripDiacritics:o},"class":{"abstract":c,single:d,multi:e}}}}(jQuery);;
/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * License: MIT
 */angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse","ui.bootstrap.tabindex","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.dateparser","ui.bootstrap.isClass","ui.bootstrap.datepicker","ui.bootstrap.position","ui.bootstrap.datepickerPopup","ui.bootstrap.debounce","ui.bootstrap.dropdown","ui.bootstrap.stackedMap","ui.bootstrap.modal","ui.bootstrap.paging","ui.bootstrap.pager","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html","uib/template/accordion/accordion.html","uib/template/alert/alert.html","uib/template/carousel/carousel.html","uib/template/carousel/slide.html","uib/template/datepicker/datepicker.html","uib/template/datepicker/day.html","uib/template/datepicker/month.html","uib/template/datepicker/year.html","uib/template/datepickerPopup/popup.html","uib/template/modal/window.html","uib/template/pager/pager.html","uib/template/pagination/pagination.html","uib/template/tooltip/tooltip-html-popup.html","uib/template/tooltip/tooltip-popup.html","uib/template/tooltip/tooltip-template-popup.html","uib/template/popover/popover-html.html","uib/template/popover/popover-template.html","uib/template/popover/popover.html","uib/template/progressbar/bar.html","uib/template/progressbar/progress.html","uib/template/progressbar/progressbar.html","uib/template/rating/rating.html","uib/template/tabs/tab.html","uib/template/tabs/tabset.html","uib/template/timepicker/timepicker.html","uib/template/typeahead/typeahead-match.html","uib/template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.collapse', [])

  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {
	var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
	return {
	  link: function(scope, element, attrs) {
		var expandingExpr = $parse(attrs.expanding),
		  expandedExpr = $parse(attrs.expanded),
		  collapsingExpr = $parse(attrs.collapsing),
		  collapsedExpr = $parse(attrs.collapsed),
		  horizontal = false,
		  css = {},
		  cssTo = {};

		init();

		function init() {
		  horizontal = !!('horizontal' in attrs);
		  if (horizontal) {
			css = {
			  width: 'auto',
			  height: 'inherit'
			};
			cssTo = {width: '0'};
		  } else {
			css = {
			  width: 'inherit',
			  height: 'auto'
			};
			cssTo = {height: '0'};
		  }
		  if (!scope.$eval(attrs.uibCollapse)) {
			element.addClass('in')
			  .addClass('collapse')
			  .attr('aria-expanded', true)
			  .attr('aria-hidden', false)
			  .css(css);
		  }
		}

		function getScrollFromElement(element) {
		  if (horizontal) {
			return {width: element.scrollWidth + 'px'};
		  }
		  return {height: element.scrollHeight + 'px'};
		}

		function expand() {
		  if (element.hasClass('collapse') && element.hasClass('in')) {
			return;
		  }

		  $q.resolve(expandingExpr(scope))
			.then(function() {
			  element.removeClass('collapse')
				.addClass('collapsing')
				.attr('aria-expanded', true)
				.attr('aria-hidden', false);

			  if ($animateCss) {
				$animateCss(element, {
				  addClass: 'in',
				  easing: 'ease',
				  to: getScrollFromElement(element[0])
				}).start()['finally'](expandDone);
			  } else {
				$animate.addClass(element, 'in', {
				  to: getScrollFromElement(element[0])
				}).then(expandDone);
			  }
			});
		}

		function expandDone() {
		  element.removeClass('collapsing')
			.addClass('collapse')
			.css(css);
		  expandedExpr(scope);
		}

		function collapse() {
		  if (!element.hasClass('collapse') && !element.hasClass('in')) {
			return collapseDone();
		  }

		  $q.resolve(collapsingExpr(scope))
			.then(function() {
			  element
			  // IMPORTANT: The width must be set before adding "collapsing" class.
			  // Otherwise, the browser attempts to animate from width 0 (in
			  // collapsing class) to the given width here.
				.css(getScrollFromElement(element[0]))
				// initially all panel collapse have the collapse class, this removal
				// prevents the animation from jumping to collapsed state
				.removeClass('collapse')
				.addClass('collapsing')
				.attr('aria-expanded', false)
				.attr('aria-hidden', true);

			  if ($animateCss) {
				$animateCss(element, {
				  removeClass: 'in',
				  to: cssTo
				}).start()['finally'](collapseDone);
			  } else {
				$animate.removeClass(element, 'in', {
				  to: cssTo
				}).then(collapseDone);
			  }
			});
		}

		function collapseDone() {
		  element.css(cssTo); // Required so that collapse works when animation is disabled
		  element.removeClass('collapsing')
			.addClass('collapse');
		  collapsedExpr(scope);
		}

		scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
		  if (shouldCollapse) {
			collapse();
		  } else {
			expand();
		  }
		});
	  }
	};
  }]);

angular.module('ui.bootstrap.tabindex', [])

.directive('uibTabindexToggle', function() {
  return {
	restrict: 'A',
	link: function(scope, elem, attrs) {
	  attrs.$observe('disabled', function(disabled) {
		attrs.$set('tabindex', disabled ? -1 : null);
	  });
	}
  };
});

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse', 'ui.bootstrap.tabindex'])

.constant('uibAccordionConfig', {
  closeOthers: true
})

.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
  // This array keeps track of the accordion groups
  this.groups = [];

  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
  this.closeOthers = function(openGroup) {
	var closeOthers = angular.isDefined($attrs.closeOthers) ?
	  $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
	if (closeOthers) {
	  angular.forEach(this.groups, function(group) {
		if (group !== openGroup) {
		  group.isOpen = false;
		}
	  });
	}
  };

  // This is called from the accordion-group directive to add itself to the accordion
  this.addGroup = function(groupScope) {
	var that = this;
	this.groups.push(groupScope);

	groupScope.$on('$destroy', function(event) {
	  that.removeGroup(groupScope);
	});
  };

  // This is called from the accordion-group directive when to remove itself
  this.removeGroup = function(group) {
	var index = this.groups.indexOf(group);
	if (index !== -1) {
	  this.groups.splice(index, 1);
	}
  };
}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive('uibAccordion', function() {
  return {
	controller: 'UibAccordionController',
	controllerAs: 'accordion',
	transclude: true,
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || 'uib/template/accordion/accordion.html';
	}
  };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('uibAccordionGroup', function() {
  return {
	require: '^uibAccordion',         // We need this directive to be inside an accordion
	transclude: true,              // It transcludes the contents of the directive into the template
	restrict: 'A',
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
	},
	scope: {
	  heading: '@',               // Interpolate the heading attribute onto this scope
	  panelClass: '@?',           // Ditto with panelClass
	  isOpen: '=?',
	  isDisabled: '=?'
	},
	controller: function() {
	  this.setHeading = function(element) {
		this.heading = element;
	  };
	},
	link: function(scope, element, attrs, accordionCtrl) {
	  element.addClass('panel');
	  accordionCtrl.addGroup(scope);

	  scope.openClass = attrs.openClass || 'panel-open';
	  scope.panelClass = attrs.panelClass || 'panel-default';
	  scope.$watch('isOpen', function(value) {
		element.toggleClass(scope.openClass, !!value);
		if (value) {
		  accordionCtrl.closeOthers(scope);
		}
	  });

	  scope.toggleOpen = function($event) {
		if (!scope.isDisabled) {
		  if (!$event || $event.which === 32) {
			scope.isOpen = !scope.isOpen;
		  }
		}
	  };

	  var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
	  scope.headingId = id + '-tab';
	  scope.panelId = id + '-panel';
	}
  };
})

// Use accordion-heading below an accordion-group to provide a heading containing HTML
.directive('uibAccordionHeading', function() {
  return {
	transclude: true,   // Grab the contents to be used as the heading
	template: '',       // In effect remove this element!
	replace: true,
	require: '^uibAccordionGroup',
	link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
	  // Pass the heading to the accordion-group controller
	  // so that it can be transcluded into the right place in the template
	  // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
	  accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
	}
  };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
.directive('uibAccordionTransclude', function() {
  return {
	require: '^uibAccordionGroup',
	link: function(scope, element, attrs, controller) {
	  scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {
		if (heading) {
		  var elem = angular.element(element[0].querySelector(getHeaderSelectors()));
		  elem.html('');
		  elem.append(heading);
		}
	  });
	}
  };

  function getHeaderSelectors() {
	  return 'uib-accordion-header,' +
		  'data-uib-accordion-header,' +
		  'x-uib-accordion-header,' +
		  'uib\\:accordion-header,' +
		  '[uib-accordion-header],' +
		  '[data-uib-accordion-header],' +
		  '[x-uib-accordion-header]';
  }
});

angular.module('ui.bootstrap.alert', [])

.controller('UibAlertController', ['$scope', '$element', '$attrs', '$interpolate', '$timeout', function($scope, $element, $attrs, $interpolate, $timeout) {
  $scope.closeable = !!$attrs.close;
  $element.addClass('alert');
  $attrs.$set('role', 'alert');
  if ($scope.closeable) {
	$element.addClass('alert-dismissible');
  }

  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
	$interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;

  if (dismissOnTimeout) {
	$timeout(function() {
	  $scope.close();
	}, parseInt(dismissOnTimeout, 10));
  }
}])

.directive('uibAlert', function() {
  return {
	controller: 'UibAlertController',
	controllerAs: 'alert',
	restrict: 'A',
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || 'uib/template/alert/alert.html';
	},
	transclude: true,
	scope: {
	  close: '&'
	}
  };
});

angular.module('ui.bootstrap.buttons', [])

.constant('uibButtonConfig', {
  activeClass: 'active',
  toggleEvent: 'click'
})

.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
  this.activeClass = buttonConfig.activeClass || 'active';
  this.toggleEvent = buttonConfig.toggleEvent || 'click';
}])

.directive('uibBtnRadio', ['$parse', function($parse) {
  return {
	require: ['uibBtnRadio', 'ngModel'],
	controller: 'UibButtonsController',
	controllerAs: 'buttons',
	link: function(scope, element, attrs, ctrls) {
	  var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	  var uncheckableExpr = $parse(attrs.uibUncheckable);

	  element.find('input').css({display: 'none'});

	  //model -> UI
	  ngModelCtrl.$render = function() {
		element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
	  };

	  //ui->model
	  element.on(buttonsCtrl.toggleEvent, function() {
		if (attrs.disabled) {
		  return;
		}

		var isActive = element.hasClass(buttonsCtrl.activeClass);

		if (!isActive || angular.isDefined(attrs.uncheckable)) {
		  scope.$apply(function() {
			ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
			ngModelCtrl.$render();
		  });
		}
	  });

	  if (attrs.uibUncheckable) {
		scope.$watch(uncheckableExpr, function(uncheckable) {
		  attrs.$set('uncheckable', uncheckable ? '' : undefined);
		});
	  }
	}
  };
}])

.directive('uibBtnCheckbox', function() {
  return {
	require: ['uibBtnCheckbox', 'ngModel'],
	controller: 'UibButtonsController',
	controllerAs: 'button',
	link: function(scope, element, attrs, ctrls) {
	  var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

	  element.find('input').css({display: 'none'});

	  function getTrueValue() {
		return getCheckboxValue(attrs.btnCheckboxTrue, true);
	  }

	  function getFalseValue() {
		return getCheckboxValue(attrs.btnCheckboxFalse, false);
	  }

	  function getCheckboxValue(attribute, defaultValue) {
		return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
	  }

	  //model -> UI
	  ngModelCtrl.$render = function() {
		element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
	  };

	  //ui->model
	  element.on(buttonsCtrl.toggleEvent, function() {
		if (attrs.disabled) {
		  return;
		}

		scope.$apply(function() {
		  ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
		  ngModelCtrl.$render();
		});
	  });
	}
  };
});

angular.module('ui.bootstrap.carousel', [])

.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {
  var self = this,
	slides = self.slides = $scope.slides = [],
	SLIDE_DIRECTION = 'uib-slideDirection',
	currentIndex = $scope.active,
	currentInterval, isPlaying, bufferedTransitions = [];

  var destroyed = false;
  $element.addClass('carousel');

  self.addSlide = function(slide, element) {
	slides.push({
	  slide: slide,
	  element: element
	});
	slides.sort(function(a, b) {
	  return +a.slide.index - +b.slide.index;
	});
	//if this is the first slide or the slide is set to active, select it
	if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {
	  if ($scope.$currentTransition) {
		$scope.$currentTransition = null;
	  }

	  currentIndex = slide.index;
	  $scope.active = slide.index;
	  setActive(currentIndex);
	  self.select(slides[findSlideIndex(slide)]);
	  if (slides.length === 1) {
		$scope.play();
	  }
	}
  };

  self.getCurrentIndex = function() {
	for (var i = 0; i < slides.length; i++) {
	  if (slides[i].slide.index === currentIndex) {
		return i;
	  }
	}
  };

  self.next = $scope.next = function() {
	var newIndex = (self.getCurrentIndex() + 1) % slides.length;

	if (newIndex === 0 && $scope.noWrap()) {
	  $scope.pause();
	  return;
	}

	return self.select(slides[newIndex], 'next');
  };

  self.prev = $scope.prev = function() {
	var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

	if ($scope.noWrap() && newIndex === slides.length - 1) {
	  $scope.pause();
	  return;
	}

	return self.select(slides[newIndex], 'prev');
  };

  self.removeSlide = function(slide) {
	var index = findSlideIndex(slide);

	var bufferedIndex = bufferedTransitions.indexOf(slides[index]);
	if (bufferedIndex !== -1) {
	  bufferedTransitions.splice(bufferedIndex, 1);
	}

	//get the index of the slide inside the carousel
	slides.splice(index, 1);
	if (slides.length > 0 && currentIndex === index) {
	  if (index >= slides.length) {
		currentIndex = slides.length - 1;
		$scope.active = currentIndex;
		setActive(currentIndex);
		self.select(slides[slides.length - 1]);
	  } else {
		currentIndex = index;
		$scope.active = currentIndex;
		setActive(currentIndex);
		self.select(slides[index]);
	  }
	} else if (currentIndex > index) {
	  currentIndex--;
	  $scope.active = currentIndex;
	}

	//clean the active value when no more slide
	if (slides.length === 0) {
	  currentIndex = null;
	  $scope.active = null;
	  clearBufferedTransitions();
	}
  };

  /* direction: "prev" or "next" */
  self.select = $scope.select = function(nextSlide, direction) {
	var nextIndex = findSlideIndex(nextSlide.slide);
	//Decide direction if it's not given
	if (direction === undefined) {
	  direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
	}
	//Prevent this user-triggered transition from occurring if there is already one in progress
	if (nextSlide.slide.index !== currentIndex &&
	  !$scope.$currentTransition) {
	  goNext(nextSlide.slide, nextIndex, direction);
	} else if (nextSlide && nextSlide.slide.index !== currentIndex && $scope.$currentTransition) {
	  bufferedTransitions.push(slides[nextIndex]);
	}
  };

  /* Allow outside people to call indexOf on slides array */
  $scope.indexOfSlide = function(slide) {
	return +slide.slide.index;
  };

  $scope.isActive = function(slide) {
	return $scope.active === slide.slide.index;
  };

  $scope.isPrevDisabled = function() {
	return $scope.active === 0 && $scope.noWrap();
  };

  $scope.isNextDisabled = function() {
	return $scope.active === slides.length - 1 && $scope.noWrap();
  };

  $scope.pause = function() {
	if (!$scope.noPause) {
	  isPlaying = false;
	  resetTimer();
	}
  };

  $scope.play = function() {
	if (!isPlaying) {
	  isPlaying = true;
	  restartTimer();
	}
  };

  $element.on('mouseenter', $scope.pause);
  $element.on('mouseleave', $scope.play);

  $scope.$on('$destroy', function() {
	destroyed = true;
	resetTimer();
  });

  $scope.$watch('noTransition', function(noTransition) {
	$animate.enabled($element, !noTransition);
  });

  $scope.$watch('interval', restartTimer);

  $scope.$watchCollection('slides', resetTransition);

  $scope.$watch('active', function(index) {
	if (angular.isNumber(index) && currentIndex !== index) {
	  for (var i = 0; i < slides.length; i++) {
		if (slides[i].slide.index === index) {
		  index = i;
		  break;
		}
	  }

	  var slide = slides[index];
	  if (slide) {
		setActive(index);
		self.select(slides[index]);
		currentIndex = index;
	  }
	}
  });

  function clearBufferedTransitions() {
	while (bufferedTransitions.length) {
	  bufferedTransitions.shift();
	}
  }

  function getSlideByIndex(index) {
	for (var i = 0, l = slides.length; i < l; ++i) {
	  if (slides[i].index === index) {
		return slides[i];
	  }
	}
  }

  function setActive(index) {
	for (var i = 0; i < slides.length; i++) {
	  slides[i].slide.active = i === index;
	}
  }

  function goNext(slide, index, direction) {
	if (destroyed) {
	  return;
	}

	angular.extend(slide, {direction: direction});
	angular.extend(slides[currentIndex].slide || {}, {direction: direction});
	if ($animate.enabled($element) && !$scope.$currentTransition &&
	  slides[index].element && self.slides.length > 1) {
	  slides[index].element.data(SLIDE_DIRECTION, slide.direction);
	  var currentIdx = self.getCurrentIndex();

	  if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
		slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
	  }

	  $scope.$currentTransition = true;
	  $animate.on('addClass', slides[index].element, function(element, phase) {
		if (phase === 'close') {
		  $scope.$currentTransition = null;
		  $animate.off('addClass', element);
		  if (bufferedTransitions.length) {
			var nextSlide = bufferedTransitions.pop().slide;
			var nextIndex = nextSlide.index;
			var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
			clearBufferedTransitions();

			goNext(nextSlide, nextIndex, nextDirection);
		  }
		}
	  });
	}

	$scope.active = slide.index;
	currentIndex = slide.index;
	setActive(index);

	//every time you change slides, reset the timer
	restartTimer();
  }

  function findSlideIndex(slide) {
	for (var i = 0; i < slides.length; i++) {
	  if (slides[i].slide === slide) {
		return i;
	  }
	}
  }

  function resetTimer() {
	if (currentInterval) {
	  $interval.cancel(currentInterval);
	  currentInterval = null;
	}
  }

  function resetTransition(slides) {
	if (!slides.length) {
	  $scope.$currentTransition = null;
	  clearBufferedTransitions();
	}
  }

  function restartTimer() {
	resetTimer();
	var interval = +$scope.interval;
	if (!isNaN(interval) && interval > 0) {
	  currentInterval = $interval(timerFn, interval);
	}
  }

  function timerFn() {
	var interval = +$scope.interval;
	if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
	  $scope.next();
	} else {
	  $scope.pause();
	}
  }
}])

.directive('uibCarousel', function() {
  return {
	transclude: true,
	controller: 'UibCarouselController',
	controllerAs: 'carousel',
	restrict: 'A',
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || 'uib/template/carousel/carousel.html';
	},
	scope: {
	  active: '=',
	  interval: '=',
	  noTransition: '=',
	  noPause: '=',
	  noWrap: '&'
	}
  };
})

.directive('uibSlide', ['$animate', function($animate) {
  return {
	require: '^uibCarousel',
	restrict: 'A',
	transclude: true,
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || 'uib/template/carousel/slide.html';
	},
	scope: {
	  actual: '=?',
	  index: '=?'
	},
	link: function (scope, element, attrs, carouselCtrl) {
	  element.addClass('item');
	  carouselCtrl.addSlide(scope, element);
	  //when the scope is destroyed then remove the slide from the current slides array
	  scope.$on('$destroy', function() {
		carouselCtrl.removeSlide(scope);
	  });

	  scope.$watch('active', function(active) {
		$animate[active ? 'addClass' : 'removeClass'](element, 'active');
	  });
	}
  };
}])

.animation('.item', ['$animateCss',
function($animateCss) {
  var SLIDE_DIRECTION = 'uib-slideDirection';

  function removeClass(element, className, callback) {
	element.removeClass(className);
	if (callback) {
	  callback();
	}
  }

  return {
	beforeAddClass: function(element, className, done) {
	  if (className === 'active') {
		var stopped = false;
		var direction = element.data(SLIDE_DIRECTION);
		var directionClass = direction === 'next' ? 'left' : 'right';
		var removeClassFn = removeClass.bind(this, element,
		  directionClass + ' ' + direction, done);
		element.addClass(direction);

		$animateCss(element, {addClass: directionClass})
		  .start()
		  .done(removeClassFn);

		return function() {
		  stopped = true;
		};
	  }
	  done();
	},
	beforeRemoveClass: function (element, className, done) {
	  if (className === 'active') {
		var stopped = false;
		var direction = element.data(SLIDE_DIRECTION);
		var directionClass = direction === 'next' ? 'left' : 'right';
		var removeClassFn = removeClass.bind(this, element, directionClass, done);

		$animateCss(element, {addClass: directionClass})
		  .start()
		  .done(removeClassFn);

		return function() {
		  stopped = true;
		};
	  }
	  done();
	}
  };
}]);

angular.module('ui.bootstrap.dateparser', [])

.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {
  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

  var localeId;
  var formatCodeToRegex;

  this.init = function() {
	localeId = $locale.id;

	this.parsers = {};
	this.formatters = {};

	formatCodeToRegex = [
	  {
		key: 'yyyy',
		regex: '\\d{4}',
		apply: function(value) { this.year = +value; },
		formatter: function(date) {
		  var _date = new Date();
		  _date.setFullYear(Math.abs(date.getFullYear()));
		  return dateFilter(_date, 'yyyy');
		}
	  },
	  {
		key: 'yy',
		regex: '\\d{2}',
		apply: function(value) { value = +value; this.year = value < 69 ? value + 2000 : value + 1900; },
		formatter: function(date) {
		  var _date = new Date();
		  _date.setFullYear(Math.abs(date.getFullYear()));
		  return dateFilter(_date, 'yy');
		}
	  },
	  {
		key: 'y',
		regex: '\\d{1,4}',
		apply: function(value) { this.year = +value; },
		formatter: function(date) {
		  var _date = new Date();
		  _date.setFullYear(Math.abs(date.getFullYear()));
		  return dateFilter(_date, 'y');
		}
	  },
	  {
		key: 'M!',
		regex: '0?[1-9]|1[0-2]',
		apply: function(value) { this.month = value - 1; },
		formatter: function(date) {
		  var value = date.getMonth();
		  if (/^[0-9]$/.test(value)) {
			return dateFilter(date, 'MM');
		  }

		  return dateFilter(date, 'M');
		}
	  },
	  {
		key: 'MMMM',
		regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
		apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },
		formatter: function(date) { return dateFilter(date, 'MMMM'); }
	  },
	  {
		key: 'MMM',
		regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
		apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },
		formatter: function(date) { return dateFilter(date, 'MMM'); }
	  },
	  {
		key: 'MM',
		regex: '0[1-9]|1[0-2]',
		apply: function(value) { this.month = value - 1; },
		formatter: function(date) { return dateFilter(date, 'MM'); }
	  },
	  {
		key: 'M',
		regex: '[1-9]|1[0-2]',
		apply: function(value) { this.month = value - 1; },
		formatter: function(date) { return dateFilter(date, 'M'); }
	  },
	  {
		key: 'd!',
		regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
		apply: function(value) { this.date = +value; },
		formatter: function(date) {
		  var value = date.getDate();
		  if (/^[1-9]$/.test(value)) {
			return dateFilter(date, 'dd');
		  }

		  return dateFilter(date, 'd');
		}
	  },
	  {
		key: 'dd',
		regex: '[0-2][0-9]{1}|3[0-1]{1}',
		apply: function(value) { this.date = +value; },
		formatter: function(date) { return dateFilter(date, 'dd'); }
	  },
	  {
		key: 'd',
		regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
		apply: function(value) { this.date = +value; },
		formatter: function(date) { return dateFilter(date, 'd'); }
	  },
	  {
		key: 'EEEE',
		regex: $locale.DATETIME_FORMATS.DAY.join('|'),
		formatter: function(date) { return dateFilter(date, 'EEEE'); }
	  },
	  {
		key: 'EEE',
		regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
		formatter: function(date) { return dateFilter(date, 'EEE'); }
	  },
	  {
		key: 'HH',
		regex: '(?:0|1)[0-9]|2[0-3]',
		apply: function(value) { this.hours = +value; },
		formatter: function(date) { return dateFilter(date, 'HH'); }
	  },
	  {
		key: 'hh',
		regex: '0[0-9]|1[0-2]',
		apply: function(value) { this.hours = +value; },
		formatter: function(date) { return dateFilter(date, 'hh'); }
	  },
	  {
		key: 'H',
		regex: '1?[0-9]|2[0-3]',
		apply: function(value) { this.hours = +value; },
		formatter: function(date) { return dateFilter(date, 'H'); }
	  },
	  {
		key: 'h',
		regex: '[0-9]|1[0-2]',
		apply: function(value) { this.hours = +value; },
		formatter: function(date) { return dateFilter(date, 'h'); }
	  },
	  {
		key: 'mm',
		regex: '[0-5][0-9]',
		apply: function(value) { this.minutes = +value; },
		formatter: function(date) { return dateFilter(date, 'mm'); }
	  },
	  {
		key: 'm',
		regex: '[0-9]|[1-5][0-9]',
		apply: function(value) { this.minutes = +value; },
		formatter: function(date) { return dateFilter(date, 'm'); }
	  },
	  {
		key: 'sss',
		regex: '[0-9][0-9][0-9]',
		apply: function(value) { this.milliseconds = +value; },
		formatter: function(date) { return dateFilter(date, 'sss'); }
	  },
	  {
		key: 'ss',
		regex: '[0-5][0-9]',
		apply: function(value) { this.seconds = +value; },
		formatter: function(date) { return dateFilter(date, 'ss'); }
	  },
	  {
		key: 's',
		regex: '[0-9]|[1-5][0-9]',
		apply: function(value) { this.seconds = +value; },
		formatter: function(date) { return dateFilter(date, 's'); }
	  },
	  {
		key: 'a',
		regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
		apply: function(value) {
		  if (this.hours === 12) {
			this.hours = 0;
		  }

		  if (value === 'PM') {
			this.hours += 12;
		  }
		},
		formatter: function(date) { return dateFilter(date, 'a'); }
	  },
	  {
		key: 'Z',
		regex: '[+-]\\d{4}',
		apply: function(value) {
		  var matches = value.match(/([+-])(\d{2})(\d{2})/),
			sign = matches[1],
			hours = matches[2],
			minutes = matches[3];
		  this.hours += toInt(sign + hours);
		  this.minutes += toInt(sign + minutes);
		},
		formatter: function(date) {
		  return dateFilter(date, 'Z');
		}
	  },
	  {
		key: 'ww',
		regex: '[0-4][0-9]|5[0-3]',
		formatter: function(date) { return dateFilter(date, 'ww'); }
	  },
	  {
		key: 'w',
		regex: '[0-9]|[1-4][0-9]|5[0-3]',
		formatter: function(date) { return dateFilter(date, 'w'); }
	  },
	  {
		key: 'GGGG',
		regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
		formatter: function(date) { return dateFilter(date, 'GGGG'); }
	  },
	  {
		key: 'GGG',
		regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
		formatter: function(date) { return dateFilter(date, 'GGG'); }
	  },
	  {
		key: 'GG',
		regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
		formatter: function(date) { return dateFilter(date, 'GG'); }
	  },
	  {
		key: 'G',
		regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
		formatter: function(date) { return dateFilter(date, 'G'); }
	  }
	];
  };

  this.init();

  function createParser(format) {
	var map = [], regex = format.split('');

	// check for literal values
	var quoteIndex = format.indexOf('\'');
	if (quoteIndex > -1) {
	  var inLiteral = false;
	  format = format.split('');
	  for (var i = quoteIndex; i < format.length; i++) {
		if (inLiteral) {
		  if (format[i] === '\'') {
			if (i + 1 < format.length && format[i+1] === '\'') { // escaped single quote
			  format[i+1] = '$';
			  regex[i+1] = '';
			} else { // end of literal
			  regex[i] = '';
			  inLiteral = false;
			}
		  }
		  format[i] = '$';
		} else {
		  if (format[i] === '\'') { // start of literal
			format[i] = '$';
			regex[i] = '';
			inLiteral = true;
		  }
		}
	  }

	  format = format.join('');
	}

	angular.forEach(formatCodeToRegex, function(data) {
	  var index = format.indexOf(data.key);

	  if (index > -1) {
		format = format.split('');

		regex[index] = '(' + data.regex + ')';
		format[index] = '$'; // Custom symbol to define consumed part of format
		for (var i = index + 1, n = index + data.key.length; i < n; i++) {
		  regex[i] = '';
		  format[i] = '$';
		}
		format = format.join('');

		map.push({
		  index: index,
		  key: data.key,
		  apply: data.apply,
		  matcher: data.regex
		});
	  }
	});

	return {
	  regex: new RegExp('^' + regex.join('') + '$'),
	  map: orderByFilter(map, 'index')
	};
  }

  function createFormatter(format) {
	var formatters = [];
	var i = 0;
	var formatter, literalIdx;
	while (i < format.length) {
	  if (angular.isNumber(literalIdx)) {
		if (format.charAt(i) === '\'') {
		  if (i + 1 >= format.length || format.charAt(i + 1) !== '\'') {
			formatters.push(constructLiteralFormatter(format, literalIdx, i));
			literalIdx = null;
		  }
		} else if (i === format.length) {
		  while (literalIdx < format.length) {
			formatter = constructFormatterFromIdx(format, literalIdx);
			formatters.push(formatter);
			literalIdx = formatter.endIdx;
		  }
		}

		i++;
		continue;
	  }

	  if (format.charAt(i) === '\'') {
		literalIdx = i;
		i++;
		continue;
	  }

	  formatter = constructFormatterFromIdx(format, i);

	  formatters.push(formatter.parser);
	  i = formatter.endIdx;
	}

	return formatters;
  }

  function constructLiteralFormatter(format, literalIdx, endIdx) {
	return function() {
	  return format.substr(literalIdx + 1, endIdx - literalIdx - 1);
	};
  }

  function constructFormatterFromIdx(format, i) {
	var currentPosStr = format.substr(i);
	for (var j = 0; j < formatCodeToRegex.length; j++) {
	  if (new RegExp('^' + formatCodeToRegex[j].key).test(currentPosStr)) {
		var data = formatCodeToRegex[j];
		return {
		  endIdx: i + data.key.length,
		  parser: data.formatter
		};
	  }
	}

	return {
	  endIdx: i + 1,
	  parser: function() {
		return currentPosStr.charAt(0);
	  }
	};
  }

  this.filter = function(date, format) {
	if (!angular.isDate(date) || isNaN(date) || !format) {
	  return '';
	}

	format = $locale.DATETIME_FORMATS[format] || format;

	if ($locale.id !== localeId) {
	  this.init();
	}

	if (!this.formatters[format]) {
	  this.formatters[format] = createFormatter(format);
	}

	var formatters = this.formatters[format];

	return formatters.reduce(function(str, formatter) {
	  return str + formatter(date);
	}, '');
  };

  this.parse = function(input, format, baseDate) {
	if (!angular.isString(input) || !format) {
	  return input;
	}

	format = $locale.DATETIME_FORMATS[format] || format;
	format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');

	if ($locale.id !== localeId) {
	  this.init();
	}

	if (!this.parsers[format]) {
	  this.parsers[format] = createParser(format, 'apply');
	}

	var parser = this.parsers[format],
		regex = parser.regex,
		map = parser.map,
		results = input.match(regex),
		tzOffset = false;
	if (results && results.length) {
	  var fields, dt;
	  if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
		fields = {
		  year: baseDate.getFullYear(),
		  month: baseDate.getMonth(),
		  date: baseDate.getDate(),
		  hours: baseDate.getHours(),
		  minutes: baseDate.getMinutes(),
		  seconds: baseDate.getSeconds(),
		  milliseconds: baseDate.getMilliseconds()
		};
	  } else {
		if (baseDate) {
		  $log.warn('dateparser:', 'baseDate is not a valid date');
		}
		fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
	  }

	  for (var i = 1, n = results.length; i < n; i++) {
		var mapper = map[i - 1];
		if (mapper.matcher === 'Z') {
		  tzOffset = true;
		}

		if (mapper.apply) {
		  mapper.apply.call(fields, results[i]);
		}
	  }

	  var datesetter = tzOffset ? Date.prototype.setUTCFullYear :
		Date.prototype.setFullYear;
	  var timesetter = tzOffset ? Date.prototype.setUTCHours :
		Date.prototype.setHours;

	  if (isValid(fields.year, fields.month, fields.date)) {
		if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
		  dt = new Date(baseDate);
		  datesetter.call(dt, fields.year, fields.month, fields.date);
		  timesetter.call(dt, fields.hours, fields.minutes,
			fields.seconds, fields.milliseconds);
		} else {
		  dt = new Date(0);
		  datesetter.call(dt, fields.year, fields.month, fields.date);
		  timesetter.call(dt, fields.hours || 0, fields.minutes || 0,
			fields.seconds || 0, fields.milliseconds || 0);
		}
	  }

	  return dt;
	}
  };

  // Check if date is valid for specific month (and year for February).
  // Month: 0 = Jan, 1 = Feb, etc
  function isValid(year, month, date) {
	if (date < 1) {
	  return false;
	}

	if (month === 1 && date > 28) {
	  return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
	}

	if (month === 3 || month === 5 || month === 8 || month === 10) {
	  return date < 31;
	}

	return true;
  }

  function toInt(str) {
	return parseInt(str, 10);
  }

  this.toTimezone = toTimezone;
  this.fromTimezone = fromTimezone;
  this.timezoneToOffset = timezoneToOffset;
  this.addDateMinutes = addDateMinutes;
  this.convertTimezoneToLocal = convertTimezoneToLocal;

  function toTimezone(date, timezone) {
	return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
  }

  function fromTimezone(date, timezone) {
	return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
  }

  //https://github.com/angular/angular.js/blob/622c42169699ec07fc6daaa19fe6d224e5d2f70e/src/Angular.js#L1207
  function timezoneToOffset(timezone, fallback) {
	timezone = timezone.replace(/:/g, '');
	var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
	return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
  }

  function addDateMinutes(date, minutes) {
	date = new Date(date.getTime());
	date.setMinutes(date.getMinutes() + minutes);
	return date;
  }

  function convertTimezoneToLocal(date, timezone, reverse) {
	reverse = reverse ? -1 : 1;
	var dateTimezoneOffset = date.getTimezoneOffset();
	var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
	return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
  }
}]);

// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to
// at most one element.
angular.module('ui.bootstrap.isClass', [])
.directive('uibIsClass', [
		 '$animate',
function ($animate) {
  //                    11111111          22222222
  var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
  //                    11111111           22222222
  var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;

  var dataPerTracked = {};

  return {
	restrict: 'A',
	compile: function(tElement, tAttrs) {
	  var linkedScopes = [];
	  var instances = [];
	  var expToData = {};
	  var lastActivated = null;
	  var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
	  var onExp = onExpMatches[2];
	  var expsStr = onExpMatches[1];
	  var exps = expsStr.split(',');

	  return linkFn;

	  function linkFn(scope, element, attrs) {
		linkedScopes.push(scope);
		instances.push({
		  scope: scope,
		  element: element
		});

		exps.forEach(function(exp, k) {
		  addForExp(exp, scope);
		});

		scope.$on('$destroy', removeScope);
	  }

	  function addForExp(exp, scope) {
		var matches = exp.match(IS_REGEXP);
		var clazz = scope.$eval(matches[1]);
		var compareWithExp = matches[2];
		var data = expToData[exp];
		if (!data) {
		  var watchFn = function(compareWithVal) {
			var newActivated = null;
			instances.some(function(instance) {
			  var thisVal = instance.scope.$eval(onExp);
			  if (thisVal === compareWithVal) {
				newActivated = instance;
				return true;
			  }
			});
			if (data.lastActivated !== newActivated) {
			  if (data.lastActivated) {
				$animate.removeClass(data.lastActivated.element, clazz);
			  }
			  if (newActivated) {
				$animate.addClass(newActivated.element, clazz);
			  }
			  data.lastActivated = newActivated;
			}
		  };
		  expToData[exp] = data = {
			lastActivated: null,
			scope: scope,
			watchFn: watchFn,
			compareWithExp: compareWithExp,
			watcher: scope.$watch(compareWithExp, watchFn)
		  };
		}
		data.watchFn(scope.$eval(compareWithExp));
	  }

	  function removeScope(e) {
		var removedScope = e.targetScope;
		var index = linkedScopes.indexOf(removedScope);
		linkedScopes.splice(index, 1);
		instances.splice(index, 1);
		if (linkedScopes.length) {
		  var newWatchScope = linkedScopes[0];
		  angular.forEach(expToData, function(data) {
			if (data.scope === removedScope) {
			  data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
			  data.scope = newWatchScope;
			}
		  });
		} else {
		  expToData = {};
		}
	  }
	}
  };
}]);
angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass'])

.value('$datepickerSuppressError', false)

.value('$datepickerLiteralWarning', true)

.constant('uibDatepickerConfig', {
  datepickerMode: 'day',
  formatDay: 'dd',
  formatMonth: 'MMMM',
  formatYear: 'yyyy',
  formatDayHeader: 'EEE',
  formatDayTitle: 'MMMM yyyy',
  formatMonthTitle: 'yyyy',
  maxDate: null,
  maxMode: 'year',
  minDate: null,
  minMode: 'day',
  monthColumns: 3,
  ngModelOptions: {},
  shortcutPropagation: false,
  showWeeks: true,
  yearColumns: 5,
  yearRows: 4
})

.controller('UibDatepickerController', ['$scope', '$element', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser',
  function($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
  var self = this,
	  ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;
	  ngModelOptions = {},
	  watchListeners = [];

  $element.addClass('uib-datepicker');
  $attrs.$set('role', 'application');

  if (!$scope.datepickerOptions) {
	$scope.datepickerOptions = {};
  }

  // Modes chain
  this.modes = ['day', 'month', 'year'];

  [
	'customClass',
	'dateDisabled',
	'datepickerMode',
	'formatDay',
	'formatDayHeader',
	'formatDayTitle',
	'formatMonth',
	'formatMonthTitle',
	'formatYear',
	'maxDate',
	'maxMode',
	'minDate',
	'minMode',
	'monthColumns',
	'showWeeks',
	'shortcutPropagation',
	'startingDay',
	'yearColumns',
	'yearRows'
  ].forEach(function(key) {
	switch (key) {
	  case 'customClass':
	  case 'dateDisabled':
		$scope[key] = $scope.datepickerOptions[key] || angular.noop;
		break;
	  case 'datepickerMode':
		$scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?
		  $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
		break;
	  case 'formatDay':
	  case 'formatDayHeader':
	  case 'formatDayTitle':
	  case 'formatMonth':
	  case 'formatMonthTitle':
	  case 'formatYear':
		self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
		  $interpolate($scope.datepickerOptions[key])($scope.$parent) :
		  datepickerConfig[key];
		break;
	  case 'monthColumns':
	  case 'showWeeks':
	  case 'shortcutPropagation':
	  case 'yearColumns':
	  case 'yearRows':
		self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
		  $scope.datepickerOptions[key] : datepickerConfig[key];
		break;
	  case 'startingDay':
		if (angular.isDefined($scope.datepickerOptions.startingDay)) {
		  self.startingDay = $scope.datepickerOptions.startingDay;
		} else if (angular.isNumber(datepickerConfig.startingDay)) {
		  self.startingDay = datepickerConfig.startingDay;
		} else {
		  self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
		}

		break;
	  case 'maxDate':
	  case 'minDate':
		$scope.$watch('datepickerOptions.' + key, function(value) {
		  if (value) {
			if (angular.isDate(value)) {
			  self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
			} else {
			  if ($datepickerLiteralWarning) {
				$log.warn('Literal date support has been deprecated, please switch to date object usage');
			  }

			  self[key] = new Date(dateFilter(value, 'medium'));
			}
		  } else {
			self[key] = datepickerConfig[key] ?
			  dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) :
			  null;
		  }

		  self.refreshView();
		});

		break;
	  case 'maxMode':
	  case 'minMode':
		if ($scope.datepickerOptions[key]) {
		  $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {
			self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];
			if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||
			  key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {
			  $scope.datepickerMode = self[key];
			  $scope.datepickerOptions.datepickerMode = self[key];
			}
		  });
		} else {
		  self[key] = $scope[key] = datepickerConfig[key] || null;
		}

		break;
	}
  });

  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

  $scope.disabled = angular.isDefined($attrs.disabled) || false;
  if (angular.isDefined($attrs.ngDisabled)) {
	watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {
	  $scope.disabled = disabled;
	  self.refreshView();
	}));
  }

  $scope.isActive = function(dateObject) {
	if (self.compare(dateObject.date, self.activeDate) === 0) {
	  $scope.activeDateId = dateObject.uid;
	  return true;
	}
	return false;
  };

  this.init = function(ngModelCtrl_) {
	ngModelCtrl = ngModelCtrl_;
	ngModelOptions = ngModelCtrl_.$options ||
	  $scope.datepickerOptions.ngModelOptions ||
	  datepickerConfig.ngModelOptions;
	if ($scope.datepickerOptions.initDate) {
	  self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();
	  $scope.$watch('datepickerOptions.initDate', function(initDate) {
		if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
		  self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
		  self.refreshView();
		}
	  });
	} else {
	  self.activeDate = new Date();
	}

	var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
	this.activeDate = !isNaN(date) ?
	  dateParser.fromTimezone(date, ngModelOptions.timezone) :
	  dateParser.fromTimezone(new Date(), ngModelOptions.timezone);

	ngModelCtrl.$render = function() {
	  self.render();
	};
  };

  this.render = function() {
	if (ngModelCtrl.$viewValue) {
	  var date = new Date(ngModelCtrl.$viewValue),
		  isValid = !isNaN(date);

	  if (isValid) {
		this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);
	  } else if (!$datepickerSuppressError) {
		$log.error('Datepicker directive: "ng-model" value must be a Date object');
	  }
	}
	this.refreshView();
  };

  this.refreshView = function() {
	if (this.element) {
	  $scope.selectedDt = null;
	  this._refreshView();
	  if ($scope.activeDt) {
		$scope.activeDateId = $scope.activeDt.uid;
	  }

	  var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
	  date = dateParser.fromTimezone(date, ngModelOptions.timezone);
	  ngModelCtrl.$setValidity('dateDisabled', !date ||
		this.element && !this.isDisabled(date));
	}
  };

  this.createDateObject = function(date, format) {
	var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
	model = dateParser.fromTimezone(model, ngModelOptions.timezone);
	var today = new Date();
	today = dateParser.fromTimezone(today, ngModelOptions.timezone);
	var time = this.compare(date, today);
	var dt = {
	  date: date,
	  label: dateParser.filter(date, format),
	  selected: model && this.compare(date, model) === 0,
	  disabled: this.isDisabled(date),
	  past: time < 0,
	  current: time === 0,
	  future: time > 0,
	  customClass: this.customClass(date) || null
	};

	if (model && this.compare(date, model) === 0) {
	  $scope.selectedDt = dt;
	}

	if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
	  $scope.activeDt = dt;
	}

	return dt;
  };

  this.isDisabled = function(date) {
	return $scope.disabled ||
	  this.minDate && this.compare(date, this.minDate) < 0 ||
	  this.maxDate && this.compare(date, this.maxDate) > 0 ||
	  $scope.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode});
  };

  this.customClass = function(date) {
	return $scope.customClass({date: date, mode: $scope.datepickerMode});
  };

  // Split array into smaller arrays
  this.split = function(arr, size) {
	var arrays = [];
	while (arr.length > 0) {
	  arrays.push(arr.splice(0, size));
	}
	return arrays;
  };

  $scope.select = function(date) {
	if ($scope.datepickerMode === self.minMode) {
	  var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);
	  dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	  dt = dateParser.toTimezone(dt, ngModelOptions.timezone);
	  ngModelCtrl.$setViewValue(dt);
	  ngModelCtrl.$render();
	} else {
	  self.activeDate = date;
	  setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);

	  $scope.$emit('uib:datepicker.mode');
	}

	$scope.$broadcast('uib:datepicker.focus');
  };

  $scope.move = function(direction) {
	var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
		month = self.activeDate.getMonth() + direction * (self.step.months || 0);
	self.activeDate.setFullYear(year, month, 1);
	self.refreshView();
  };

  $scope.toggleMode = function(direction) {
	direction = direction || 1;

	if ($scope.datepickerMode === self.maxMode && direction === 1 ||
	  $scope.datepickerMode === self.minMode && direction === -1) {
	  return;
	}

	setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);

	$scope.$emit('uib:datepicker.mode');
  };

  // Key event mapper
  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

  var focusElement = function() {
	self.element[0].focus();
  };

  // Listen for focus requests from popup directive
  $scope.$on('uib:datepicker.focus', focusElement);

  $scope.keydown = function(evt) {
	var key = $scope.keys[evt.which];

	if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
	  return;
	}

	evt.preventDefault();
	if (!self.shortcutPropagation) {
	  evt.stopPropagation();
	}

	if (key === 'enter' || key === 'space') {
	  if (self.isDisabled(self.activeDate)) {
		return; // do nothing
	  }
	  $scope.select(self.activeDate);
	} else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
	  $scope.toggleMode(key === 'up' ? 1 : -1);
	} else {
	  self.handleKeyDown(key, evt);
	  self.refreshView();
	}
  };

  $element.on('keydown', function(evt) {
	$scope.$apply(function() {
	  $scope.keydown(evt);
	});
  });

  $scope.$on('$destroy', function() {
	//Clear all watch listeners on destroy
	while (watchListeners.length) {
	  watchListeners.shift()();
	}
  });

  function setMode(mode) {
	$scope.datepickerMode = mode;
	$scope.datepickerOptions.datepickerMode = mode;
  }
}])

.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  this.step = { months: 1 };
  this.element = $element;
  function getDaysInMonth(year, month) {
	return month === 1 && year % 4 === 0 &&
	  (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
  }

  this.init = function(ctrl) {
	angular.extend(ctrl, this);
	scope.showWeeks = ctrl.showWeeks;
	ctrl.refreshView();
  };

  this.getDates = function(startDate, n) {
	var dates = new Array(n), current = new Date(startDate), i = 0, date;
	while (i < n) {
	  date = new Date(current);
	  dates[i++] = date;
	  current.setDate(current.getDate() + 1);
	}
	return dates;
  };

  this._refreshView = function() {
	var year = this.activeDate.getFullYear(),
	  month = this.activeDate.getMonth(),
	  firstDayOfMonth = new Date(this.activeDate);

	firstDayOfMonth.setFullYear(year, month, 1);

	var difference = this.startingDay - firstDayOfMonth.getDay(),
	  numDisplayedFromPreviousMonth = difference > 0 ?
		7 - difference : - difference,
	  firstDate = new Date(firstDayOfMonth);

	if (numDisplayedFromPreviousMonth > 0) {
	  firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
	}

	// 42 is the number of days on a six-week calendar
	var days = this.getDates(firstDate, 42);
	for (var i = 0; i < 42; i ++) {
	  days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
		secondary: days[i].getMonth() !== month,
		uid: scope.uniqueId + '-' + i
	  });
	}

	scope.labels = new Array(7);
	for (var j = 0; j < 7; j++) {
	  scope.labels[j] = {
		abbr: dateFilter(days[j].date, this.formatDayHeader),
		full: dateFilter(days[j].date, 'EEEE')
	  };
	}

	scope.title = dateFilter(this.activeDate, this.formatDayTitle);
	scope.rows = this.split(days, 7);

	if (scope.showWeeks) {
	  scope.weekNumbers = [];
	  var thursdayIndex = (4 + 7 - this.startingDay) % 7,
		  numWeeks = scope.rows.length;
	  for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
		scope.weekNumbers.push(
		  getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
	  }
	}
  };

  this.compare = function(date1, date2) {
	var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
	var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
	_date1.setFullYear(date1.getFullYear());
	_date2.setFullYear(date2.getFullYear());
	return _date1 - _date2;
  };

  function getISO8601WeekNumber(date) {
	var checkDate = new Date(date);
	checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
	var time = checkDate.getTime();
	checkDate.setMonth(0); // Compare with Jan 1
	checkDate.setDate(1);
	return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
  }

  this.handleKeyDown = function(key, evt) {
	var date = this.activeDate.getDate();

	if (key === 'left') {
	  date = date - 1;
	} else if (key === 'up') {
	  date = date - 7;
	} else if (key === 'right') {
	  date = date + 1;
	} else if (key === 'down') {
	  date = date + 7;
	} else if (key === 'pageup' || key === 'pagedown') {
	  var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
	  this.activeDate.setMonth(month, 1);
	  date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
	} else if (key === 'home') {
	  date = 1;
	} else if (key === 'end') {
	  date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
	}
	this.activeDate.setDate(date);
  };
}])

.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  this.step = { years: 1 };
  this.element = $element;

  this.init = function(ctrl) {
	angular.extend(ctrl, this);
	ctrl.refreshView();
  };

  this._refreshView = function() {
	var months = new Array(12),
		year = this.activeDate.getFullYear(),
		date;

	for (var i = 0; i < 12; i++) {
	  date = new Date(this.activeDate);
	  date.setFullYear(year, i, 1);
	  months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
		uid: scope.uniqueId + '-' + i
	  });
	}

	scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
	scope.rows = this.split(months, this.monthColumns);
	scope.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1;
  };

  this.compare = function(date1, date2) {
	var _date1 = new Date(date1.getFullYear(), date1.getMonth());
	var _date2 = new Date(date2.getFullYear(), date2.getMonth());
	_date1.setFullYear(date1.getFullYear());
	_date2.setFullYear(date2.getFullYear());
	return _date1 - _date2;
  };

  this.handleKeyDown = function(key, evt) {
	var date = this.activeDate.getMonth();

	if (key === 'left') {
	  date = date - 1;
	} else if (key === 'up') {
	  date = date - this.monthColumns;
	} else if (key === 'right') {
	  date = date + 1;
	} else if (key === 'down') {
	  date = date + this.monthColumns;
	} else if (key === 'pageup' || key === 'pagedown') {
	  var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
	  this.activeDate.setFullYear(year);
	} else if (key === 'home') {
	  date = 0;
	} else if (key === 'end') {
	  date = 11;
	}
	this.activeDate.setMonth(date);
  };
}])

.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  var columns, range;
  this.element = $element;

  function getStartingYear(year) {
	return parseInt((year - 1) / range, 10) * range + 1;
  }

  this.yearpickerInit = function() {
	columns = this.yearColumns;
	range = this.yearRows * columns;
	this.step = { years: range };
  };

  this._refreshView = function() {
	var years = new Array(range), date;

	for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
	  date = new Date(this.activeDate);
	  date.setFullYear(start + i, 0, 1);
	  years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
		uid: scope.uniqueId + '-' + i
	  });
	}

	scope.title = [years[0].label, years[range - 1].label].join(' - ');
	scope.rows = this.split(years, columns);
	scope.columns = columns;
  };

  this.compare = function(date1, date2) {
	return date1.getFullYear() - date2.getFullYear();
  };

  this.handleKeyDown = function(key, evt) {
	var date = this.activeDate.getFullYear();

	if (key === 'left') {
	  date = date - 1;
	} else if (key === 'up') {
	  date = date - columns;
	} else if (key === 'right') {
	  date = date + 1;
	} else if (key === 'down') {
	  date = date + columns;
	} else if (key === 'pageup' || key === 'pagedown') {
	  date += (key === 'pageup' ? - 1 : 1) * range;
	} else if (key === 'home') {
	  date = getStartingYear(this.activeDate.getFullYear());
	} else if (key === 'end') {
	  date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
	}
	this.activeDate.setFullYear(date);
  };
}])

.directive('uibDatepicker', function() {
  return {
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
	},
	scope: {
	  datepickerOptions: '=?'
	},
	require: ['uibDatepicker', '^ngModel'],
	restrict: 'A',
	controller: 'UibDatepickerController',
	controllerAs: 'datepicker',
	link: function(scope, element, attrs, ctrls) {
	  var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

	  datepickerCtrl.init(ngModelCtrl);
	}
  };
})

.directive('uibDaypicker', function() {
  return {
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || 'uib/template/datepicker/day.html';
	},
	require: ['^uibDatepicker', 'uibDaypicker'],
	restrict: 'A',
	controller: 'UibDaypickerController',
	link: function(scope, element, attrs, ctrls) {
	  var datepickerCtrl = ctrls[0],
		daypickerCtrl = ctrls[1];

	  daypickerCtrl.init(datepickerCtrl);
	}
  };
})

.directive('uibMonthpicker', function() {
  return {
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || 'uib/template/datepicker/month.html';
	},
	require: ['^uibDatepicker', 'uibMonthpicker'],
	restrict: 'A',
	controller: 'UibMonthpickerController',
	link: function(scope, element, attrs, ctrls) {
	  var datepickerCtrl = ctrls[0],
		monthpickerCtrl = ctrls[1];

	  monthpickerCtrl.init(datepickerCtrl);
	}
  };
})

.directive('uibYearpicker', function() {
  return {
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || 'uib/template/datepicker/year.html';
	},
	require: ['^uibDatepicker', 'uibYearpicker'],
	restrict: 'A',
	controller: 'UibYearpickerController',
	link: function(scope, element, attrs, ctrls) {
	  var ctrl = ctrls[0];
	  angular.extend(ctrl, ctrls[1]);
	  ctrl.yearpickerInit();

	  ctrl.refreshView();
	}
  };
});

angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods for working with the DOM.
 * It is meant to be used where we need to absolute-position elements in
 * relation to another element (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$uibPosition', ['$document', '$window', function($document, $window) {
	/**
	 * Used by scrollbarWidth() function to cache scrollbar's width.
	 * Do not access this variable directly, use scrollbarWidth() instead.
	 */
	var SCROLLBAR_WIDTH;
	/**
	 * scrollbar on body and html element in IE and Edge overlay
	 * content and should be considered 0 width.
	 */
	var BODY_SCROLLBAR_WIDTH;
	var OVERFLOW_REGEX = {
	  normal: /(auto|scroll)/,
	  hidden: /(auto|scroll|hidden)/
	};
	var PLACEMENT_REGEX = {
	  auto: /\s?auto?\s?/i,
	  primary: /^(top|bottom|left|right)$/,
	  secondary: /^(top|bottom|left|right|center)$/,
	  vertical: /^(top|bottom)$/
	};
	var BODY_REGEX = /(HTML|BODY)/;

	return {

	  /**
	   * Provides a raw DOM element from a jQuery/jQLite element.
	   *
	   * @param {element} elem - The element to convert.
	   *
	   * @returns {element} A HTML element.
	   */
	  getRawNode: function(elem) {
		return elem.nodeName ? elem : elem[0] || elem;
	  },

	  /**
	   * Provides a parsed number for a style property.  Strips
	   * units and casts invalid numbers to 0.
	   *
	   * @param {string} value - The style value to parse.
	   *
	   * @returns {number} A valid number.
	   */
	  parseStyle: function(value) {
		value = parseFloat(value);
		return isFinite(value) ? value : 0;
	  },

	  /**
	   * Provides the closest positioned ancestor.
	   *
	   * @param {element} element - The element to get the offest parent for.
	   *
	   * @returns {element} The closest positioned ancestor.
	   */
	  offsetParent: function(elem) {
		elem = this.getRawNode(elem);

		var offsetParent = elem.offsetParent || $document[0].documentElement;

		function isStaticPositioned(el) {
		  return ($window.getComputedStyle(el).position || 'static') === 'static';
		}

		while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
		  offsetParent = offsetParent.offsetParent;
		}

		return offsetParent || $document[0].documentElement;
	  },

	  /**
	   * Provides the scrollbar width, concept from TWBS measureScrollbar()
	   * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js
	   * In IE and Edge, scollbar on body and html element overlay and should
	   * return a width of 0.
	   *
	   * @returns {number} The width of the browser scollbar.
	   */
	  scrollbarWidth: function(isBody) {
		if (isBody) {
		  if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
			var bodyElem = $document.find('body');
			bodyElem.addClass('uib-position-body-scrollbar-measure');
			BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
			BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;
			bodyElem.removeClass('uib-position-body-scrollbar-measure');
		  }
		  return BODY_SCROLLBAR_WIDTH;
		}

		if (angular.isUndefined(SCROLLBAR_WIDTH)) {
		  var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
		  $document.find('body').append(scrollElem);
		  SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
		  SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
		  scrollElem.remove();
		}

		return SCROLLBAR_WIDTH;
	  },

	  /**
	   * Provides the padding required on an element to replace the scrollbar.
	   *
	   * @returns {object} An object with the following properties:
	   *   <ul>
	   *     <li>**scrollbarWidth**: the width of the scrollbar</li>
	   *     <li>**widthOverflow**: whether the the width is overflowing</li>
	   *     <li>**right**: the amount of right padding on the element needed to replace the scrollbar</li>
	   *     <li>**rightOriginal**: the amount of right padding currently on the element</li>
	   *     <li>**heightOverflow**: whether the the height is overflowing</li>
	   *     <li>**bottom**: the amount of bottom padding on the element needed to replace the scrollbar</li>
	   *     <li>**bottomOriginal**: the amount of bottom padding currently on the element</li>
	   *   </ul>
	   */
	  scrollbarPadding: function(elem) {
		elem = this.getRawNode(elem);

		var elemStyle = $window.getComputedStyle(elem);
		var paddingRight = this.parseStyle(elemStyle.paddingRight);
		var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
		var scrollParent = this.scrollParent(elem, false, true);
		var scrollbarWidth = this.scrollbarWidth(scrollParent, BODY_REGEX.test(scrollParent.tagName));

		return {
		  scrollbarWidth: scrollbarWidth,
		  widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
		  right: paddingRight + scrollbarWidth,
		  originalRight: paddingRight,
		  heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
		  bottom: paddingBottom + scrollbarWidth,
		  originalBottom: paddingBottom
		 };
	  },

	  /**
	   * Checks to see if the element is scrollable.
	   *
	   * @param {element} elem - The element to check.
	   * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
	   *   default is false.
	   *
	   * @returns {boolean} Whether the element is scrollable.
	   */
	  isScrollable: function(elem, includeHidden) {
		elem = this.getRawNode(elem);

		var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
		var elemStyle = $window.getComputedStyle(elem);
		return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
	  },

	  /**
	   * Provides the closest scrollable ancestor.
	   * A port of the jQuery UI scrollParent method:
	   * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js
	   *
	   * @param {element} elem - The element to find the scroll parent of.
	   * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
	   *   default is false.
	   * @param {boolean=} [includeSelf=false] - Should the element being passed be
	   * included in the scrollable llokup.
	   *
	   * @returns {element} A HTML element.
	   */
	  scrollParent: function(elem, includeHidden, includeSelf) {
		elem = this.getRawNode(elem);

		var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
		var documentEl = $document[0].documentElement;
		var elemStyle = $window.getComputedStyle(elem);
		if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {
		  return elem;
		}
		var excludeStatic = elemStyle.position === 'absolute';
		var scrollParent = elem.parentElement || documentEl;

		if (scrollParent === documentEl || elemStyle.position === 'fixed') {
		  return documentEl;
		}

		while (scrollParent.parentElement && scrollParent !== documentEl) {
		  var spStyle = $window.getComputedStyle(scrollParent);
		  if (excludeStatic && spStyle.position !== 'static') {
			excludeStatic = false;
		  }

		  if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
			break;
		  }
		  scrollParent = scrollParent.parentElement;
		}

		return scrollParent;
	  },

	  /**
	   * Provides read-only equivalent of jQuery's position function:
	   * http://api.jquery.com/position/ - distance to closest positioned
	   * ancestor.  Does not account for margins by default like jQuery position.
	   *
	   * @param {element} elem - The element to caclulate the position on.
	   * @param {boolean=} [includeMargins=false] - Should margins be accounted
	   * for, default is false.
	   *
	   * @returns {object} An object with the following properties:
	   *   <ul>
	   *     <li>**width**: the width of the element</li>
	   *     <li>**height**: the height of the element</li>
	   *     <li>**top**: distance to top edge of offset parent</li>
	   *     <li>**left**: distance to left edge of offset parent</li>
	   *   </ul>
	   */
	  position: function(elem, includeMagins) {
		elem = this.getRawNode(elem);

		var elemOffset = this.offset(elem);
		if (includeMagins) {
		  var elemStyle = $window.getComputedStyle(elem);
		  elemOffset.top -= this.parseStyle(elemStyle.marginTop);
		  elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
		}
		var parent = this.offsetParent(elem);
		var parentOffset = {top: 0, left: 0};

		if (parent !== $document[0].documentElement) {
		  parentOffset = this.offset(parent);
		  parentOffset.top += parent.clientTop - parent.scrollTop;
		  parentOffset.left += parent.clientLeft - parent.scrollLeft;
		}

		return {
		  width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
		  height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
		  top: Math.round(elemOffset.top - parentOffset.top),
		  left: Math.round(elemOffset.left - parentOffset.left)
		};
	  },

	  /**
	   * Provides read-only equivalent of jQuery's offset function:
	   * http://api.jquery.com/offset/ - distance to viewport.  Does
	   * not account for borders, margins, or padding on the body
	   * element.
	   *
	   * @param {element} elem - The element to calculate the offset on.
	   *
	   * @returns {object} An object with the following properties:
	   *   <ul>
	   *     <li>**width**: the width of the element</li>
	   *     <li>**height**: the height of the element</li>
	   *     <li>**top**: distance to top edge of viewport</li>
	   *     <li>**right**: distance to bottom edge of viewport</li>
	   *   </ul>
	   */
	  offset: function(elem) {
		elem = this.getRawNode(elem);

		var elemBCR = elem.getBoundingClientRect();
		return {
		  width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
		  height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
		  top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
		  left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
		};
	  },

	  /**
	   * Provides offset distance to the closest scrollable ancestor
	   * or viewport.  Accounts for border and scrollbar width.
	   *
	   * Right and bottom dimensions represent the distance to the
	   * respective edge of the viewport element.  If the element
	   * edge extends beyond the viewport, a negative value will be
	   * reported.
	   *
	   * @param {element} elem - The element to get the viewport offset for.
	   * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead
	   * of the first scrollable element, default is false.
	   * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element
	   * be accounted for, default is true.
	   *
	   * @returns {object} An object with the following properties:
	   *   <ul>
	   *     <li>**top**: distance to the top content edge of viewport element</li>
	   *     <li>**bottom**: distance to the bottom content edge of viewport element</li>
	   *     <li>**left**: distance to the left content edge of viewport element</li>
	   *     <li>**right**: distance to the right content edge of viewport element</li>
	   *   </ul>
	   */
	  viewportOffset: function(elem, useDocument, includePadding) {
		elem = this.getRawNode(elem);
		includePadding = includePadding !== false ? true : false;

		var elemBCR = elem.getBoundingClientRect();
		var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};

		var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
		var offsetParentBCR = offsetParent.getBoundingClientRect();

		offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
		offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
		if (offsetParent === $document[0].documentElement) {
		  offsetBCR.top += $window.pageYOffset;
		  offsetBCR.left += $window.pageXOffset;
		}
		offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
		offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;

		if (includePadding) {
		  var offsetParentStyle = $window.getComputedStyle(offsetParent);
		  offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
		  offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
		  offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
		  offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
		}

		return {
		  top: Math.round(elemBCR.top - offsetBCR.top),
		  bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
		  left: Math.round(elemBCR.left - offsetBCR.left),
		  right: Math.round(offsetBCR.right - elemBCR.right)
		};
	  },

	  /**
	   * Provides an array of placement values parsed from a placement string.
	   * Along with the 'auto' indicator, supported placement strings are:
	   *   <ul>
	   *     <li>top: element on top, horizontally centered on host element.</li>
	   *     <li>top-left: element on top, left edge aligned with host element left edge.</li>
	   *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>
	   *     <li>bottom: element on bottom, horizontally centered on host element.</li>
	   *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>
	   *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>
	   *     <li>left: element on left, vertically centered on host element.</li>
	   *     <li>left-top: element on left, top edge aligned with host element top edge.</li>
	   *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>
	   *     <li>right: element on right, vertically centered on host element.</li>
	   *     <li>right-top: element on right, top edge aligned with host element top edge.</li>
	   *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>
	   *   </ul>
	   * A placement string with an 'auto' indicator is expected to be
	   * space separated from the placement, i.e: 'auto bottom-left'  If
	   * the primary and secondary placement values do not match 'top,
	   * bottom, left, right' then 'top' will be the primary placement and
	   * 'center' will be the secondary placement.  If 'auto' is passed, true
	   * will be returned as the 3rd value of the array.
	   *
	   * @param {string} placement - The placement string to parse.
	   *
	   * @returns {array} An array with the following values
	   * <ul>
	   *   <li>**[0]**: The primary placement.</li>
	   *   <li>**[1]**: The secondary placement.</li>
	   *   <li>**[2]**: If auto is passed: true, else undefined.</li>
	   * </ul>
	   */
	  parsePlacement: function(placement) {
		var autoPlace = PLACEMENT_REGEX.auto.test(placement);
		if (autoPlace) {
		  placement = placement.replace(PLACEMENT_REGEX.auto, '');
		}

		placement = placement.split('-');

		placement[0] = placement[0] || 'top';
		if (!PLACEMENT_REGEX.primary.test(placement[0])) {
		  placement[0] = 'top';
		}

		placement[1] = placement[1] || 'center';
		if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
		  placement[1] = 'center';
		}

		if (autoPlace) {
		  placement[2] = true;
		} else {
		  placement[2] = false;
		}

		return placement;
	  },

	  /**
	   * Provides coordinates for an element to be positioned relative to
	   * another element.  Passing 'auto' as part of the placement parameter
	   * will enable smart placement - where the element fits. i.e:
	   * 'auto left-top' will check to see if there is enough space to the left
	   * of the hostElem to fit the targetElem, if not place right (same for secondary
	   * top placement).  Available space is calculated using the viewportOffset
	   * function.
	   *
	   * @param {element} hostElem - The element to position against.
	   * @param {element} targetElem - The element to position.
	   * @param {string=} [placement=top] - The placement for the targetElem,
	   *   default is 'top'. 'center' is assumed as secondary placement for
	   *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:
	   *   <ul>
	   *     <li>top</li>
	   *     <li>top-right</li>
	   *     <li>top-left</li>
	   *     <li>bottom</li>
	   *     <li>bottom-left</li>
	   *     <li>bottom-right</li>
	   *     <li>left</li>
	   *     <li>left-top</li>
	   *     <li>left-bottom</li>
	   *     <li>right</li>
	   *     <li>right-top</li>
	   *     <li>right-bottom</li>
	   *   </ul>
	   * @param {boolean=} [appendToBody=false] - Should the top and left values returned
	   *   be calculated from the body element, default is false.
	   *
	   * @returns {object} An object with the following properties:
	   *   <ul>
	   *     <li>**top**: Value for targetElem top.</li>
	   *     <li>**left**: Value for targetElem left.</li>
	   *     <li>**placement**: The resolved placement.</li>
	   *   </ul>
	   */
	  positionElements: function(hostElem, targetElem, placement, appendToBody) {
		hostElem = this.getRawNode(hostElem);
		targetElem = this.getRawNode(targetElem);

		// need to read from prop to support tests.
		var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
		var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');

		placement = this.parsePlacement(placement);

		var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
		var targetElemPos = {top: 0, left: 0, placement: ''};

		if (placement[2]) {
		  var viewportOffset = this.viewportOffset(hostElem, appendToBody);

		  var targetElemStyle = $window.getComputedStyle(targetElem);
		  var adjustedSize = {
			width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
			height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
		  };

		  placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :
						 placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :
						 placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :
						 placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :
						 placement[0];

		  placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :
						 placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :
						 placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :
						 placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :
						 placement[1];

		  if (placement[1] === 'center') {
			if (PLACEMENT_REGEX.vertical.test(placement[0])) {
			  var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
			  if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
				placement[1] = 'left';
			  } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
				placement[1] = 'right';
			  }
			} else {
			  var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
			  if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
				placement[1] = 'top';
			  } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
				placement[1] = 'bottom';
			  }
			}
		  }
		}

		switch (placement[0]) {
		  case 'top':
			targetElemPos.top = hostElemPos.top - targetHeight;
			break;
		  case 'bottom':
			targetElemPos.top = hostElemPos.top + hostElemPos.height;
			break;
		  case 'left':
			targetElemPos.left = hostElemPos.left - targetWidth;
			break;
		  case 'right':
			targetElemPos.left = hostElemPos.left + hostElemPos.width;
			break;
		}

		switch (placement[1]) {
		  case 'top':
			targetElemPos.top = hostElemPos.top;
			break;
		  case 'bottom':
			targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
			break;
		  case 'left':
			targetElemPos.left = hostElemPos.left;
			break;
		  case 'right':
			targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
			break;
		  case 'center':
			if (PLACEMENT_REGEX.vertical.test(placement[0])) {
			  targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
			} else {
			  targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
			}
			break;
		}

		targetElemPos.top = Math.round(targetElemPos.top);
		targetElemPos.left = Math.round(targetElemPos.left);
		targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];

		return targetElemPos;
	  },

	  /**
	   * Provides a way to adjust the top positioning after first
	   * render to correctly align element to top after content
	   * rendering causes resized element height
	   *
	   * @param {array} placementClasses - The array of strings of classes
	   * element should have.
	   * @param {object} containerPosition - The object with container
	   * position information
	   * @param {number} initialHeight - The initial height for the elem.
	   * @param {number} currentHeight - The current height for the elem.
	   */
	  adjustTop: function(placementClasses, containerPosition, initialHeight, currentHeight) {
		if (placementClasses.indexOf('top') !== -1 && initialHeight !== currentHeight) {
		  return {
			top: containerPosition.top - currentHeight + 'px'
		  };
		}
	  },

	  /**
	   * Provides a way for positioning tooltip & dropdown
	   * arrows when using placement options beyond the standard
	   * left, right, top, or bottom.
	   *
	   * @param {element} elem - The tooltip/dropdown element.
	   * @param {string} placement - The placement for the elem.
	   */
	  positionArrow: function(elem, placement) {
		elem = this.getRawNode(elem);

		var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
		if (!innerElem) {
		  return;
		}

		var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');

		var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
		if (!arrowElem) {
		  return;
		}

		var arrowCss = {
		  top: '',
		  bottom: '',
		  left: '',
		  right: ''
		};

		placement = this.parsePlacement(placement);
		if (placement[1] === 'center') {
		  // no adjustment necessary - just reset styles
		  angular.element(arrowElem).css(arrowCss);
		  return;
		}

		var borderProp = 'border-' + placement[0] + '-width';
		var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];

		var borderRadiusProp = 'border-';
		if (PLACEMENT_REGEX.vertical.test(placement[0])) {
		  borderRadiusProp += placement[0] + '-' + placement[1];
		} else {
		  borderRadiusProp += placement[1] + '-' + placement[0];
		}
		borderRadiusProp += '-radius';
		var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];

		switch (placement[0]) {
		  case 'top':
			arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
			break;
		  case 'bottom':
			arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
			break;
		  case 'left':
			arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
			break;
		  case 'right':
			arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
			break;
		}

		arrowCss[placement[1]] = borderRadius;

		angular.element(arrowElem).css(arrowCss);
	  }
	};
  }]);

angular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position'])

.value('$datepickerPopupLiteralWarning', true)

.constant('uibDatepickerPopupConfig', {
  altInputFormats: [],
  appendToBody: false,
  clearText: 'Clear',
  closeOnDateSelection: true,
  closeText: 'Done',
  currentText: 'Today',
  datepickerPopup: 'yyyy-MM-dd',
  datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',
  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
  html5Types: {
	date: 'yyyy-MM-dd',
	'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
	'month': 'yyyy-MM'
  },
  onOpenFocus: true,
  showButtonBar: true,
  placement: 'auto bottom-left'
})

.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning',
function($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
  var cache = {},
	isHtml5DateInput = false;
  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,
	datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl,
	ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];

  this.init = function(_ngModel_) {
	ngModel = _ngModel_;
	ngModelOptions = _ngModel_.$options;
	closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?
	  $scope.$parent.$eval($attrs.closeOnDateSelection) :
	  datepickerPopupConfig.closeOnDateSelection;
	appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?
	  $scope.$parent.$eval($attrs.datepickerAppendToBody) :
	  datepickerPopupConfig.appendToBody;
	onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?
	  $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
	datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?
	  $attrs.datepickerPopupTemplateUrl :
	  datepickerPopupConfig.datepickerPopupTemplateUrl;
	datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?
	  $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
	altInputFormats = angular.isDefined($attrs.altInputFormats) ?
	  $scope.$parent.$eval($attrs.altInputFormats) :
	  datepickerPopupConfig.altInputFormats;

	$scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?
	  $scope.$parent.$eval($attrs.showButtonBar) :
	  datepickerPopupConfig.showButtonBar;

	if (datepickerPopupConfig.html5Types[$attrs.type]) {
	  dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
	  isHtml5DateInput = true;
	} else {
	  dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
	  $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
		var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
		// Invalidate the $modelValue to ensure that formatters re-run
		// FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
		if (newDateFormat !== dateFormat) {
		  dateFormat = newDateFormat;
		  ngModel.$modelValue = null;

		  if (!dateFormat) {
			throw new Error('uibDatepickerPopup must have a date format specified.');
		  }
		}
	  });
	}

	if (!dateFormat) {
	  throw new Error('uibDatepickerPopup must have a date format specified.');
	}

	if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
	  throw new Error('HTML5 date input types do not support custom formats.');
	}

	// popup element used to display calendar
	popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');

	popupEl.attr({
	  'ng-model': 'date',
	  'ng-change': 'dateSelection(date)',
	  'template-url': datepickerPopupTemplateUrl
	});

	// datepicker element
	datepickerEl = angular.element(popupEl.children()[0]);
	datepickerEl.attr('template-url', datepickerTemplateUrl);

	if (!$scope.datepickerOptions) {
	  $scope.datepickerOptions = {};
	}

	if (isHtml5DateInput) {
	  if ($attrs.type === 'month') {
		$scope.datepickerOptions.datepickerMode = 'month';
		$scope.datepickerOptions.minMode = 'month';
	  }
	}

	datepickerEl.attr('datepicker-options', 'datepickerOptions');

	if (!isHtml5DateInput) {
	  // Internal API to maintain the correct ng-invalid-[key] class
	  ngModel.$$parserName = 'date';
	  ngModel.$validators.date = validator;
	  ngModel.$parsers.unshift(parseDate);
	  ngModel.$formatters.push(function(value) {
		if (ngModel.$isEmpty(value)) {
		  $scope.date = value;
		  return value;
		}

		if (angular.isNumber(value)) {
		  value = new Date(value);
		}

		$scope.date = value;

		return dateParser.filter($scope.date, dateFormat);
	  });
	} else {
	  ngModel.$formatters.push(function(value) {
		$scope.date = value;
		return value;
	  });
	}

	// Detect changes in the view from the text box
	ngModel.$viewChangeListeners.push(function() {
	  $scope.date = parseDateString(ngModel.$viewValue);
	});

	$element.on('keydown', inputKeydownBind);

	$popup = $compile(popupEl)($scope);
	// Prevent jQuery cache memory leak (template is now redundant after linking)
	popupEl.remove();

	if (appendToBody) {
	  $document.find('body').append($popup);
	} else {
	  $element.after($popup);
	}

	$scope.$on('$destroy', function() {
	  if ($scope.isOpen === true) {
		if (!$rootScope.$$phase) {
		  $scope.$apply(function() {
			$scope.isOpen = false;
		  });
		}
	  }

	  $popup.remove();
	  $element.off('keydown', inputKeydownBind);
	  $document.off('click', documentClickBind);
	  if (scrollParentEl) {
		scrollParentEl.off('scroll', positionPopup);
	  }
	  angular.element($window).off('resize', positionPopup);

	  //Clear all watch listeners on destroy
	  while (watchListeners.length) {
		watchListeners.shift()();
	  }
	});
  };

  $scope.getText = function(key) {
	return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
  };

  $scope.isDisabled = function(date) {
	if (date === 'today') {
	  date = new Date();
	}

	var dates = {};
	angular.forEach(['minDate', 'maxDate'], function(key) {
	  if (!$scope.datepickerOptions[key]) {
		dates[key] = null;
	  } else if (angular.isDate($scope.datepickerOptions[key])) {
		dates[key] = new Date($scope.datepickerOptions[key]);
	  } else {
		if ($datepickerPopupLiteralWarning) {
		  $log.warn('Literal date support has been deprecated, please switch to date object usage');
		}

		dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));
	  }
	});

	return $scope.datepickerOptions &&
	  dates.minDate && $scope.compare(date, dates.minDate) < 0 ||
	  dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
  };

  $scope.compare = function(date1, date2) {
	return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
  };

  // Inner change
  $scope.dateSelection = function(dt) {
	$scope.date = dt;
	var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
	$element.val(date);
	ngModel.$setViewValue(date);

	if (closeOnDateSelection) {
	  $scope.isOpen = false;
	  $element[0].focus();
	}
  };

  $scope.keydown = function(evt) {
	if (evt.which === 27) {
	  evt.stopPropagation();
	  $scope.isOpen = false;
	  $element[0].focus();
	}
  };

  $scope.select = function(date, evt) {
	evt.stopPropagation();

	if (date === 'today') {
	  var today = new Date();
	  if (angular.isDate($scope.date)) {
		date = new Date($scope.date);
		date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
	  } else {
		date = new Date(today.setHours(0, 0, 0, 0));
	  }
	}
	$scope.dateSelection(date);
  };

  $scope.close = function(evt) {
	evt.stopPropagation();

	$scope.isOpen = false;
	$element[0].focus();
  };

  $scope.disabled = angular.isDefined($attrs.disabled) || false;
  if ($attrs.ngDisabled) {
	watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {
	  $scope.disabled = disabled;
	}));
  }

  $scope.$watch('isOpen', function(value) {
	if (value) {
	  if (!$scope.disabled) {
		$timeout(function() {
		  positionPopup();

		  if (onOpenFocus) {
			$scope.$broadcast('uib:datepicker.focus');
		  }

		  $document.on('click', documentClickBind);

		  var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
		  if (appendToBody || $position.parsePlacement(placement)[2]) {
			scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
			if (scrollParentEl) {
			  scrollParentEl.on('scroll', positionPopup);
			}
		  } else {
			scrollParentEl = null;
		  }

		  angular.element($window).on('resize', positionPopup);
		}, 0, false);
	  } else {
		$scope.isOpen = false;
	  }
	} else {
	  $document.off('click', documentClickBind);
	  if (scrollParentEl) {
		scrollParentEl.off('scroll', positionPopup);
	  }
	  angular.element($window).off('resize', positionPopup);
	}
  });

  function cameltoDash(string) {
	return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });
  }

  function parseDateString(viewValue) {
	var date = dateParser.parse(viewValue, dateFormat, $scope.date);
	if (isNaN(date)) {
	  for (var i = 0; i < altInputFormats.length; i++) {
		date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
		if (!isNaN(date)) {
		  return date;
		}
	  }
	}
	return date;
  }

  function parseDate(viewValue) {
	if (angular.isNumber(viewValue)) {
	  // presumably timestamp to date object
	  viewValue = new Date(viewValue);
	}

	if (!viewValue) {
	  return null;
	}

	if (angular.isDate(viewValue) && !isNaN(viewValue)) {
	  return viewValue;
	}

	if (angular.isString(viewValue)) {
	  var date = parseDateString(viewValue);
	  if (!isNaN(date)) {
		return date;
	  }
	}

	return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;
  }

  function validator(modelValue, viewValue) {
	var value = modelValue || viewValue;

	if (!$attrs.ngRequired && !value) {
	  return true;
	}

	if (angular.isNumber(value)) {
	  value = new Date(value);
	}

	if (!value) {
	  return true;
	}

	if (angular.isDate(value) && !isNaN(value)) {
	  return true;
	}

	if (angular.isString(value)) {
	  return !isNaN(parseDateString(value));
	}

	return false;
  }

  function documentClickBind(event) {
	if (!$scope.isOpen && $scope.disabled) {
	  return;
	}

	var popup = $popup[0];
	var dpContainsTarget = $element[0].contains(event.target);
	// The popup node may not be an element node
	// In some browsers (IE) only element nodes have the 'contains' function
	var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
	if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
	  $scope.$apply(function() {
		$scope.isOpen = false;
	  });
	}
  }

  function inputKeydownBind(evt) {
	if (evt.which === 27 && $scope.isOpen) {
	  evt.preventDefault();
	  evt.stopPropagation();
	  $scope.$apply(function() {
		$scope.isOpen = false;
	  });
	  $element[0].focus();
	} else if (evt.which === 40 && !$scope.isOpen) {
	  evt.preventDefault();
	  evt.stopPropagation();
	  $scope.$apply(function() {
		$scope.isOpen = true;
	  });
	}
  }

  function positionPopup() {
	if ($scope.isOpen) {
	  var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
	  var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
	  var position = $position.positionElements($element, dpElement, placement, appendToBody);
	  dpElement.css({top: position.top + 'px', left: position.left + 'px'});
	  if (dpElement.hasClass('uib-position-measure')) {
		dpElement.removeClass('uib-position-measure');
	  }
	}
  }

  $scope.$on('uib:datepicker.mode', function() {
	$timeout(positionPopup, 0, false);
  });
}])

.directive('uibDatepickerPopup', function() {
  return {
	require: ['ngModel', 'uibDatepickerPopup'],
	controller: 'UibDatepickerPopupController',
	scope: {
	  datepickerOptions: '=?',
	  isOpen: '=?',
	  currentText: '@',
	  clearText: '@',
	  closeText: '@'
	},
	link: function(scope, element, attrs, ctrls) {
	  var ngModel = ctrls[0],
		ctrl = ctrls[1];

	  ctrl.init(ngModel);
	}
  };
})

.directive('uibDatepickerPopupWrap', function() {
  return {
	restrict: 'A',
	transclude: true,
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';
	}
  };
});

angular.module('ui.bootstrap.debounce', [])
/**
 * A helper, internal service that debounces a function
 */
  .factory('$$debounce', ['$timeout', function($timeout) {
	return function(callback, debounceTime) {
	  var timeoutPromise;

	  return function() {
		var self = this;
		var args = Array.prototype.slice.call(arguments);
		if (timeoutPromise) {
		  $timeout.cancel(timeoutPromise);
		}

		timeoutPromise = $timeout(function() {
		  callback.apply(self, args);
		}, debounceTime);
	  };
	};
  }]);

angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])

.constant('uibDropdownConfig', {
  appendToOpenClass: 'uib-dropdown-open',
  openClass: 'open'
})

.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {
  var openScope = null;

  this.open = function(dropdownScope, element) {
	if (!openScope) {
	  $document.on('click', closeDropdown);
	}

	if (openScope && openScope !== dropdownScope) {
	  openScope.isOpen = false;
	}

	openScope = dropdownScope;
  };

  this.close = function(dropdownScope, element) {
	if (openScope === dropdownScope) {
	  openScope = null;
	  $document.off('click', closeDropdown);
	  var dropdownMenu = dropdownScope.getDropdownElement();
	  if (dropdownMenu) {
		dropdownMenu.off('keydown', this.keybindFilter);
	  }
	}
  };

  var closeDropdown = function(evt) {
	// This method may still be called during the same mouse event that
	// unbound this event handler. So check openScope before proceeding.
	if (!openScope) { return; }

	if (evt && openScope.getAutoClose() === 'disabled') { return; }

	if (evt && evt.which === 3) { return; }

	var toggleElement = openScope.getToggleElement();
	if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
	  return;
	}

	var dropdownElement = openScope.getDropdownElement();
	if (evt && openScope.getAutoClose() === 'outsideClick' &&
	  dropdownElement && dropdownElement[0].contains(evt.target)) {
	  return;
	}

	openScope.isOpen = false;
	openScope.focusToggleElement();

	if (!$rootScope.$$phase) {
	  openScope.$apply();
	}
  };

  this.keybindFilter = function(evt) {
	if (evt.which === 27) {
	  evt.stopPropagation();
	  openScope.focusToggleElement();
	  closeDropdown();
	} else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {
	  evt.preventDefault();
	  evt.stopPropagation();
	  openScope.focusDropdownEntry(evt.which);
	}
  };
}])

.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
  var self = this,
	scope = $scope.$new(), // create a child scope so we are not polluting original one
	templateScope,
	appendToOpenClass = dropdownConfig.appendToOpenClass,
	openClass = dropdownConfig.openClass,
	getIsOpen,
	setIsOpen = angular.noop,
	toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
	appendToBody = false,
	appendTo = null,
	keynavEnabled = false,
	selectedOption = null,
	body = $document.find('body');

  $element.addClass('dropdown');

  this.init = function() {
	if ($attrs.isOpen) {
	  getIsOpen = $parse($attrs.isOpen);
	  setIsOpen = getIsOpen.assign;

	  $scope.$watch(getIsOpen, function(value) {
		scope.isOpen = !!value;
	  });
	}

	if (angular.isDefined($attrs.dropdownAppendTo)) {
	  var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
	  if (appendToEl) {
		appendTo = angular.element(appendToEl);
	  }
	}

	appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
	keynavEnabled = angular.isDefined($attrs.keyboardNav);

	if (appendToBody && !appendTo) {
	  appendTo = body;
	}

	if (appendTo && self.dropdownMenu) {
	  appendTo.append(self.dropdownMenu);
	  $element.on('$destroy', function handleDestroyEvent() {
		self.dropdownMenu.remove();
	  });
	}
  };

  this.toggle = function(open) {
	scope.isOpen = arguments.length ? !!open : !scope.isOpen;
	if (angular.isFunction(setIsOpen)) {
	  setIsOpen(scope, scope.isOpen);
	}

	return scope.isOpen;
  };

  // Allow other directives to watch status
  this.isOpen = function() {
	return scope.isOpen;
  };

  scope.getToggleElement = function() {
	return self.toggleElement;
  };

  scope.getAutoClose = function() {
	return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
  };

  scope.getElement = function() {
	return $element;
  };

  scope.isKeynavEnabled = function() {
	return keynavEnabled;
  };

  scope.focusDropdownEntry = function(keyCode) {
	var elems = self.dropdownMenu ? //If append to body is used.
	  angular.element(self.dropdownMenu).find('a') :
	  $element.find('ul').eq(0).find('a');

	switch (keyCode) {
	  case 40: {
		if (!angular.isNumber(self.selectedOption)) {
		  self.selectedOption = 0;
		} else {
		  self.selectedOption = self.selectedOption === elems.length - 1 ?
			self.selectedOption :
			self.selectedOption + 1;
		}
		break;
	  }
	  case 38: {
		if (!angular.isNumber(self.selectedOption)) {
		  self.selectedOption = elems.length - 1;
		} else {
		  self.selectedOption = self.selectedOption === 0 ?
			0 : self.selectedOption - 1;
		}
		break;
	  }
	}
	elems[self.selectedOption].focus();
  };

  scope.getDropdownElement = function() {
	return self.dropdownMenu;
  };

  scope.focusToggleElement = function() {
	if (self.toggleElement) {
	  self.toggleElement[0].focus();
	}
  };

  scope.$watch('isOpen', function(isOpen, wasOpen) {
	if (appendTo && self.dropdownMenu) {
	  var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
		css,
		rightalign,
		scrollbarPadding,
		scrollbarWidth = 0;

	  css = {
		top: pos.top + 'px',
		display: isOpen ? 'block' : 'none'
	  };

	  rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
	  if (!rightalign) {
		css.left = pos.left + 'px';
		css.right = 'auto';
	  } else {
		css.left = 'auto';
		scrollbarPadding = $position.scrollbarPadding(appendTo);

		if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
		  scrollbarWidth = scrollbarPadding.scrollbarWidth;
		}

		css.right = window.innerWidth - scrollbarWidth -
		  (pos.left + $element.prop('offsetWidth')) + 'px';
	  }

	  // Need to adjust our positioning to be relative to the appendTo container
	  // if it's not the body element
	  if (!appendToBody) {
		var appendOffset = $position.offset(appendTo);

		css.top = pos.top - appendOffset.top + 'px';

		if (!rightalign) {
		  css.left = pos.left - appendOffset.left + 'px';
		} else {
		  css.right = window.innerWidth -
			(pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
		}
	  }

	  self.dropdownMenu.css(css);
	}

	var openContainer = appendTo ? appendTo : $element;
	var hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);

	if (hasOpenClass === !isOpen) {
	  $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {
		if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
		  toggleInvoker($scope, { open: !!isOpen });
		}
	  });
	}

	if (isOpen) {
	  if (self.dropdownMenuTemplateUrl) {
		$templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
		  templateScope = scope.$new();
		  $compile(tplContent.trim())(templateScope, function(dropdownElement) {
			var newEl = dropdownElement;
			self.dropdownMenu.replaceWith(newEl);
			self.dropdownMenu = newEl;
			self.dropdownMenu.on('keydown', uibDropdownService.keybindFilter);
		  });
		});
	  } else {
		if (self.dropdownMenu) {
		  self.dropdownMenu.on('keydown', uibDropdownService.keybindFilter);
		}
	  }

	  scope.focusToggleElement();
	  uibDropdownService.open(scope, $element);
	} else {
	  uibDropdownService.close(scope, $element);
	  if (self.dropdownMenuTemplateUrl) {
		if (templateScope) {
		  templateScope.$destroy();
		}
		var newEl = angular.element('<ul class="dropdown-menu"></ul>');
		self.dropdownMenu.replaceWith(newEl);
		self.dropdownMenu = newEl;
	  }

	  self.selectedOption = null;
	}

	if (angular.isFunction(setIsOpen)) {
	  setIsOpen($scope, isOpen);
	}
  });
}])

.directive('uibDropdown', function() {
  return {
	controller: 'UibDropdownController',
	link: function(scope, element, attrs, dropdownCtrl) {
	  dropdownCtrl.init();
	}
  };
})

.directive('uibDropdownMenu', function() {
  return {
	restrict: 'A',
	require: '?^uibDropdown',
	link: function(scope, element, attrs, dropdownCtrl) {
	  if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
		return;
	  }

	  element.addClass('dropdown-menu');

	  var tplUrl = attrs.templateUrl;
	  if (tplUrl) {
		dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
	  }

	  if (!dropdownCtrl.dropdownMenu) {
		dropdownCtrl.dropdownMenu = element;
	  }
	}
  };
})

.directive('uibDropdownToggle', function() {
  return {
	require: '?^uibDropdown',
	link: function(scope, element, attrs, dropdownCtrl) {
	  if (!dropdownCtrl) {
		return;
	  }

	  element.addClass('dropdown-toggle');

	  dropdownCtrl.toggleElement = element;

	  var toggleDropdown = function(event) {
		event.preventDefault();

		if (!element.hasClass('disabled') && !attrs.disabled) {
		  scope.$apply(function() {
			dropdownCtrl.toggle();
		  });
		}
	  };

	  element.bind('click', toggleDropdown);

	  // WAI-ARIA
	  element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
	  scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
		element.attr('aria-expanded', !!isOpen);
	  });

	  scope.$on('$destroy', function() {
		element.unbind('click', toggleDropdown);
	  });
	}
  };
});

angular.module('ui.bootstrap.stackedMap', [])
/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
  .factory('$$stackedMap', function() {
	return {
	  createNew: function() {
		var stack = [];

		return {
		  add: function(key, value) {
			stack.push({
			  key: key,
			  value: value
			});
		  },
		  get: function(key) {
			for (var i = 0; i < stack.length; i++) {
			  if (key === stack[i].key) {
				return stack[i];
			  }
			}
		  },
		  keys: function() {
			var keys = [];
			for (var i = 0; i < stack.length; i++) {
			  keys.push(stack[i].key);
			}
			return keys;
		  },
		  top: function() {
			return stack[stack.length - 1];
		  },
		  remove: function(key) {
			var idx = -1;
			for (var i = 0; i < stack.length; i++) {
			  if (key === stack[i].key) {
				idx = i;
				break;
			  }
			}
			return stack.splice(idx, 1)[0];
		  },
		  removeTop: function() {
			return stack.pop();
		  },
		  length: function() {
			return stack.length;
		  }
		};
	  }
	};
  });
angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap', 'ui.bootstrap.position'])
/**
 * A helper, internal data structure that stores all references attached to key
 */
  .factory('$$multiMap', function() {
	return {
	  createNew: function() {
		var map = {};

		return {
		  entries: function() {
			return Object.keys(map).map(function(key) {
			  return {
				key: key,
				value: map[key]
			  };
			});
		  },
		  get: function(key) {
			return map[key];
		  },
		  hasKey: function(key) {
			return !!map[key];
		  },
		  keys: function() {
			return Object.keys(map);
		  },
		  put: function(key, value) {
			if (!map[key]) {
			  map[key] = [];
			}

			map[key].push(value);
		  },
		  remove: function(key, value) {
			var values = map[key];

			if (!values) {
			  return;
			}

			var idx = values.indexOf(value);

			if (idx !== -1) {
			  values.splice(idx, 1);
			}

			if (!values.length) {
			  delete map[key];
			}
		  }
		};
	  }
	};
  })

/**
 * Pluggable resolve mechanism for the modal resolve resolution
 * Supports UI Router's $resolve service
 */
  .provider('$uibResolve', function() {
	var resolve = this;
	this.resolver = null;

	this.setResolver = function(resolver) {
	  this.resolver = resolver;
	};

	this.$get = ['$injector', '$q', function($injector, $q) {
	  var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
	  return {
		resolve: function(invocables, locals, parent, self) {
		  if (resolver) {
			return resolver.resolve(invocables, locals, parent, self);
		  }

		  var promises = [];

		  angular.forEach(invocables, function(value) {
			if (angular.isFunction(value) || angular.isArray(value)) {
			  promises.push($q.resolve($injector.invoke(value)));
			} else if (angular.isString(value)) {
			  promises.push($q.resolve($injector.get(value)));
			} else {
			  promises.push($q.resolve(value));
			}
		  });

		  return $q.all(promises).then(function(resolves) {
			var resolveObj = {};
			var resolveIter = 0;
			angular.forEach(invocables, function(value, key) {
			  resolveObj[key] = resolves[resolveIter++];
			});

			return resolveObj;
		  });
		}
	  };
	}];
  })

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
  .directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack',
  function($animate, $injector, $modalStack) {
	return {
	  restrict: 'A',
	  compile: function(tElement, tAttrs) {
		tElement.addClass(tAttrs.backdropClass);
		return linkFn;
	  }
	};

	function linkFn(scope, element, attrs) {
	  if (attrs.modalInClass) {
		$animate.addClass(element, attrs.modalInClass);

		scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
		  var done = setIsAsync();
		  if (scope.modalOptions.animation) {
			$animate.removeClass(element, attrs.modalInClass).then(done);
		  } else {
			done();
		  }
		});
	  }
	}
  }])

  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document',
  function($modalStack, $q, $animateCss, $document) {
	return {
	  scope: {
		index: '@'
	  },
	  restrict: 'A',
	  transclude: true,
	  templateUrl: function(tElement, tAttrs) {
		return tAttrs.templateUrl || 'uib/template/modal/window.html';
	  },
	  link: function(scope, element, attrs) {
		element.addClass(attrs.windowTopClass || '');
		scope.size = attrs.size;

		scope.close = function(evt) {
		  var modal = $modalStack.getTop();
		  if (modal && modal.value.backdrop &&
			modal.value.backdrop !== 'static' &&
			evt.target === evt.currentTarget) {
			evt.preventDefault();
			evt.stopPropagation();
			$modalStack.dismiss(modal.key, 'backdrop click');
		  }
		};

		// moved from template to fix issue #2280
		element.on('click', scope.close);

		// This property is only added to the scope for the purpose of detecting when this directive is rendered.
		// We can detect that by using this property in the template associated with this directive and then use
		// {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
		scope.$isRendered = true;

		// Deferred object that will be resolved when this modal is render.
		var modalRenderDeferObj = $q.defer();
		// Resolve render promise post-digest
		scope.$$postDigest(function() {
		  modalRenderDeferObj.resolve();
		});

		modalRenderDeferObj.promise.then(function() {
		  var animationPromise = null;

		  if (attrs.modalInClass) {
			animationPromise = $animateCss(element, {
			  addClass: attrs.modalInClass
			}).start();

			scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
			  var done = setIsAsync();
			  $animateCss(element, {
				removeClass: attrs.modalInClass
			  }).start().then(done);
			});
		  }


		  $q.when(animationPromise).then(function() {
			// Notify {@link $modalStack} that modal is rendered.
			var modal = $modalStack.getTop();
			if (modal) {
			  $modalStack.modalRendered(modal.key);
			}

			/**
			 * If something within the freshly-opened modal already has focus (perhaps via a
			 * directive that causes focus). then no need to try and focus anything.
			 */
			if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
			  var inputWithAutofocus = element[0].querySelector('[autofocus]');
			  /**
			   * Auto-focusing of a freshly-opened modal element causes any child elements
			   * with the autofocus attribute to lose focus. This is an issue on touch
			   * based devices which will show and then hide the onscreen keyboard.
			   * Attempts to refocus the autofocus element via JavaScript will not reopen
			   * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
			   * the modal element if the modal does not contain an autofocus element.
			   */
			  if (inputWithAutofocus) {
				inputWithAutofocus.focus();
			  } else {
				element[0].focus();
			  }
			}
		  });
		});
	  }
	};
  }])

  .directive('uibModalAnimationClass', function() {
	return {
	  compile: function(tElement, tAttrs) {
		if (tAttrs.modalAnimation) {
		  tElement.addClass(tAttrs.uibModalAnimationClass);
		}
	  }
	};
  })

  .directive('uibModalTransclude', ['$animate', function($animate) {
	return {
	  link: function(scope, element, attrs, controller, transclude) {
		transclude(scope.$parent, function(clone) {
		  element.empty();
		  $animate.enter(clone, element);
		});
	  }
	};
  }])

  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',
	'$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition',
	function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
	  var OPENED_MODAL_CLASS = 'modal-open';

	  var backdropDomEl, backdropScope;
	  var openedWindows = $$stackedMap.createNew();
	  var openedClasses = $$multiMap.createNew();
	  var $modalStack = {
		NOW_CLOSING_EVENT: 'modal.stack.now-closing'
	  };
	  var topModalIndex = 0;
	  var previousTopOpenedModal = null;

	  //Modal focus behavior
	  var tabbableSelector = 'a[href], area[href], input:not([disabled]):not([tabindex=\'-1\']), ' +
		'button:not([disabled]):not([tabindex=\'-1\']),select:not([disabled]):not([tabindex=\'-1\']), textarea:not([disabled]):not([tabindex=\'-1\']), ' +
		'iframe, object, embed, *[tabindex]:not([tabindex=\'-1\']), *[contenteditable=true]';
	  var scrollbarPadding;

	  function isVisible(element) {
		return !!(element.offsetWidth ||
		  element.offsetHeight ||
		  element.getClientRects().length);
	  }

	  function backdropIndex() {
		var topBackdropIndex = -1;
		var opened = openedWindows.keys();
		for (var i = 0; i < opened.length; i++) {
		  if (openedWindows.get(opened[i]).value.backdrop) {
			topBackdropIndex = i;
		  }
		}

		// If any backdrop exist, ensure that it's index is always
		// right below the top modal
		if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {
		  topBackdropIndex = topModalIndex;
		}
		return topBackdropIndex;
	  }

	  $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
		if (backdropScope) {
		  backdropScope.index = newBackdropIndex;
		}
	  });

	  function removeModalWindow(modalInstance, elementToReceiveFocus) {
		var modalWindow = openedWindows.get(modalInstance).value;
		var appendToElement = modalWindow.appendTo;

		//clean up the stack
		openedWindows.remove(modalInstance);
		previousTopOpenedModal = openedWindows.top();
		if (previousTopOpenedModal) {
		  topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);
		}

		removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
		  var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
		  openedClasses.remove(modalBodyClass, modalInstance);
		  var areAnyOpen = openedClasses.hasKey(modalBodyClass);
		  appendToElement.toggleClass(modalBodyClass, areAnyOpen);
		  if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
			if (scrollbarPadding.originalRight) {
			  appendToElement.css({paddingRight: scrollbarPadding.originalRight + 'px'});
			} else {
			  appendToElement.css({paddingRight: ''});
			}
			scrollbarPadding = null;
		  }
		  toggleTopWindowClass(true);
		}, modalWindow.closedDeferred);
		checkRemoveBackdrop();

		//move focus to specified element if available, or else to body
		if (elementToReceiveFocus && elementToReceiveFocus.focus) {
		  elementToReceiveFocus.focus();
		} else if (appendToElement.focus) {
		  appendToElement.focus();
		}
	  }

	  // Add or remove "windowTopClass" from the top window in the stack
	  function toggleTopWindowClass(toggleSwitch) {
		var modalWindow;

		if (openedWindows.length() > 0) {
		  modalWindow = openedWindows.top().value;
		  modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
		}
	  }

	  function checkRemoveBackdrop() {
		//remove backdrop if no longer needed
		if (backdropDomEl && backdropIndex() === -1) {
		  var backdropScopeRef = backdropScope;
		  removeAfterAnimate(backdropDomEl, backdropScope, function() {
			backdropScopeRef = null;
		  });
		  backdropDomEl = undefined;
		  backdropScope = undefined;
		}
	  }

	  function removeAfterAnimate(domEl, scope, done, closedDeferred) {
		var asyncDeferred;
		var asyncPromise = null;
		var setIsAsync = function() {
		  if (!asyncDeferred) {
			asyncDeferred = $q.defer();
			asyncPromise = asyncDeferred.promise;
		  }

		  return function asyncDone() {
			asyncDeferred.resolve();
		  };
		};
		scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);

		// Note that it's intentional that asyncPromise might be null.
		// That's when setIsAsync has not been called during the
		// NOW_CLOSING_EVENT broadcast.
		return $q.when(asyncPromise).then(afterAnimating);

		function afterAnimating() {
		  if (afterAnimating.done) {
			return;
		  }
		  afterAnimating.done = true;

		  $animate.leave(domEl).then(function() {
			if (done) {
			  done();
			}

			domEl.remove();
			if (closedDeferred) {
			  closedDeferred.resolve();
			}
		  });

		  scope.$destroy();
		}
	  }

	  $document.on('keydown', keydownListener);

	  $rootScope.$on('$destroy', function() {
		$document.off('keydown', keydownListener);
	  });

	  function keydownListener(evt) {
		if (evt.isDefaultPrevented()) {
		  return evt;
		}

		var modal = openedWindows.top();
		if (modal) {
		  switch (evt.which) {
			case 27: {
			  if (modal.value.keyboard) {
				evt.preventDefault();
				$rootScope.$apply(function() {
				  $modalStack.dismiss(modal.key, 'escape key press');
				});
			  }
			  break;
			}
			case 9: {
			  var list = $modalStack.loadFocusElementList(modal);
			  var focusChanged = false;
			  if (evt.shiftKey) {
				if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
				  focusChanged = $modalStack.focusLastFocusableElement(list);
				}
			  } else {
				if ($modalStack.isFocusInLastItem(evt, list)) {
				  focusChanged = $modalStack.focusFirstFocusableElement(list);
				}
			  }

			  if (focusChanged) {
				evt.preventDefault();
				evt.stopPropagation();
			  }

			  break;
			}
		  }
		}
	  }

	  $modalStack.open = function(modalInstance, modal) {
		var modalOpener = $document[0].activeElement,
		  modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;

		toggleTopWindowClass(false);

		// Store the current top first, to determine what index we ought to use
		// for the current top modal
		previousTopOpenedModal = openedWindows.top();

		openedWindows.add(modalInstance, {
		  deferred: modal.deferred,
		  renderDeferred: modal.renderDeferred,
		  closedDeferred: modal.closedDeferred,
		  modalScope: modal.scope,
		  backdrop: modal.backdrop,
		  keyboard: modal.keyboard,
		  openedClass: modal.openedClass,
		  windowTopClass: modal.windowTopClass,
		  animation: modal.animation,
		  appendTo: modal.appendTo
		});

		openedClasses.put(modalBodyClass, modalInstance);

		var appendToElement = modal.appendTo,
			currBackdropIndex = backdropIndex();

		if (!appendToElement.length) {
		  throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
		}

		if (currBackdropIndex >= 0 && !backdropDomEl) {
		  backdropScope = $rootScope.$new(true);
		  backdropScope.modalOptions = modal;
		  backdropScope.index = currBackdropIndex;
		  backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
		  backdropDomEl.attr({
			'class': 'modal-backdrop',
			'ng-style': '{\'z-index\': 1040 + (index && 1 || 0) + index*10}',
			'uib-modal-animation-class': 'fade',
			'modal-in-class': 'in'
		  });
		  if (modal.backdropClass) {
			backdropDomEl.addClass(modal.backdropClass);
		  }

		  if (modal.animation) {
			backdropDomEl.attr('modal-animation', 'true');
		  }
		  $compile(backdropDomEl)(backdropScope);
		  $animate.enter(backdropDomEl, appendToElement);
		  if ($uibPosition.isScrollable(appendToElement)) {
			scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
			if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
			  appendToElement.css({paddingRight: scrollbarPadding.right + 'px'});
			}
		  }
		}

		// Set the top modal index based on the index of the previous top modal
		topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;
		var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
		angularDomEl.attr({
		  'class': 'modal',
		  'template-url': modal.windowTemplateUrl,
		  'window-top-class': modal.windowTopClass,
		  'role': 'dialog',
		  'size': modal.size,
		  'index': topModalIndex,
		  'animate': 'animate',
		  'ng-style': '{\'z-index\': 1050 + index*10, display: \'block\'}',
		  'tabindex': -1,
		  'uib-modal-animation-class': 'fade',
		  'modal-in-class': 'in'
		}).html(modal.content);
		if (modal.windowClass) {
		  angularDomEl.addClass(modal.windowClass);
		}

		if (modal.animation) {
		  angularDomEl.attr('modal-animation', 'true');
		}

		appendToElement.addClass(modalBodyClass);
		$animate.enter($compile(angularDomEl)(modal.scope), appendToElement);

		openedWindows.top().value.modalDomEl = angularDomEl;
		openedWindows.top().value.modalOpener = modalOpener;
	  };

	  function broadcastClosing(modalWindow, resultOrReason, closing) {
		return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
	  }

	  $modalStack.close = function(modalInstance, result) {
		var modalWindow = openedWindows.get(modalInstance);
		if (modalWindow && broadcastClosing(modalWindow, result, true)) {
		  modalWindow.value.modalScope.$$uibDestructionScheduled = true;
		  modalWindow.value.deferred.resolve(result);
		  removeModalWindow(modalInstance, modalWindow.value.modalOpener);
		  return true;
		}
		return !modalWindow;
	  };

	  $modalStack.dismiss = function(modalInstance, reason) {
		var modalWindow = openedWindows.get(modalInstance);
		if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
		  modalWindow.value.modalScope.$$uibDestructionScheduled = true;
		  modalWindow.value.deferred.reject(reason);
		  removeModalWindow(modalInstance, modalWindow.value.modalOpener);
		  return true;
		}
		return !modalWindow;
	  };

	  $modalStack.dismissAll = function(reason) {
		var topModal = this.getTop();
		while (topModal && this.dismiss(topModal.key, reason)) {
		  topModal = this.getTop();
		}
	  };

	  $modalStack.getTop = function() {
		return openedWindows.top();
	  };

	  $modalStack.modalRendered = function(modalInstance) {
		var modalWindow = openedWindows.get(modalInstance);
		if (modalWindow) {
		  modalWindow.value.renderDeferred.resolve();
		}
	  };

	  $modalStack.focusFirstFocusableElement = function(list) {
		if (list.length > 0) {
		  list[0].focus();
		  return true;
		}
		return false;
	  };

	  $modalStack.focusLastFocusableElement = function(list) {
		if (list.length > 0) {
		  list[list.length - 1].focus();
		  return true;
		}
		return false;
	  };

	  $modalStack.isModalFocused = function(evt, modalWindow) {
		if (evt && modalWindow) {
		  var modalDomEl = modalWindow.value.modalDomEl;
		  if (modalDomEl && modalDomEl.length) {
			return (evt.target || evt.srcElement) === modalDomEl[0];
		  }
		}
		return false;
	  };

	  $modalStack.isFocusInFirstItem = function(evt, list) {
		if (list.length > 0) {
		  return (evt.target || evt.srcElement) === list[0];
		}
		return false;
	  };

	  $modalStack.isFocusInLastItem = function(evt, list) {
		if (list.length > 0) {
		  return (evt.target || evt.srcElement) === list[list.length - 1];
		}
		return false;
	  };

	  $modalStack.loadFocusElementList = function(modalWindow) {
		if (modalWindow) {
		  var modalDomE1 = modalWindow.value.modalDomEl;
		  if (modalDomE1 && modalDomE1.length) {
			var elements = modalDomE1[0].querySelectorAll(tabbableSelector);
			return elements ?
			  Array.prototype.filter.call(elements, function(element) {
				return isVisible(element);
			  }) : elements;
		  }
		}
	  };

	  return $modalStack;
	}])

  .provider('$uibModal', function() {
	var $modalProvider = {
	  options: {
		animation: true,
		backdrop: true, //can also be false or 'static'
		keyboard: true
	  },
	  $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',
		function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
		  var $modal = {};

		  function getTemplatePromise(options) {
			return options.template ? $q.when(options.template) :
			  $templateRequest(angular.isFunction(options.templateUrl) ?
				options.templateUrl() : options.templateUrl);
		  }

		  var promiseChain = null;
		  $modal.getPromiseChain = function() {
			return promiseChain;
		  };

		  $modal.open = function(modalOptions) {
			var modalResultDeferred = $q.defer();
			var modalOpenedDeferred = $q.defer();
			var modalClosedDeferred = $q.defer();
			var modalRenderDeferred = $q.defer();

			//prepare an instance of a modal to be injected into controllers and returned to a caller
			var modalInstance = {
			  result: modalResultDeferred.promise,
			  opened: modalOpenedDeferred.promise,
			  closed: modalClosedDeferred.promise,
			  rendered: modalRenderDeferred.promise,
			  close: function (result) {
				return $modalStack.close(modalInstance, result);
			  },
			  dismiss: function (reason) {
				return $modalStack.dismiss(modalInstance, reason);
			  }
			};

			//merge and clean up options
			modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
			modalOptions.resolve = modalOptions.resolve || {};
			modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);

			//verify options
			if (!modalOptions.template && !modalOptions.templateUrl) {
			  throw new Error('One of template or templateUrl options is required.');
			}

			var templateAndResolvePromise =
			  $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);

			function resolveWithTemplate() {
			  return templateAndResolvePromise;
			}

			// Wait for the resolution of the existing promise chain.
			// Then switch to our own combined promise dependency (regardless of how the previous modal fared).
			// Then add to $modalStack and resolve opened.
			// Finally clean up the chain variable if no subsequent modal has overwritten it.
			var samePromise;
			samePromise = promiseChain = $q.all([promiseChain])
			  .then(resolveWithTemplate, resolveWithTemplate)
			  .then(function resolveSuccess(tplAndVars) {
				var providedScope = modalOptions.scope || $rootScope;

				var modalScope = providedScope.$new();
				modalScope.$close = modalInstance.close;
				modalScope.$dismiss = modalInstance.dismiss;

				modalScope.$on('$destroy', function() {
				  if (!modalScope.$$uibDestructionScheduled) {
					modalScope.$dismiss('$uibUnscheduledDestruction');
				  }
				});

				var ctrlInstance, ctrlInstantiate, ctrlLocals = {};

				//controllers
				if (modalOptions.controller) {
				  ctrlLocals.$scope = modalScope;
				  ctrlLocals.$scope.$resolve = {};
				  ctrlLocals.$uibModalInstance = modalInstance;
				  angular.forEach(tplAndVars[1], function(value, key) {
					ctrlLocals[key] = value;
					ctrlLocals.$scope.$resolve[key] = value;
				  });

				  // the third param will make the controller instantiate later,private api
				  // @see https://github.com/angular/angular.js/blob/master/src/ng/controller.js#L126
				  ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);
				  if (modalOptions.controllerAs && modalOptions.bindToController) {
					ctrlInstance = ctrlInstantiate.instance;
					ctrlInstance.$close = modalScope.$close;
					ctrlInstance.$dismiss = modalScope.$dismiss;
					angular.extend(ctrlInstance, {
					  $resolve: ctrlLocals.$scope.$resolve
					}, providedScope);
				  }

				  ctrlInstance = ctrlInstantiate();

				  if (angular.isFunction(ctrlInstance.$onInit)) {
					ctrlInstance.$onInit();
				  }
				}

				$modalStack.open(modalInstance, {
				  scope: modalScope,
				  deferred: modalResultDeferred,
				  renderDeferred: modalRenderDeferred,
				  closedDeferred: modalClosedDeferred,
				  content: tplAndVars[0],
				  animation: modalOptions.animation,
				  backdrop: modalOptions.backdrop,
				  keyboard: modalOptions.keyboard,
				  backdropClass: modalOptions.backdropClass,
				  windowTopClass: modalOptions.windowTopClass,
				  windowClass: modalOptions.windowClass,
				  windowTemplateUrl: modalOptions.windowTemplateUrl,
				  size: modalOptions.size,
				  openedClass: modalOptions.openedClass,
				  appendTo: modalOptions.appendTo
				});
				modalOpenedDeferred.resolve(true);

			}, function resolveError(reason) {
			  modalOpenedDeferred.reject(reason);
			  modalResultDeferred.reject(reason);
			})['finally'](function() {
			  if (promiseChain === samePromise) {
				promiseChain = null;
			  }
			});

			return modalInstance;
		  };

		  return $modal;
		}
	  ]
	};

	return $modalProvider;
  });

angular.module('ui.bootstrap.paging', [])
/**
 * Helper internal service for generating common controller code between the
 * pager and pagination components
 */
.factory('uibPaging', ['$parse', function($parse) {
  return {
	create: function(ctrl, $scope, $attrs) {
	  ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
	  ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl
	  ctrl._watchers = [];

	  ctrl.init = function(ngModelCtrl, config) {
		ctrl.ngModelCtrl = ngModelCtrl;
		ctrl.config = config;

		ngModelCtrl.$render = function() {
		  ctrl.render();
		};

		if ($attrs.itemsPerPage) {
		  ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {
			ctrl.itemsPerPage = parseInt(value, 10);
			$scope.totalPages = ctrl.calculateTotalPages();
			ctrl.updatePage();
		  }));
		} else {
		  ctrl.itemsPerPage = config.itemsPerPage;
		}

		$scope.$watch('totalItems', function(newTotal, oldTotal) {
		  if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
			$scope.totalPages = ctrl.calculateTotalPages();
			ctrl.updatePage();
		  }
		});
	  };

	  ctrl.calculateTotalPages = function() {
		var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
		return Math.max(totalPages || 0, 1);
	  };

	  ctrl.render = function() {
		$scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
	  };

	  $scope.selectPage = function(page, evt) {
		if (evt) {
		  evt.preventDefault();
		}

		var clickAllowed = !$scope.ngDisabled || !evt;
		if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
		  if (evt && evt.target) {
			evt.target.blur();
		  }
		  ctrl.ngModelCtrl.$setViewValue(page);
		  ctrl.ngModelCtrl.$render();
		}
	  };

	  $scope.getText = function(key) {
		return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
	  };

	  $scope.noPrevious = function() {
		return $scope.page === 1;
	  };

	  $scope.noNext = function() {
		return $scope.page === $scope.totalPages;
	  };

	  ctrl.updatePage = function() {
		ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable

		if ($scope.page > $scope.totalPages) {
		  $scope.selectPage($scope.totalPages);
		} else {
		  ctrl.ngModelCtrl.$render();
		}
	  };

	  $scope.$on('$destroy', function() {
		while (ctrl._watchers.length) {
		  ctrl._watchers.shift()();
		}
	  });
	}
  };
}]);

angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])

.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {
  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;

  uibPaging.create(this, $scope, $attrs);
}])

.constant('uibPagerConfig', {
  itemsPerPage: 10,
  previousText: '« Previous',
  nextText: 'Next »',
  align: true
})

.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {
  return {
	scope: {
	  totalItems: '=',
	  previousText: '@',
	  nextText: '@',
	  ngDisabled: '='
	},
	require: ['uibPager', '?ngModel'],
	restrict: 'A',
	controller: 'UibPagerController',
	controllerAs: 'pager',
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || 'uib/template/pager/pager.html';
	},
	link: function(scope, element, attrs, ctrls) {
	  element.addClass('pager');
	  var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

	  if (!ngModelCtrl) {
		return; // do nothing if no ng-model
	  }

	  paginationCtrl.init(ngModelCtrl, uibPagerConfig);
	}
  };
}]);

angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])
.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
  var ctrl = this;
  // Setup configuration parameters
  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
	rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
	forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
	boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,
	pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) { return $scope.$parent.$eval($attrs.pageLabel, {$page: idx}); } : angular.identity;
  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;

  uibPaging.create(this, $scope, $attrs);

  if ($attrs.maxSize) {
	ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {
	  maxSize = parseInt(value, 10);
	  ctrl.render();
	}));
  }

  // Create page object used in template
  function makePage(number, text, isActive) {
	return {
	  number: number,
	  text: text,
	  active: isActive
	};
  }

  function getPages(currentPage, totalPages) {
	var pages = [];

	// Default page limits
	var startPage = 1, endPage = totalPages;
	var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;

	// recompute if maxSize
	if (isMaxSized) {
	  if (rotate) {
		// Current page is displayed in the middle of the visible ones
		startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
		endPage = startPage + maxSize - 1;

		// Adjust if limit is exceeded
		if (endPage > totalPages) {
		  endPage = totalPages;
		  startPage = endPage - maxSize + 1;
		}
	  } else {
		// Visible pages are paginated with maxSize
		startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;

		// Adjust last page if limit is exceeded
		endPage = Math.min(startPage + maxSize - 1, totalPages);
	  }
	}

	// Add page number links
	for (var number = startPage; number <= endPage; number++) {
	  var page = makePage(number, pageLabel(number), number === currentPage);
	  pages.push(page);
	}

	// Add links to move between page sets
	if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
	  if (startPage > 1) {
		if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning
		var previousPageSet = makePage(startPage - 1, '...', false);
		pages.unshift(previousPageSet);
	  }
		if (boundaryLinkNumbers) {
		  if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential
			var secondPageLink = makePage(2, '2', false);
			pages.unshift(secondPageLink);
		  }
		  //add the first page
		  var firstPageLink = makePage(1, '1', false);
		  pages.unshift(firstPageLink);
		}
	  }

	  if (endPage < totalPages) {
		if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end
		var nextPageSet = makePage(endPage + 1, '...', false);
		pages.push(nextPageSet);
	  }
		if (boundaryLinkNumbers) {
		  if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential
			var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
			pages.push(secondToLastPageLink);
		  }
		  //add the last page
		  var lastPageLink = makePage(totalPages, totalPages, false);
		  pages.push(lastPageLink);
		}
	  }
	}
	return pages;
  }

  var originalRender = this.render;
  this.render = function() {
	originalRender();
	if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
	  $scope.pages = getPages($scope.page, $scope.totalPages);
	}
  };
}])

.constant('uibPaginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  boundaryLinkNumbers: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true,
  forceEllipses: false
})

.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {
  return {
	scope: {
	  totalItems: '=',
	  firstText: '@',
	  previousText: '@',
	  nextText: '@',
	  lastText: '@',
	  ngDisabled:'='
	},
	require: ['uibPagination', '?ngModel'],
	restrict: 'A',
	controller: 'UibPaginationController',
	controllerAs: 'pagination',
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || 'uib/template/pagination/pagination.html';
	},
	link: function(scope, element, attrs, ctrls) {
	  element.addClass('pagination');
	  var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

	  if (!ngModelCtrl) {
		 return; // do nothing if no ng-model
	  }

	  paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
	}
  };
}]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider('$uibTooltip', function() {
  // The default options tooltip and popover.
  var defaultOptions = {
	placement: 'top',
	placementClassPrefix: '',
	animation: true,
	popupDelay: 0,
	popupCloseDelay: 0,
	useContentExp: false
  };

  // Default hide triggers for each show trigger
  var triggerMap = {
	'mouseenter': 'mouseleave',
	'click': 'click',
	'outsideClick': 'outsideClick',
	'focus': 'blur',
	'none': ''
  };

  // The options specified to the provider globally.
  var globalOptions = {};

  /**
   * `options({})` allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: 'left' } );
   *   });
   */
	this.options = function(value) {
		angular.extend(globalOptions, value);
	};

  /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( { 'openTrigger': 'closeTrigger' } );
   */
  this.setTriggers = function setTriggers(triggers) {
	angular.extend(triggerMap, triggers);
  };

  /**
   * This is a helper function for translating camel-case to snake_case.
   */
  function snake_case(name) {
	var regexp = /[A-Z]/g;
	var separator = '-';
	return name.replace(regexp, function(letter, pos) {
	  return (pos ? separator : '') + letter.toLowerCase();
	});
  }

  /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
	var openedTooltips = $$stackedMap.createNew();
	$document.on('keypress', keypressListener);

	$rootScope.$on('$destroy', function() {
	  $document.off('keypress', keypressListener);
	});

	function keypressListener(e) {
	  if (e.which === 27) {
		var last = openedTooltips.top();
		if (last) {
		  last.value.close();
		  openedTooltips.removeTop();
		  last = null;
		}
	  }
	}

	return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
	  options = angular.extend({}, defaultOptions, globalOptions, options);

	  /**
	   * Returns an object of show and hide triggers.
	   *
	   * If a trigger is supplied,
	   * it is used to show the tooltip; otherwise, it will use the `trigger`
	   * option passed to the `$tooltipProvider.options` method; else it will
	   * default to the trigger supplied to this directive factory.
	   *
	   * The hide trigger is based on the show trigger. If the `trigger` option
	   * was passed to the `$tooltipProvider.options` method, it will use the
	   * mapped trigger from `triggerMap` or the passed trigger if the map is
	   * undefined; otherwise, it uses the `triggerMap` value of the show
	   * trigger; else it will just use the show trigger.
	   */
	  function getTriggers(trigger) {
		var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
		var hide = show.map(function(trigger) {
		  return triggerMap[trigger] || trigger;
		});
		return {
		  show: show,
		  hide: hide
		};
	  }

	  var directiveName = snake_case(ttType);

	  var startSym = $interpolate.startSymbol();
	  var endSym = $interpolate.endSymbol();
	  var template =
		'<div '+ directiveName + '-popup ' +
		  'uib-title="' + startSym + 'title' + endSym + '" ' +
		  (options.useContentExp ?
			'content-exp="contentExp()" ' :
			'content="' + startSym + 'content' + endSym + '" ') +
		  'origin-scope="origScope" ' +
		  'class="uib-position-measure ' + prefix + '" ' +
		  'tooltip-animation-class="fade"' +
		  'uib-tooltip-classes ' +
		  'ng-class="{ in: isOpen }" ' +
		  '>' +
		'</div>';

	  return {
		compile: function(tElem, tAttrs) {
		  var tooltipLinker = $compile(template);

		  return function link(scope, element, attrs, tooltipCtrl) {
			var tooltip;
			var tooltipLinkedScope;
			var transitionTimeout;
			var showTimeout;
			var hideTimeout;
			var positionTimeout;
			var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
			var triggers = getTriggers(undefined);
			var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
			var ttScope = scope.$new(true);
			var repositionScheduled = false;
			var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
			var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
			var observers = [];
			var lastPlacement;

			var positionTooltip = function() {
			  // check if tooltip exists and is not empty
			  if (!tooltip || !tooltip.html()) { return; }

			  if (!positionTimeout) {
				positionTimeout = $timeout(function() {
				  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
				  var initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
				  var elementPos = appendToBody ? $position.offset(element) : $position.position(element);
				  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });
				  var placementClasses = ttPosition.placement.split('-');

				  if (!tooltip.hasClass(placementClasses[0])) {
					tooltip.removeClass(lastPlacement.split('-')[0]);
					tooltip.addClass(placementClasses[0]);
				  }

				  if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
					tooltip.removeClass(options.placementClassPrefix + lastPlacement);
					tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
				  }

				  $timeout(function() {
					var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
					var adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);
					if (adjustment) {
					  tooltip.css(adjustment);
					}
				  }, 0, false);

				  // first time through tt element will have the
				  // uib-position-measure class or if the placement
				  // has changed we need to position the arrow.
				  if (tooltip.hasClass('uib-position-measure')) {
					$position.positionArrow(tooltip, ttPosition.placement);
					tooltip.removeClass('uib-position-measure');
				  } else if (lastPlacement !== ttPosition.placement) {
					$position.positionArrow(tooltip, ttPosition.placement);
				  }
				  lastPlacement = ttPosition.placement;

				  positionTimeout = null;
				}, 0, false);
			  }
			};

			// Set up the correct scope to allow transclusion later
			ttScope.origScope = scope;

			// By default, the tooltip is not open.
			// TODO add ability to start tooltip opened
			ttScope.isOpen = false;
			openedTooltips.add(ttScope, {
			  close: hide
			});

			function toggleTooltipBind() {
			  if (!ttScope.isOpen) {
				showTooltipBind();
			  } else {
				hideTooltipBind();
			  }
			}

			// Show the tooltip with delay if specified, otherwise show it immediately
			function showTooltipBind() {
			  if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
				return;
			  }

			  cancelHide();
			  prepareTooltip();

			  if (ttScope.popupDelay) {
				// Do nothing if the tooltip was already scheduled to pop-up.
				// This happens if show is triggered multiple times before any hide is triggered.
				if (!showTimeout) {
				  showTimeout = $timeout(show, ttScope.popupDelay, false);
				}
			  } else {
				show();
			  }
			}

			function hideTooltipBind() {
			  cancelShow();

			  if (ttScope.popupCloseDelay) {
				if (!hideTimeout) {
				  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
				}
			  } else {
				hide();
			  }
			}

			// Show the tooltip popup element.
			function show() {
			  cancelShow();
			  cancelHide();

			  // Don't show empty tooltips.
			  if (!ttScope.content) {
				return angular.noop;
			  }

			  createTooltip();

			  // And show the tooltip.
			  ttScope.$evalAsync(function() {
				ttScope.isOpen = true;
				assignIsOpen(true);
				positionTooltip();
			  });
			}

			function cancelShow() {
			  if (showTimeout) {
				$timeout.cancel(showTimeout);
				showTimeout = null;
			  }

			  if (positionTimeout) {
				$timeout.cancel(positionTimeout);
				positionTimeout = null;
			  }
			}

			// Hide the tooltip popup element.
			function hide() {
			  if (!ttScope) {
				return;
			  }

			  // First things first: we don't show it anymore.
			  ttScope.$evalAsync(function() {
				if (ttScope) {
				  ttScope.isOpen = false;
				  assignIsOpen(false);
				  // And now we remove it from the DOM. However, if we have animation, we
				  // need to wait for it to expire beforehand.
				  // FIXME: this is a placeholder for a port of the transitions library.
				  // The fade transition in TWBS is 150ms.
				  if (ttScope.animation) {
					if (!transitionTimeout) {
					  transitionTimeout = $timeout(removeTooltip, 150, false);
					}
				  } else {
					removeTooltip();
				  }
				}
			  });
			}

			function cancelHide() {
			  if (hideTimeout) {
				$timeout.cancel(hideTimeout);
				hideTimeout = null;
			  }

			  if (transitionTimeout) {
				$timeout.cancel(transitionTimeout);
				transitionTimeout = null;
			  }
			}

			function createTooltip() {
			  // There can only be one tooltip element per directive shown at once.
			  if (tooltip) {
				return;
			  }

			  tooltipLinkedScope = ttScope.$new();
			  tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
				if (appendToBody) {
				  $document.find('body').append(tooltip);
				} else {
				  element.after(tooltip);
				}
			  });

			  prepObservers();
			}

			function removeTooltip() {
			  cancelShow();
			  cancelHide();
			  unregisterObservers();

			  if (tooltip) {
				tooltip.remove();
				tooltip = null;
			  }
			  if (tooltipLinkedScope) {
				tooltipLinkedScope.$destroy();
				tooltipLinkedScope = null;
			  }
			}

			/**
			 * Set the initial scope values. Once
			 * the tooltip is created, the observers
			 * will be added to keep things in sync.
			 */
			function prepareTooltip() {
			  ttScope.title = attrs[prefix + 'Title'];
			  if (contentParse) {
				ttScope.content = contentParse(scope);
			  } else {
				ttScope.content = attrs[ttType];
			  }

			  ttScope.popupClass = attrs[prefix + 'Class'];
			  ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
			  var placement = $position.parsePlacement(ttScope.placement);
			  lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];

			  var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
			  var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
			  ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
			  ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
			}

			function assignIsOpen(isOpen) {
			  if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
				isOpenParse.assign(scope, isOpen);
			  }
			}

			ttScope.contentExp = function() {
			  return ttScope.content;
			};

			/**
			 * Observe the relevant attributes.
			 */
			attrs.$observe('disabled', function(val) {
			  if (val) {
				cancelShow();
			  }

			  if (val && ttScope.isOpen) {
				hide();
			  }
			});

			if (isOpenParse) {
			  scope.$watch(isOpenParse, function(val) {
				if (ttScope && !val === ttScope.isOpen) {
				  toggleTooltipBind();
				}
			  });
			}

			function prepObservers() {
			  observers.length = 0;

			  if (contentParse) {
				observers.push(
				  scope.$watch(contentParse, function(val) {
					ttScope.content = val;
					if (!val && ttScope.isOpen) {
					  hide();
					}
				  })
				);

				observers.push(
				  tooltipLinkedScope.$watch(function() {
					if (!repositionScheduled) {
					  repositionScheduled = true;
					  tooltipLinkedScope.$$postDigest(function() {
						repositionScheduled = false;
						if (ttScope && ttScope.isOpen) {
						  positionTooltip();
						}
					  });
					}
				  })
				);
			  } else {
				observers.push(
				  attrs.$observe(ttType, function(val) {
					ttScope.content = val;
					if (!val && ttScope.isOpen) {
					  hide();
					} else {
					  positionTooltip();
					}
				  })
				);
			  }

			  observers.push(
				attrs.$observe(prefix + 'Title', function(val) {
				  ttScope.title = val;
				  if (ttScope.isOpen) {
					positionTooltip();
				  }
				})
			  );

			  observers.push(
				attrs.$observe(prefix + 'Placement', function(val) {
				  ttScope.placement = val ? val : options.placement;
				  if (ttScope.isOpen) {
					positionTooltip();
				  }
				})
			  );
			}

			function unregisterObservers() {
			  if (observers.length) {
				angular.forEach(observers, function(observer) {
				  observer();
				});
				observers.length = 0;
			  }
			}

			// hide tooltips/popovers for outsideClick trigger
			function bodyHideTooltipBind(e) {
			  if (!ttScope || !ttScope.isOpen || !tooltip) {
				return;
			  }
			  // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked
			  if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
				hideTooltipBind();
			  }
			}

			var unregisterTriggers = function() {
			  triggers.show.forEach(function(trigger) {
				if (trigger === 'outsideClick') {
				  element.off('click', toggleTooltipBind);
				} else {
				  element.off(trigger, showTooltipBind);
				  element.off(trigger, toggleTooltipBind);
				}
			  });
			  triggers.hide.forEach(function(trigger) {
				if (trigger === 'outsideClick') {
				  $document.off('click', bodyHideTooltipBind);
				} else {
				  element.off(trigger, hideTooltipBind);
				}
			  });
			};

			function prepTriggers() {
			  var showTriggers = [], hideTriggers = [];
			  var val = scope.$eval(attrs[prefix + 'Trigger']);
			  unregisterTriggers();

			  if (angular.isObject(val)) {
				Object.keys(val).forEach(function(key) {
				  showTriggers.push(key);
				  hideTriggers.push(val[key]);
				});
				triggers = {
				  show: showTriggers,
				  hide: hideTriggers
				};
			  } else {
				triggers = getTriggers(val);
			  }

			  if (triggers.show !== 'none') {
				triggers.show.forEach(function(trigger, idx) {
				  if (trigger === 'outsideClick') {
					element.on('click', toggleTooltipBind);
					$document.on('click', bodyHideTooltipBind);
				  } else if (trigger === triggers.hide[idx]) {
					element.on(trigger, toggleTooltipBind);
				  } else if (trigger) {
					element.on(trigger, showTooltipBind);
					element.on(triggers.hide[idx], hideTooltipBind);
				  }

				  element.on('keypress', function(e) {
					if (e.which === 27) {
					  hideTooltipBind();
					}
				  });
				});
			  }
			}

			prepTriggers();

			var animation = scope.$eval(attrs[prefix + 'Animation']);
			ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

			var appendToBodyVal;
			var appendKey = prefix + 'AppendToBody';
			if (appendKey in attrs && attrs[appendKey] === undefined) {
			  appendToBodyVal = true;
			} else {
			  appendToBodyVal = scope.$eval(attrs[appendKey]);
			}

			appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

			// Make sure tooltip is destroyed and removed.
			scope.$on('$destroy', function onDestroyTooltip() {
			  unregisterTriggers();
			  removeTooltip();
			  openedTooltips.remove(ttScope);
			  ttScope = null;
			});
		  };
		}
	  };
	};
  }];
})

// This is mostly ngInclude code but with a custom scope
.directive('uibTooltipTemplateTransclude', [
		 '$animate', '$sce', '$compile', '$templateRequest',
function ($animate, $sce, $compile, $templateRequest) {
  return {
	link: function(scope, elem, attrs) {
	  var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

	  var changeCounter = 0,
		currentScope,
		previousElement,
		currentElement;

	  var cleanupLastIncludeContent = function() {
		if (previousElement) {
		  previousElement.remove();
		  previousElement = null;
		}

		if (currentScope) {
		  currentScope.$destroy();
		  currentScope = null;
		}

		if (currentElement) {
		  $animate.leave(currentElement).then(function() {
			previousElement = null;
		  });
		  previousElement = currentElement;
		  currentElement = null;
		}
	  };

	  scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
		var thisChangeId = ++changeCounter;

		if (src) {
		  //set the 2nd param to true to ignore the template request error so that the inner
		  //contents and scope can be cleaned up.
		  $templateRequest(src, true).then(function(response) {
			if (thisChangeId !== changeCounter) { return; }
			var newScope = origScope.$new();
			var template = response;

			var clone = $compile(template)(newScope, function(clone) {
			  cleanupLastIncludeContent();
			  $animate.enter(clone, elem);
			});

			currentScope = newScope;
			currentElement = clone;

			currentScope.$emit('$includeContentLoaded', src);
		  }, function() {
			if (thisChangeId === changeCounter) {
			  cleanupLastIncludeContent();
			  scope.$emit('$includeContentError', src);
			}
		  });
		  scope.$emit('$includeContentRequested', src);
		} else {
		  cleanupLastIncludeContent();
		}
	  });

	  scope.$on('$destroy', cleanupLastIncludeContent);
	}
  };
}])

/**
 * Note that it's intentional that these classes are *not* applied through $animate.
 * They must not be animated as they're expected to be present on the tooltip on
 * initialization.
 */
.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {
  return {
	restrict: 'A',
	link: function(scope, element, attrs) {
	  // need to set the primary position so the
	  // arrow has space during position measure.
	  // tooltip.positionTooltip()
	  if (scope.placement) {
		// // There are no top-left etc... classes
		// // in TWBS, so we need the primary position.
		var position = $uibPosition.parsePlacement(scope.placement);
		element.addClass(position[0]);
	  }

	  if (scope.popupClass) {
		element.addClass(scope.popupClass);
	  }

	  if (scope.animation) {
		element.addClass(attrs.tooltipAnimationClass);
	  }
	}
  };
}])

.directive('uibTooltipPopup', function() {
  return {
	restrict: 'A',
	scope: { content: '@' },
	templateUrl: 'uib/template/tooltip/tooltip-popup.html'
  };
})

.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
}])

.directive('uibTooltipTemplatePopup', function() {
  return {
	restrict: 'A',
	scope: { contentExp: '&', originScope: '&' },
	templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
  };
})

.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
	useContentExp: true
  });
}])

.directive('uibTooltipHtmlPopup', function() {
  return {
	restrict: 'A',
	scope: { contentExp: '&' },
	templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
  };
})

.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
	useContentExp: true
  });
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, and selector delegatation.
 */
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])

.directive('uibPopoverTemplatePopup', function() {
  return {
	restrict: 'A',
	scope: { uibTitle: '@', contentExp: '&', originScope: '&' },
	templateUrl: 'uib/template/popover/popover-template.html'
  };
})

.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
	useContentExp: true
  });
}])

.directive('uibPopoverHtmlPopup', function() {
  return {
	restrict: 'A',
	scope: { contentExp: '&', uibTitle: '@' },
	templateUrl: 'uib/template/popover/popover-html.html'
  };
})

.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
	useContentExp: true
  });
}])

.directive('uibPopoverPopup', function() {
  return {
	restrict: 'A',
	scope: { uibTitle: '@', content: '@' },
	templateUrl: 'uib/template/popover/popover.html'
  };
})

.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopover', 'popover', 'click');
}]);

angular.module('ui.bootstrap.progressbar', [])

.constant('uibProgressConfig', {
  animate: true,
  max: 100
})

.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
  var self = this,
	  animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

  this.bars = [];
  $scope.max = getMaxOrDefault();

  this.addBar = function(bar, element, attrs) {
	if (!animate) {
	  element.css({'transition': 'none'});
	}

	this.bars.push(bar);

	bar.max = getMaxOrDefault();
	bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';

	bar.$watch('value', function(value) {
	  bar.recalculatePercentage();
	});

	bar.recalculatePercentage = function() {
	  var totalPercentage = self.bars.reduce(function(total, bar) {
		bar.percent = +(100 * bar.value / bar.max).toFixed(2);
		return total + bar.percent;
	  }, 0);

	  if (totalPercentage > 100) {
		bar.percent -= totalPercentage - 100;
	  }
	};

	bar.$on('$destroy', function() {
	  element = null;
	  self.removeBar(bar);
	});
  };

  this.removeBar = function(bar) {
	this.bars.splice(this.bars.indexOf(bar), 1);
	this.bars.forEach(function (bar) {
	  bar.recalculatePercentage();
	});
  };

  //$attrs.$observe('maxParam', function(maxParam) {
  $scope.$watch('maxParam', function(maxParam) {
	self.bars.forEach(function(bar) {
	  bar.max = getMaxOrDefault();
	  bar.recalculatePercentage();
	});
  });

  function getMaxOrDefault () {
	return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
  }
}])

.directive('uibProgress', function() {
  return {
	replace: true,
	transclude: true,
	controller: 'UibProgressController',
	require: 'uibProgress',
	scope: {
	  maxParam: '=?max'
	},
	templateUrl: 'uib/template/progressbar/progress.html'
  };
})

.directive('uibBar', function() {
  return {
	replace: true,
	transclude: true,
	require: '^uibProgress',
	scope: {
	  value: '=',
	  type: '@'
	},
	templateUrl: 'uib/template/progressbar/bar.html',
	link: function(scope, element, attrs, progressCtrl) {
	  progressCtrl.addBar(scope, element, attrs);
	}
  };
})

.directive('uibProgressbar', function() {
  return {
	replace: true,
	transclude: true,
	controller: 'UibProgressController',
	scope: {
	  value: '=',
	  maxParam: '=?max',
	  type: '@'
	},
	templateUrl: 'uib/template/progressbar/progressbar.html',
	link: function(scope, element, attrs, progressCtrl) {
	  progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
	}
  };
});

angular.module('ui.bootstrap.rating', [])

.constant('uibRatingConfig', {
  max: 5,
  stateOn: null,
  stateOff: null,
  enableReset: true,
  titles: ['one', 'two', 'three', 'four', 'five']
})

.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
  var ngModelCtrl = { $setViewValue: angular.noop },
	self = this;

  this.init = function(ngModelCtrl_) {
	ngModelCtrl = ngModelCtrl_;
	ngModelCtrl.$render = this.render;

	ngModelCtrl.$formatters.push(function(value) {
	  if (angular.isNumber(value) && value << 0 !== value) {
		value = Math.round(value);
	  }

	  return value;
	});

	this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
	this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
	this.enableReset = angular.isDefined($attrs.enableReset) ?
	  $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
	var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
	this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
	  tmpTitles : ratingConfig.titles;

	var ratingStates = angular.isDefined($attrs.ratingStates) ?
	  $scope.$parent.$eval($attrs.ratingStates) :
	  new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
	$scope.range = this.buildTemplateObjects(ratingStates);
  };

  this.buildTemplateObjects = function(states) {
	for (var i = 0, n = states.length; i < n; i++) {
	  states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
	}
	return states;
  };

  this.getTitle = function(index) {
	if (index >= this.titles.length) {
	  return index + 1;
	}

	return this.titles[index];
  };

  $scope.rate = function(value) {
	if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
	  var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
	  ngModelCtrl.$setViewValue(newViewValue);
	  ngModelCtrl.$render();
	}
  };

  $scope.enter = function(value) {
	if (!$scope.readonly) {
	  $scope.value = value;
	}
	$scope.onHover({value: value});
  };

  $scope.reset = function() {
	$scope.value = ngModelCtrl.$viewValue;
	$scope.onLeave();
  };

  $scope.onKeydown = function(evt) {
	if (/(37|38|39|40)/.test(evt.which)) {
	  evt.preventDefault();
	  evt.stopPropagation();
	  $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
	}
  };

  this.render = function() {
	$scope.value = ngModelCtrl.$viewValue;
	$scope.title = self.getTitle($scope.value - 1);
  };
}])

.directive('uibRating', function() {
  return {
	require: ['uibRating', 'ngModel'],
	restrict: 'A',
	scope: {
	  readonly: '=?readOnly',
	  onHover: '&',
	  onLeave: '&'
	},
	controller: 'UibRatingController',
	templateUrl: 'uib/template/rating/rating.html',
	link: function(scope, element, attrs, ctrls) {
	  var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	  ratingCtrl.init(ngModelCtrl);
	}
  };
});

angular.module('ui.bootstrap.tabs', [])

.controller('UibTabsetController', ['$scope', function ($scope) {
  var ctrl = this,
	oldIndex;
  ctrl.tabs = [];

  ctrl.select = function(index, evt) {
	if (!destroyed) {
	  var previousIndex = findTabIndex(oldIndex);
	  var previousSelected = ctrl.tabs[previousIndex];
	  if (previousSelected) {
		previousSelected.tab.onDeselect({
		  $event: evt,
		  $selectedIndex: index
		});
		if (evt && evt.isDefaultPrevented()) {
		  return;
		}
		previousSelected.tab.active = false;
	  }

	  var selected = ctrl.tabs[index];
	  if (selected) {
		selected.tab.onSelect({
		  $event: evt
		});
		selected.tab.active = true;
		ctrl.active = selected.index;
		oldIndex = selected.index;
	  } else if (!selected && angular.isDefined(oldIndex)) {
		ctrl.active = null;
		oldIndex = null;
	  }
	}
  };

  ctrl.addTab = function addTab(tab) {
	ctrl.tabs.push({
	  tab: tab,
	  index: tab.index
	});
	ctrl.tabs.sort(function(t1, t2) {
	  if (t1.index > t2.index) {
		return 1;
	  }

	  if (t1.index < t2.index) {
		return -1;
	  }

	  return 0;
	});

	if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {
	  var newActiveIndex = findTabIndex(tab.index);
	  ctrl.select(newActiveIndex);
	}
  };

  ctrl.removeTab = function removeTab(tab) {
	var index;
	for (var i = 0; i < ctrl.tabs.length; i++) {
	  if (ctrl.tabs[i].tab === tab) {
		index = i;
		break;
	  }
	}

	if (ctrl.tabs[index].index === ctrl.active) {
	  var newActiveTabIndex = index === ctrl.tabs.length - 1 ?
		index - 1 : index + 1 % ctrl.tabs.length;
	  ctrl.select(newActiveTabIndex);
	}

	ctrl.tabs.splice(index, 1);
  };

  $scope.$watch('tabset.active', function(val) {
	if (angular.isDefined(val) && val !== oldIndex) {
	  ctrl.select(findTabIndex(val));
	}
  });

  var destroyed;
  $scope.$on('$destroy', function() {
	destroyed = true;
  });

  function findTabIndex(index) {
	for (var i = 0; i < ctrl.tabs.length; i++) {
	  if (ctrl.tabs[i].index === index) {
		return i;
	  }
	}
  }
}])

.directive('uibTabset', function() {
  return {
	transclude: true,
	replace: true,
	scope: {},
	bindToController: {
	  active: '=?',
	  type: '@'
	},
	controller: 'UibTabsetController',
	controllerAs: 'tabset',
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || 'uib/template/tabs/tabset.html';
	},
	link: function(scope, element, attrs) {
	  scope.vertical = angular.isDefined(attrs.vertical) ?
		scope.$parent.$eval(attrs.vertical) : false;
	  scope.justified = angular.isDefined(attrs.justified) ?
		scope.$parent.$eval(attrs.justified) : false;
	}
  };
})

.directive('uibTab', ['$parse', function($parse) {
  return {
	require: '^uibTabset',
	replace: true,
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || 'uib/template/tabs/tab.html';
	},
	transclude: true,
	scope: {
	  heading: '@',
	  index: '=?',
	  classes: '@?',
	  onSelect: '&select', //This callback is called in contentHeadingTransclude
						  //once it inserts the tab's content into the dom
	  onDeselect: '&deselect'
	},
	controller: function() {
	  //Empty controller so other directives can require being 'under' a tab
	},
	controllerAs: 'tab',
	link: function(scope, elm, attrs, tabsetCtrl, transclude) {
	  scope.disabled = false;
	  if (attrs.disable) {
		scope.$parent.$watch($parse(attrs.disable), function(value) {
		  scope.disabled = !! value;
		});
	  }

	  if (angular.isUndefined(attrs.index)) {
		if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
		  scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) { return t.index; })) + 1;
		} else {
		  scope.index = 0;
		}
	  }

	  if (angular.isUndefined(attrs.classes)) {
		scope.classes = '';
	  }

	  scope.select = function(evt) {
		if (!scope.disabled) {
		  var index;
		  for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
			if (tabsetCtrl.tabs[i].tab === scope) {
			  index = i;
			  break;
			}
		  }

		  tabsetCtrl.select(index, evt);
		}
	  };

	  tabsetCtrl.addTab(scope);
	  scope.$on('$destroy', function() {
		tabsetCtrl.removeTab(scope);
	  });

	  //We need to transclude later, once the content container is ready.
	  //when this link happens, we're inside a tab heading.
	  scope.$transcludeFn = transclude;
	}
  };
}])

.directive('uibTabHeadingTransclude', function() {
  return {
	restrict: 'A',
	require: '^uibTab',
	link: function(scope, elm) {
	  scope.$watch('headingElement', function updateHeadingElement(heading) {
		if (heading) {
		  elm.html('');
		  elm.append(heading);
		}
	  });
	}
  };
})

.directive('uibTabContentTransclude', function() {
  return {
	restrict: 'A',
	require: '^uibTabset',
	link: function(scope, elm, attrs) {
	  var tab = scope.$eval(attrs.uibTabContentTransclude).tab;

	  //Now our tab is ready to be transcluded: both the tab heading area
	  //and the tab content area are loaded.  Transclude 'em both.
	  tab.$transcludeFn(tab.$parent, function(contents) {
		angular.forEach(contents, function(node) {
		  if (isTabHeading(node)) {
			//Let tabHeadingTransclude know.
			tab.headingElement = node;
		  } else {
			elm.append(node);
		  }
		});
	  });
	}
  };

  function isTabHeading(node) {
	return node.tagName && (
	  node.hasAttribute('uib-tab-heading') ||
	  node.hasAttribute('data-uib-tab-heading') ||
	  node.hasAttribute('x-uib-tab-heading') ||
	  node.tagName.toLowerCase() === 'uib-tab-heading' ||
	  node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
	  node.tagName.toLowerCase() === 'x-uib-tab-heading' ||
	  node.tagName.toLowerCase() === 'uib:tab-heading'
	);
  }
});

angular.module('ui.bootstrap.timepicker', [])

.constant('uibTimepickerConfig', {
  hourStep: 1,
  minuteStep: 1,
  secondStep: 1,
  showMeridian: true,
  showSeconds: false,
  meridians: null,
  readonlyInput: false,
  mousewheel: true,
  arrowkeys: true,
  showSpinners: true,
  templateUrl: 'uib/template/timepicker/timepicker.html'
})

.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
  var selected = new Date(),
	watchers = [],
	ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
	meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,
	padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;

  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
  $element.removeAttr('tabindex');

  this.init = function(ngModelCtrl_, inputs) {
	ngModelCtrl = ngModelCtrl_;
	ngModelCtrl.$render = this.render;

	ngModelCtrl.$formatters.unshift(function(modelValue) {
	  return modelValue ? new Date(modelValue) : null;
	});

	var hoursInputEl = inputs.eq(0),
		minutesInputEl = inputs.eq(1),
		secondsInputEl = inputs.eq(2);

	var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;

	if (mousewheel) {
	  this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
	}

	var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
	if (arrowkeys) {
	  this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
	}

	$scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
	this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
  };

  var hourStep = timepickerConfig.hourStep;
  if ($attrs.hourStep) {
	watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {
	  hourStep = +value;
	}));
  }

  var minuteStep = timepickerConfig.minuteStep;
  if ($attrs.minuteStep) {
	watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
	  minuteStep = +value;
	}));
  }

  var min;
  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {
	var dt = new Date(value);
	min = isNaN(dt) ? undefined : dt;
  }));

  var max;
  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {
	var dt = new Date(value);
	max = isNaN(dt) ? undefined : dt;
  }));

  var disabled = false;
  if ($attrs.ngDisabled) {
	watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {
	  disabled = value;
	}));
  }

  $scope.noIncrementHours = function() {
	var incrementedSelected = addMinutes(selected, hourStep * 60);
	return disabled || incrementedSelected > max ||
	  incrementedSelected < selected && incrementedSelected < min;
  };

  $scope.noDecrementHours = function() {
	var decrementedSelected = addMinutes(selected, -hourStep * 60);
	return disabled || decrementedSelected < min ||
	  decrementedSelected > selected && decrementedSelected > max;
  };

  $scope.noIncrementMinutes = function() {
	var incrementedSelected = addMinutes(selected, minuteStep);
	return disabled || incrementedSelected > max ||
	  incrementedSelected < selected && incrementedSelected < min;
  };

  $scope.noDecrementMinutes = function() {
	var decrementedSelected = addMinutes(selected, -minuteStep);
	return disabled || decrementedSelected < min ||
	  decrementedSelected > selected && decrementedSelected > max;
  };

  $scope.noIncrementSeconds = function() {
	var incrementedSelected = addSeconds(selected, secondStep);
	return disabled || incrementedSelected > max ||
	  incrementedSelected < selected && incrementedSelected < min;
  };

  $scope.noDecrementSeconds = function() {
	var decrementedSelected = addSeconds(selected, -secondStep);
	return disabled || decrementedSelected < min ||
	  decrementedSelected > selected && decrementedSelected > max;
  };

  $scope.noToggleMeridian = function() {
	if (selected.getHours() < 12) {
	  return disabled || addMinutes(selected, 12 * 60) > max;
	}

	return disabled || addMinutes(selected, -12 * 60) < min;
  };

  var secondStep = timepickerConfig.secondStep;
  if ($attrs.secondStep) {
	watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {
	  secondStep = +value;
	}));
  }

  $scope.showSeconds = timepickerConfig.showSeconds;
  if ($attrs.showSeconds) {
	watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {
	  $scope.showSeconds = !!value;
	}));
  }

  // 12H / 24H mode
  $scope.showMeridian = timepickerConfig.showMeridian;
  if ($attrs.showMeridian) {
	watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
	  $scope.showMeridian = !!value;

	  if (ngModelCtrl.$error.time) {
		// Evaluate from template
		var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
		if (angular.isDefined(hours) && angular.isDefined(minutes)) {
		  selected.setHours(hours);
		  refresh();
		}
	  } else {
		updateTemplate();
	  }
	}));
  }

  // Get $scope.hours in 24H mode if valid
  function getHoursFromTemplate() {
	var hours = +$scope.hours;
	var valid = $scope.showMeridian ? hours > 0 && hours < 13 :
	  hours >= 0 && hours < 24;
	if (!valid || $scope.hours === '') {
	  return undefined;
	}

	if ($scope.showMeridian) {
	  if (hours === 12) {
		hours = 0;
	  }
	  if ($scope.meridian === meridians[1]) {
		hours = hours + 12;
	  }
	}
	return hours;
  }

  function getMinutesFromTemplate() {
	var minutes = +$scope.minutes;
	var valid = minutes >= 0 && minutes < 60;
	if (!valid || $scope.minutes === '') {
	  return undefined;
	}
	return minutes;
  }

  function getSecondsFromTemplate() {
	var seconds = +$scope.seconds;
	return seconds >= 0 && seconds < 60 ? seconds : undefined;
  }

  function pad(value, noPad) {
	if (value === null) {
	  return '';
	}

	return angular.isDefined(value) && value.toString().length < 2 && !noPad ?
	  '0' + value : value.toString();
  }

  // Respond on mousewheel spin
  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
	var isScrollingUp = function(e) {
	  if (e.originalEvent) {
		e = e.originalEvent;
	  }
	  //pick correct delta variable depending on event
	  var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
	  return e.detail || delta > 0;
	};

	hoursInputEl.bind('mousewheel wheel', function(e) {
	  if (!disabled) {
		$scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
	  }
	  e.preventDefault();
	});

	minutesInputEl.bind('mousewheel wheel', function(e) {
	  if (!disabled) {
		$scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
	  }
	  e.preventDefault();
	});

	 secondsInputEl.bind('mousewheel wheel', function(e) {
	  if (!disabled) {
		$scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
	  }
	  e.preventDefault();
	});
  };

  // Respond on up/down arrowkeys
  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
	hoursInputEl.bind('keydown', function(e) {
	  if (!disabled) {
		if (e.which === 38) { // up
		  e.preventDefault();
		  $scope.incrementHours();
		  $scope.$apply();
		} else if (e.which === 40) { // down
		  e.preventDefault();
		  $scope.decrementHours();
		  $scope.$apply();
		}
	  }
	});

	minutesInputEl.bind('keydown', function(e) {
	  if (!disabled) {
		if (e.which === 38) { // up
		  e.preventDefault();
		  $scope.incrementMinutes();
		  $scope.$apply();
		} else if (e.which === 40) { // down
		  e.preventDefault();
		  $scope.decrementMinutes();
		  $scope.$apply();
		}
	  }
	});

	secondsInputEl.bind('keydown', function(e) {
	  if (!disabled) {
		if (e.which === 38) { // up
		  e.preventDefault();
		  $scope.incrementSeconds();
		  $scope.$apply();
		} else if (e.which === 40) { // down
		  e.preventDefault();
		  $scope.decrementSeconds();
		  $scope.$apply();
		}
	  }
	});
  };

  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
	if ($scope.readonlyInput) {
	  $scope.updateHours = angular.noop;
	  $scope.updateMinutes = angular.noop;
	  $scope.updateSeconds = angular.noop;
	  return;
	}

	var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {
	  ngModelCtrl.$setViewValue(null);
	  ngModelCtrl.$setValidity('time', false);
	  if (angular.isDefined(invalidHours)) {
		$scope.invalidHours = invalidHours;
	  }

	  if (angular.isDefined(invalidMinutes)) {
		$scope.invalidMinutes = invalidMinutes;
	  }

	  if (angular.isDefined(invalidSeconds)) {
		$scope.invalidSeconds = invalidSeconds;
	  }
	};

	$scope.updateHours = function() {
	  var hours = getHoursFromTemplate(),
		minutes = getMinutesFromTemplate();

	  ngModelCtrl.$setDirty();

	  if (angular.isDefined(hours) && angular.isDefined(minutes)) {
		selected.setHours(hours);
		selected.setMinutes(minutes);
		if (selected < min || selected > max) {
		  invalidate(true);
		} else {
		  refresh('h');
		}
	  } else {
		invalidate(true);
	  }
	};

	hoursInputEl.bind('blur', function(e) {
	  ngModelCtrl.$setTouched();
	  if (modelIsEmpty()) {
		makeValid();
	  } else if ($scope.hours === null || $scope.hours === '') {
		invalidate(true);
	  } else if (!$scope.invalidHours && $scope.hours < 10) {
		$scope.$apply(function() {
		  $scope.hours = pad($scope.hours, !padHours);
		});
	  }
	});

	$scope.updateMinutes = function() {
	  var minutes = getMinutesFromTemplate(),
		hours = getHoursFromTemplate();

	  ngModelCtrl.$setDirty();

	  if (angular.isDefined(minutes) && angular.isDefined(hours)) {
		selected.setHours(hours);
		selected.setMinutes(minutes);
		if (selected < min || selected > max) {
		  invalidate(undefined, true);
		} else {
		  refresh('m');
		}
	  } else {
		invalidate(undefined, true);
	  }
	};

	minutesInputEl.bind('blur', function(e) {
	  ngModelCtrl.$setTouched();
	  if (modelIsEmpty()) {
		makeValid();
	  } else if ($scope.minutes === null) {
		invalidate(undefined, true);
	  } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
		$scope.$apply(function() {
		  $scope.minutes = pad($scope.minutes);
		});
	  }
	});

	$scope.updateSeconds = function() {
	  var seconds = getSecondsFromTemplate();

	  ngModelCtrl.$setDirty();

	  if (angular.isDefined(seconds)) {
		selected.setSeconds(seconds);
		refresh('s');
	  } else {
		invalidate(undefined, undefined, true);
	  }
	};

	secondsInputEl.bind('blur', function(e) {
	  if (modelIsEmpty()) {
		makeValid();
	  } else if (!$scope.invalidSeconds && $scope.seconds < 10) {
		$scope.$apply( function() {
		  $scope.seconds = pad($scope.seconds);
		});
	  }
	});

  };

  this.render = function() {
	var date = ngModelCtrl.$viewValue;

	if (isNaN(date)) {
	  ngModelCtrl.$setValidity('time', false);
	  $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
	} else {
	  if (date) {
		selected = date;
	  }

	  if (selected < min || selected > max) {
		ngModelCtrl.$setValidity('time', false);
		$scope.invalidHours = true;
		$scope.invalidMinutes = true;
	  } else {
		makeValid();
	  }
	  updateTemplate();
	}
  };

  // Call internally when we know that model is valid.
  function refresh(keyboardChange) {
	makeValid();
	ngModelCtrl.$setViewValue(new Date(selected));
	updateTemplate(keyboardChange);
  }

  function makeValid() {
	ngModelCtrl.$setValidity('time', true);
	$scope.invalidHours = false;
	$scope.invalidMinutes = false;
	$scope.invalidSeconds = false;
  }

  function updateTemplate(keyboardChange) {
	if (!ngModelCtrl.$modelValue) {
	  $scope.hours = null;
	  $scope.minutes = null;
	  $scope.seconds = null;
	  $scope.meridian = meridians[0];
	} else {
	  var hours = selected.getHours(),
		minutes = selected.getMinutes(),
		seconds = selected.getSeconds();

	  if ($scope.showMeridian) {
		hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system
	  }

	  $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
	  if (keyboardChange !== 'm') {
		$scope.minutes = pad(minutes);
	  }
	  $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];

	  if (keyboardChange !== 's') {
		$scope.seconds = pad(seconds);
	  }
	  $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
	}
  }

  function addSecondsToSelected(seconds) {
	selected = addSeconds(selected, seconds);
	refresh();
  }

  function addMinutes(selected, minutes) {
	return addSeconds(selected, minutes*60);
  }

  function addSeconds(date, seconds) {
	var dt = new Date(date.getTime() + seconds * 1000);
	var newDate = new Date(date);
	newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
	return newDate;
  }

  function modelIsEmpty() {
	return ($scope.hours === null || $scope.hours === '') &&
	  ($scope.minutes === null || $scope.minutes === '') &&
	  (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));
  }

  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
	$scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;

  $scope.incrementHours = function() {
	if (!$scope.noIncrementHours()) {
	  addSecondsToSelected(hourStep * 60 * 60);
	}
  };

  $scope.decrementHours = function() {
	if (!$scope.noDecrementHours()) {
	  addSecondsToSelected(-hourStep * 60 * 60);
	}
  };

  $scope.incrementMinutes = function() {
	if (!$scope.noIncrementMinutes()) {
	  addSecondsToSelected(minuteStep * 60);
	}
  };

  $scope.decrementMinutes = function() {
	if (!$scope.noDecrementMinutes()) {
	  addSecondsToSelected(-minuteStep * 60);
	}
  };

  $scope.incrementSeconds = function() {
	if (!$scope.noIncrementSeconds()) {
	  addSecondsToSelected(secondStep);
	}
  };

  $scope.decrementSeconds = function() {
	if (!$scope.noDecrementSeconds()) {
	  addSecondsToSelected(-secondStep);
	}
  };

  $scope.toggleMeridian = function() {
	var minutes = getMinutesFromTemplate(),
		hours = getHoursFromTemplate();

	if (!$scope.noToggleMeridian()) {
	  if (angular.isDefined(minutes) && angular.isDefined(hours)) {
		addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
	  } else {
		$scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
	  }
	}
  };

  $scope.blur = function() {
	ngModelCtrl.$setTouched();
  };

  $scope.$on('$destroy', function() {
	while (watchers.length) {
	  watchers.shift()();
	}
  });
}])

.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {
  return {
	require: ['uibTimepicker', '?^ngModel'],
	restrict: 'A',
	controller: 'UibTimepickerController',
	controllerAs: 'timepicker',
	scope: {},
	templateUrl: function(element, attrs) {
	  return attrs.templateUrl || uibTimepickerConfig.templateUrl;
	},
	link: function(scope, element, attrs, ctrls) {
	  var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

	  if (ngModelCtrl) {
		timepickerCtrl.init(ngModelCtrl, element.find('input'));
	  }
	}
  };
}]);

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])

/**
 * A helper service that can parse typeahead's syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory('uibTypeaheadParser', ['$parse', function($parse) {
	//                      00000111000000000000022200000000000000003333333333333330000000000044000
	var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
	return {
	  parse: function(input) {
		var match = input.match(TYPEAHEAD_REGEXP);
		if (!match) {
		  throw new Error(
			'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
			  ' but got "' + input + '".');
		}

		return {
		  itemName: match[3],
		  source: $parse(match[4]),
		  viewMapper: $parse(match[2] || match[1]),
		  modelMapper: $parse(match[1])
		};
	  }
	};
  }])

  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',
	function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
	var HOT_KEYS = [9, 13, 27, 38, 40];
	var eventDebounceTime = 200;
	var modelCtrl, ngModelOptions;
	//SUPPORTED ATTRIBUTES (OPTIONS)

	//minimal no of characters that needs to be entered before typeahead kicks-in
	var minLength = originalScope.$eval(attrs.typeaheadMinLength);
	if (!minLength && minLength !== 0) {
	  minLength = 1;
	}

	originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {
		minLength = !newVal && newVal !== 0 ? 1 : newVal;
	});

	//minimal wait time after last character typed before typeahead kicks-in
	var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

	//should it restrict model values to the ones selected from the popup only?
	var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
	originalScope.$watch(attrs.typeaheadEditable, function (newVal) {
	  isEditable = newVal !== false;
	});

	//binding to a variable that indicates if matches are being retrieved asynchronously
	var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

	//a function to determine if an event should cause selection
	var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {
	  var evt = vals.$event;
	  return evt.which === 13 || evt.which === 9;
	};

	//a callback executed when a match is selected
	var onSelectCallback = $parse(attrs.typeaheadOnSelect);

	//should it select highlighted popup value when losing focus?
	var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

	//binding to a variable that indicates if there were no results after the query is completed
	var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

	var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

	var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

	var appendTo = attrs.typeaheadAppendTo ?
	  originalScope.$eval(attrs.typeaheadAppendTo) : null;

	var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

	//If input matches an item of the list exactly, select it automatically
	var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

	//binding to a variable that indicates if dropdown is open
	var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;

	var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;

	//INTERNAL VARIABLES

	//model setter executed upon match selection
	var parsedModel = $parse(attrs.ngModel);
	var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
	var $setModelValue = function(scope, newValue) {
	  if (angular.isFunction(parsedModel(originalScope)) &&
		ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
		return invokeModelSetter(scope, {$$$p: newValue});
	  }

	  return parsedModel.assign(scope, newValue);
	};

	//expressions used by typeahead
	var parserResult = typeaheadParser.parse(attrs.uibTypeahead);

	var hasFocus;

	//Used to avoid bug in iOS webview where iOS keyboard does not fire
	//mousedown & mouseup events
	//Issue #3699
	var selected;

	//create a child scope for the typeahead directive so we are not polluting original scope
	//with typeahead-specific data (matches, query etc.)
	var scope = originalScope.$new();
	var offDestroy = originalScope.$on('$destroy', function() {
	  scope.$destroy();
	});
	scope.$on('$destroy', offDestroy);

	// WAI-ARIA
	var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
	element.attr({
	  'aria-autocomplete': 'list',
	  'aria-expanded': false,
	  'aria-owns': popupId
	});

	var inputsContainer, hintInputElem;
	//add read-only input to show hint
	if (showHint) {
	  inputsContainer = angular.element('<div></div>');
	  inputsContainer.css('position', 'relative');
	  element.after(inputsContainer);
	  hintInputElem = element.clone();
	  hintInputElem.attr('placeholder', '');
	  hintInputElem.attr('tabindex', '-1');
	  hintInputElem.val('');
	  hintInputElem.css({
		'position': 'absolute',
		'top': '0px',
		'left': '0px',
		'border-color': 'transparent',
		'box-shadow': 'none',
		'opacity': 1,
		'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
		'color': '#999'
	  });
	  element.css({
		'position': 'relative',
		'vertical-align': 'top',
		'background-color': 'transparent'
	  });

	  if (hintInputElem.attr('id')) {
		hintInputElem.removeAttr('id'); // remove duplicate id if present.
	  }
	  inputsContainer.append(hintInputElem);
	  hintInputElem.after(element);
	}

	//pop-up element used to display matches
	var popUpEl = angular.element('<div uib-typeahead-popup></div>');
	popUpEl.attr({
	  id: popupId,
	  matches: 'matches',
	  active: 'activeIdx',
	  select: 'select(activeIdx, evt)',
	  'move-in-progress': 'moveInProgress',
	  query: 'query',
	  position: 'position',
	  'assign-is-open': 'assignIsOpen(isOpen)',
	  debounce: 'debounceUpdate'
	});
	//custom item template
	if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
	  popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
	}

	if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
	  popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
	}

	var resetHint = function() {
	  if (showHint) {
		hintInputElem.val('');
	  }
	};

	var resetMatches = function() {
	  scope.matches = [];
	  scope.activeIdx = -1;
	  element.attr('aria-expanded', false);
	  resetHint();
	};

	var getMatchId = function(index) {
	  return popupId + '-option-' + index;
	};

	// Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
	// This attribute is added or removed automatically when the `activeIdx` changes.
	scope.$watch('activeIdx', function(index) {
	  if (index < 0) {
		element.removeAttr('aria-activedescendant');
	  } else {
		element.attr('aria-activedescendant', getMatchId(index));
	  }
	});

	var inputIsExactMatch = function(inputValue, index) {
	  if (scope.matches.length > index && inputValue) {
		return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
	  }

	  return false;
	};

	var getMatchesAsync = function(inputValue, evt) {
	  var locals = {$viewValue: inputValue};
	  isLoadingSetter(originalScope, true);
	  isNoResultsSetter(originalScope, false);
	  $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
		//it might happen that several async queries were in progress if a user were typing fast
		//but we are interested only in responses that correspond to the current view value
		var onCurrentRequest = inputValue === modelCtrl.$viewValue;
		if (onCurrentRequest && hasFocus) {
		  if (matches && matches.length > 0) {
			scope.activeIdx = focusFirst ? 0 : -1;
			isNoResultsSetter(originalScope, false);
			scope.matches.length = 0;

			//transform labels
			for (var i = 0; i < matches.length; i++) {
			  locals[parserResult.itemName] = matches[i];
			  scope.matches.push({
				id: getMatchId(i),
				label: parserResult.viewMapper(scope, locals),
				model: matches[i]
			  });
			}

			scope.query = inputValue;
			//position pop-up with matches - we need to re-calculate its position each time we are opening a window
			//with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
			//due to other elements being rendered
			recalculatePosition();

			element.attr('aria-expanded', true);

			//Select the single remaining option if user input matches
			if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
			  if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
				$$debounce(function() {
				  scope.select(0, evt);
				}, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
			  } else {
				scope.select(0, evt);
			  }
			}

			if (showHint) {
			  var firstLabel = scope.matches[0].label;
			  if (angular.isString(inputValue) &&
				inputValue.length > 0 &&
				firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
				hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
			  } else {
				hintInputElem.val('');
			  }
			}
		  } else {
			resetMatches();
			isNoResultsSetter(originalScope, true);
		  }
		}
		if (onCurrentRequest) {
		  isLoadingSetter(originalScope, false);
		}
	  }, function() {
		resetMatches();
		isLoadingSetter(originalScope, false);
		isNoResultsSetter(originalScope, true);
	  });
	};

	// bind events only if appendToBody params exist - performance feature
	if (appendToBody) {
	  angular.element($window).on('resize', fireRecalculating);
	  $document.find('body').on('scroll', fireRecalculating);
	}

	// Declare the debounced function outside recalculating for
	// proper debouncing
	var debouncedRecalculate = $$debounce(function() {
	  // if popup is visible
	  if (scope.matches.length) {
		recalculatePosition();
	  }

	  scope.moveInProgress = false;
	}, eventDebounceTime);

	// Default progress type
	scope.moveInProgress = false;

	function fireRecalculating() {
	  if (!scope.moveInProgress) {
		scope.moveInProgress = true;
		scope.$digest();
	  }

	  debouncedRecalculate();
	}

	// recalculate actual position and set new values to scope
	// after digest loop is popup in right position
	function recalculatePosition() {
	  scope.position = appendToBody ? $position.offset(element) : $position.position(element);
	  scope.position.top += element.prop('offsetHeight');
	}

	//we need to propagate user's query so we can higlight matches
	scope.query = undefined;

	//Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
	var timeoutPromise;

	var scheduleSearchWithTimeout = function(inputValue) {
	  timeoutPromise = $timeout(function() {
		getMatchesAsync(inputValue);
	  }, waitTime);
	};

	var cancelPreviousTimeout = function() {
	  if (timeoutPromise) {
		$timeout.cancel(timeoutPromise);
	  }
	};

	resetMatches();

	scope.assignIsOpen = function (isOpen) {
	  isOpenSetter(originalScope, isOpen);
	};

	scope.select = function(activeIdx, evt) {
	  //called from within the $digest() cycle
	  var locals = {};
	  var model, item;

	  selected = true;
	  locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
	  model = parserResult.modelMapper(originalScope, locals);
	  $setModelValue(originalScope, model);
	  modelCtrl.$setValidity('editable', true);
	  modelCtrl.$setValidity('parse', true);

	  onSelectCallback(originalScope, {
		$item: item,
		$model: model,
		$label: parserResult.viewMapper(originalScope, locals),
		$event: evt
	  });

	  resetMatches();

	  //return focus to the input element if a match was selected via a mouse click event
	  // use timeout to avoid $rootScope:inprog error
	  if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
		$timeout(function() { element[0].focus(); }, 0, false);
	  }
	};

	//bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
	element.on('keydown', function(evt) {
	  //typeahead is open and an "interesting" key was pressed
	  if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
		return;
	  }

	  var shouldSelect = isSelectEvent(originalScope, {$event: evt});

	  /**
	   * if there's nothing selected (i.e. focusFirst) and enter or tab is hit
	   * or
	   * shift + tab is pressed to bring focus to the previous element
	   * then clear the results
	   */
	  if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {
		resetMatches();
		scope.$digest();
		return;
	  }

	  evt.preventDefault();
	  var target;
	  switch (evt.which) {
		case 27: // escape
		  evt.stopPropagation();

		  resetMatches();
		  originalScope.$digest();
		  break;
		case 38: // up arrow
		  scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
		  scope.$digest();
		  target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
		  target.parentNode.scrollTop = target.offsetTop;
		  break;
		case 40: // down arrow
		  scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
		  scope.$digest();
		  target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
		  target.parentNode.scrollTop = target.offsetTop;
		  break;
		default:
		  if (shouldSelect) {
			scope.$apply(function() {
			  if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
				$$debounce(function() {
				  scope.select(scope.activeIdx, evt);
				}, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
			  } else {
				scope.select(scope.activeIdx, evt);
			  }
			});
		  }
	  }
	});

	element.bind('focus', function (evt) {
	  hasFocus = true;
	  if (minLength === 0 && !modelCtrl.$viewValue) {
		$timeout(function() {
		  getMatchesAsync(modelCtrl.$viewValue, evt);
		}, 0);
	  }
	});

	element.bind('blur', function(evt) {
	  if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
		selected = true;
		scope.$apply(function() {
		  if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
			$$debounce(function() {
			  scope.select(scope.activeIdx, evt);
			}, scope.debounceUpdate.blur);
		  } else {
			scope.select(scope.activeIdx, evt);
		  }
		});
	  }
	  if (!isEditable && modelCtrl.$error.editable) {
		modelCtrl.$setViewValue();
		scope.$apply(function() {
		  // Reset validity as we are clearing
		  modelCtrl.$setValidity('editable', true);
		  modelCtrl.$setValidity('parse', true);
		});
		element.val('');
	  }
	  hasFocus = false;
	  selected = false;
	});

	// Keep reference to click handler to unbind it.
	var dismissClickHandler = function(evt) {
	  // Issue #3973
	  // Firefox treats right click as a click on document
	  if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
		resetMatches();
		if (!$rootScope.$$phase) {
		  originalScope.$digest();
		}
	  }
	};

	$document.on('click', dismissClickHandler);

	originalScope.$on('$destroy', function() {
	  $document.off('click', dismissClickHandler);
	  if (appendToBody || appendTo) {
		$popup.remove();
	  }

	  if (appendToBody) {
		angular.element($window).off('resize', fireRecalculating);
		$document.find('body').off('scroll', fireRecalculating);
	  }
	  // Prevent jQuery cache memory leak
	  popUpEl.remove();

	  if (showHint) {
		  inputsContainer.remove();
	  }
	});

	var $popup = $compile(popUpEl)(scope);

	if (appendToBody) {
	  $document.find('body').append($popup);
	} else if (appendTo) {
	  angular.element(appendTo).eq(0).append($popup);
	} else {
	  element.after($popup);
	}

	this.init = function(_modelCtrl, _ngModelOptions) {
	  modelCtrl = _modelCtrl;
	  ngModelOptions = _ngModelOptions;

	  scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);

	  //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
	  //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
	  modelCtrl.$parsers.unshift(function(inputValue) {
		hasFocus = true;

		if (minLength === 0 || inputValue && inputValue.length >= minLength) {
		  if (waitTime > 0) {
			cancelPreviousTimeout();
			scheduleSearchWithTimeout(inputValue);
		  } else {
			getMatchesAsync(inputValue);
		  }
		} else {
		  isLoadingSetter(originalScope, false);
		  cancelPreviousTimeout();
		  resetMatches();
		}

		if (isEditable) {
		  return inputValue;
		}

		if (!inputValue) {
		  // Reset in case user had typed something previously.
		  modelCtrl.$setValidity('editable', true);
		  return null;
		}

		modelCtrl.$setValidity('editable', false);
		return undefined;
	  });

	  modelCtrl.$formatters.push(function(modelValue) {
		var candidateViewValue, emptyViewValue;
		var locals = {};

		// The validity may be set to false via $parsers (see above) if
		// the model is restricted to selected values. If the model
		// is set manually it is considered to be valid.
		if (!isEditable) {
		  modelCtrl.$setValidity('editable', true);
		}

		if (inputFormatter) {
		  locals.$model = modelValue;
		  return inputFormatter(originalScope, locals);
		}

		//it might happen that we don't have enough info to properly render input value
		//we need to check for this situation and simply return model value if we can't apply custom formatting
		locals[parserResult.itemName] = modelValue;
		candidateViewValue = parserResult.viewMapper(originalScope, locals);
		locals[parserResult.itemName] = undefined;
		emptyViewValue = parserResult.viewMapper(originalScope, locals);

		return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
	  });
	};
  }])

  .directive('uibTypeahead', function() {
	return {
	  controller: 'UibTypeaheadController',
	  require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
	  link: function(originalScope, element, attrs, ctrls) {
		ctrls[2].init(ctrls[0], ctrls[1]);
	  }
	};
  })

  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {
	return {
	  scope: {
		matches: '=',
		query: '=',
		active: '=',
		position: '&',
		moveInProgress: '=',
		select: '&',
		assignIsOpen: '&',
		debounce: '&'
	  },
	  replace: true,
	  templateUrl: function(element, attrs) {
		return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
	  },
	  link: function(scope, element, attrs) {
		scope.templateUrl = attrs.templateUrl;

		scope.isOpen = function() {
		  var isDropdownOpen = scope.matches.length > 0;
		  scope.assignIsOpen({ isOpen: isDropdownOpen });
		  return isDropdownOpen;
		};

		scope.isActive = function(matchIdx) {
		  return scope.active === matchIdx;
		};

		scope.selectActive = function(matchIdx) {
		  scope.active = matchIdx;
		};

		scope.selectMatch = function(activeIdx, evt) {
		  var debounce = scope.debounce();
		  if (angular.isNumber(debounce) || angular.isObject(debounce)) {
			$$debounce(function() {
			  scope.select({activeIdx: activeIdx, evt: evt});
			}, angular.isNumber(debounce) ? debounce : debounce['default']);
		  } else {
			scope.select({activeIdx: activeIdx, evt: evt});
		  }
		};
	  }
	};
  }])

  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
	return {
	  scope: {
		index: '=',
		match: '=',
		query: '='
	  },
	  link: function(scope, element, attrs) {
		var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
		$templateRequest(tplUrl).then(function(tplContent) {
		  var tplEl = angular.element(tplContent.trim());
		  element.replaceWith(tplEl);
		  $compile(tplEl)(scope);
		});
	  }
	};
  }])

  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
	var isSanitizePresent;
	isSanitizePresent = $injector.has('$sanitize');

	function escapeRegexp(queryToEscape) {
	  // Regex: capture the whole query string and replace it with the string that will be used to match
	  // the results, for example if the capture is "a" the result will be \a
	  return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
	}

	function containsHtml(matchItem) {
	  return /<.*>/g.test(matchItem);
	}

	return function(matchItem, query) {
	  if (!isSanitizePresent && containsHtml(matchItem)) {
		$log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
	  }
	  matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
	  if (!isSanitizePresent) {
		matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
	  }
	  return matchItem;
	};
  }]);

angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/accordion/accordion-group.html",
	"<div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" +
	"  <h4 class=\"panel-title\">\n" +
	"    <a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\" ng-disabled=\"isDisabled\" uib-tabindex-toggle><span uib-accordion-header ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" +
	"  </h4>\n" +
	"</div>\n" +
	"<div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" +
	"  <div class=\"panel-body\" ng-transclude></div>\n" +
	"</div>\n" +
	"");
}]);

angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/accordion/accordion.html",
	"<div role=\"tablist\" class=\"panel-group\" ng-transclude></div>");
}]);

angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/alert/alert.html",
	"<button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" +
	"  <span aria-hidden=\"true\">&times;</span>\n" +
	"  <span class=\"sr-only\">Close</span>\n" +
	"</button>\n" +
	"<div ng-transclude></div>\n" +
	"");
}]);

angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/carousel/carousel.html",
	"<div class=\"carousel-inner\" ng-transclude></div>\n" +
	"<a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-class=\"{ disabled: isPrevDisabled() }\" ng-show=\"slides.length > 1\">\n" +
	"  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" +
	"  <span class=\"sr-only\">previous</span>\n" +
	"</a>\n" +
	"<a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-class=\"{ disabled: isNextDisabled() }\" ng-show=\"slides.length > 1\">\n" +
	"  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" +
	"  <span class=\"sr-only\">next</span>\n" +
	"</a>\n" +
	"<ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
	"  <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" +
	"    <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" +
	"  </li>\n" +
	"</ol>\n" +
	"");
}]);

angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/carousel/slide.html",
	"<div class=\"text-center\" ng-transclude></div>\n" +
	"");
}]);

angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/datepicker.html",
	"<div ng-switch=\"datepickerMode\">\n" +
	"  <div uib-daypicker ng-switch-when=\"day\" tabindex=\"0\" class=\"uib-daypicker\"></div>\n" +
	"  <div uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\" class=\"uib-monthpicker\"></div>\n" +
	"  <div uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\" class=\"uib-yearpicker\"></div>\n" +
	"</div>\n" +
	"");
}]);

angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/day.html",
	"<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	"  <thead>\n" +
	"    <tr>\n" +
	"      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	"      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
	"      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	"    </tr>\n" +
	"    <tr>\n" +
	"      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
	"      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
	"    </tr>\n" +
	"  </thead>\n" +
	"  <tbody>\n" +
	"    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\">\n" +
	"      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
	"      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" +
	"        id=\"{{::dt.uid}}\"\n" +
	"        ng-class=\"::dt.customClass\">\n" +
	"        <button type=\"button\" class=\"btn btn-default btn-sm\"\n" +
	"          uib-is-class=\"\n" +
	"            'btn-info' for selectedDt,\n" +
	"            'active' for activeDt\n" +
	"            on dt\"\n" +
	"          ng-click=\"select(dt.date)\"\n" +
	"          ng-disabled=\"::dt.disabled\"\n" +
	"          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	"      </td>\n" +
	"    </tr>\n" +
	"  </tbody>\n" +
	"</table>\n" +
	"");
}]);

angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/month.html",
	"<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	"  <thead>\n" +
	"    <tr>\n" +
	"      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	"      <th colspan=\"{{::yearHeaderColspan}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
	"      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	"    </tr>\n" +
	"  </thead>\n" +
	"  <tbody>\n" +
	"    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\">\n" +
	"      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" +
	"        id=\"{{::dt.uid}}\"\n" +
	"        ng-class=\"::dt.customClass\">\n" +
	"        <button type=\"button\" class=\"btn btn-default\"\n" +
	"          uib-is-class=\"\n" +
	"            'btn-info' for selectedDt,\n" +
	"            'active' for activeDt\n" +
	"            on dt\"\n" +
	"          ng-click=\"select(dt.date)\"\n" +
	"          ng-disabled=\"::dt.disabled\"\n" +
	"          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	"      </td>\n" +
	"    </tr>\n" +
	"  </tbody>\n" +
	"</table>\n" +
	"");
}]);

angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/year.html",
	"<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	"  <thead>\n" +
	"    <tr>\n" +
	"      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	"      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
	"      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	"    </tr>\n" +
	"  </thead>\n" +
	"  <tbody>\n" +
	"    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\">\n" +
	"      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" +
	"        id=\"{{::dt.uid}}\"\n" +
	"        ng-class=\"::dt.customClass\">\n" +
	"        <button type=\"button\" class=\"btn btn-default\"\n" +
	"          uib-is-class=\"\n" +
	"            'btn-info' for selectedDt,\n" +
	"            'active' for activeDt\n" +
	"            on dt\"\n" +
	"          ng-click=\"select(dt.date)\"\n" +
	"          ng-disabled=\"::dt.disabled\"\n" +
	"          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	"      </td>\n" +
	"    </tr>\n" +
	"  </tbody>\n" +
	"</table>\n" +
	"");
}]);

angular.module("uib/template/datepickerPopup/popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepickerPopup/popup.html",
	"<ul class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
	"  <li ng-transclude></li>\n" +
	"  <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" +
	"    <span class=\"btn-group pull-left\">\n" +
	"      <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today', $event)\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
	"      <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText('clear') }}</button>\n" +
	"    </span>\n" +
	"    <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText('close') }}</button>\n" +
	"  </li>\n" +
	"</ul>\n" +
	"");
}]);

angular.module("uib/template/modal/window.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/modal/window.html",
	"<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" +
	"");
}]);

angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/pager/pager.html",
	"<li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" +
	"<li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" +
	"");
}]);

angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/pagination/pagination.html",
	"<li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('first')}}</a></li>\n" +
	"<li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" +
	"<li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\" ng-disabled=\"ngDisabled&&!page.active\" uib-tabindex-toggle>{{page.text}}</a></li>\n" +
	"<li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" +
	"<li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('last')}}</a></li>\n" +
	"");
}]);

angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-html-popup.html",
	"<div class=\"tooltip-arrow\"></div>\n" +
	"<div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" +
	"");
}]);

angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-popup.html",
	"<div class=\"tooltip-arrow\"></div>\n" +
	"<div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
	"");
}]);

angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-template-popup.html",
	"<div class=\"tooltip-arrow\"></div>\n" +
	"<div class=\"tooltip-inner\"\n" +
	"  uib-tooltip-template-transclude=\"contentExp()\"\n" +
	"  tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
	"");
}]);

angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover-html.html",
	"<div class=\"arrow\"></div>\n" +
	"\n" +
	"<div class=\"popover-inner\">\n" +
	"    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
	"    <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" +
	"</div>\n" +
	"");
}]);

angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover-template.html",
	"<div class=\"arrow\"></div>\n" +
	"\n" +
	"<div class=\"popover-inner\">\n" +
	"    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
	"    <div class=\"popover-content\"\n" +
	"      uib-tooltip-template-transclude=\"contentExp()\"\n" +
	"      tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
	"</div>\n" +
	"");
}]);

angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover.html",
	"<div class=\"arrow\"></div>\n" +
	"\n" +
	"<div class=\"popover-inner\">\n" +
	"    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
	"    <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
	"</div>\n" +
	"");
}]);

angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/bar.html",
	"<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
	"");
}]);

angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/progress.html",
	"<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
}]);

angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/progressbar.html",
	"<div class=\"progress\">\n" +
	"  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
	"</div>\n" +
	"");
}]);

angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/rating/rating.html",
	"<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\" aria-valuetext=\"{{title}}\">\n" +
	"    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
	"    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\"></i>\n" +
	"</span>\n" +
	"");
}]);

angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tabs/tab.html",
	"<li ng-class=\"[{active: active, disabled: disabled}, classes]\" class=\"uib-tab nav-item\">\n" +
	"  <a href ng-click=\"select($event)\" class=\"nav-link\" uib-tab-heading-transclude>{{heading}}</a>\n" +
	"</li>\n" +
	"");
}]);

angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tabs/tabset.html",
	"<div>\n" +
	"  <ul class=\"nav nav-{{tabset.type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
	"  <div class=\"tab-content\">\n" +
	"    <div class=\"tab-pane\"\n" +
	"         ng-repeat=\"tab in tabset.tabs\"\n" +
	"         ng-class=\"{active: tabset.active === tab.index}\"\n" +
	"         uib-tab-content-transclude=\"tab\">\n" +
	"    </div>\n" +
	"  </div>\n" +
	"</div>\n" +
	"");
}]);

angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/timepicker/timepicker.html",
	"<table class=\"uib-timepicker\">\n" +
	"  <tbody>\n" +
	"    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
	"      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
	"      <td>&nbsp;</td>\n" +
	"      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
	"      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
	"      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
	"      <td ng-show=\"showMeridian\"></td>\n" +
	"    </tr>\n" +
	"    <tr>\n" +
	"      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" +
	"        <input type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\n" +
	"      </td>\n" +
	"      <td class=\"uib-separator\">:</td>\n" +
	"      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
	"        <input type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\n" +
	"      </td>\n" +
	"      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" +
	"      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" +
	"        <input type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\n" +
	"      </td>\n" +
	"      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" +
	"    </tr>\n" +
	"    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
	"      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
	"      <td>&nbsp;</td>\n" +
	"      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
	"      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
	"      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
	"      <td ng-show=\"showMeridian\"></td>\n" +
	"    </tr>\n" +
	"  </tbody>\n" +
	"</table>\n" +
	"");
}]);

angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/typeahead/typeahead-match.html",
	"<a href\n" +
	"   tabindex=\"-1\"\n" +
	"   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\n" +
	"   ng-attr-title=\"{{match.label}}\"></a>\n" +
	"");
}]);

angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/typeahead/typeahead-popup.html",
	"<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
	"    <li class=\"uib-typeahead-match\" ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\n" +
	"        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
	"    </li>\n" +
	"</ul>\n" +
	"");
}]);
angular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); angular.$$uibCarouselCss = true; });
angular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'); angular.$$uibDatepickerCss = true; });
angular.module('ui.bootstrap.position').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'); angular.$$uibPositionCss = true; });
angular.module('ui.bootstrap.datepickerPopup').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'); angular.$$uibDatepickerpopupCss = true; });
angular.module('ui.bootstrap.tooltip').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); angular.$$uibTooltipCss = true; });
angular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>'); angular.$$uibTimepickerCss = true; });
angular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); angular.$$uibTypeaheadCss = true; });;
/*
CryptoJS 
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(a,j){var c={},b=c.lib={},f=function(){},l=b.Base={extend:function(a){f.prototype=this;var d=new f;a&&d.mixIn(a);d.hasOwnProperty("init")||(d.init=function(){d.$super.init.apply(this,arguments)});d.init.prototype=d;d.$super=this;return d},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var d in a)a.hasOwnProperty(d)&&(this[d]=a[d]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
u=b.WordArray=l.extend({init:function(a,d){a=this.words=a||[];this.sigBytes=d!=j?d:4*a.length},toString:function(a){return(a||m).stringify(this)},concat:function(a){var d=this.words,M=a.words,e=this.sigBytes;a=a.sigBytes;this.clamp();if(e%4)for(var b=0;b<a;b++)d[e+b>>>2]|=(M[b>>>2]>>>24-8*(b%4)&255)<<24-8*((e+b)%4);else if(65535<M.length)for(b=0;b<a;b+=4)d[e+b>>>2]=M[b>>>2];else d.push.apply(d,M);this.sigBytes+=a;return this},clamp:function(){var D=this.words,d=this.sigBytes;D[d>>>2]&=4294967295<<
32-8*(d%4);D.length=a.ceil(d/4)},clone:function(){var a=l.clone.call(this);a.words=this.words.slice(0);return a},random:function(D){for(var d=[],b=0;b<D;b+=4)d.push(4294967296*a.random()|0);return new u.init(d,D)}}),k=c.enc={},m=k.Hex={stringify:function(a){var d=a.words;a=a.sigBytes;for(var b=[],e=0;e<a;e++){var c=d[e>>>2]>>>24-8*(e%4)&255;b.push((c>>>4).toString(16));b.push((c&15).toString(16))}return b.join("")},parse:function(a){for(var d=a.length,b=[],e=0;e<d;e+=2)b[e>>>3]|=parseInt(a.substr(e,
2),16)<<24-4*(e%8);return new u.init(b,d/2)}},y=k.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var c=[],e=0;e<a;e++)c.push(String.fromCharCode(b[e>>>2]>>>24-8*(e%4)&255));return c.join("")},parse:function(a){for(var b=a.length,c=[],e=0;e<b;e++)c[e>>>2]|=(a.charCodeAt(e)&255)<<24-8*(e%4);return new u.init(c,b)}},z=k.Utf8={stringify:function(a){try{return decodeURIComponent(escape(y.stringify(a)))}catch(b){throw Error("Malformed UTF-8 data");}},parse:function(a){return y.parse(unescape(encodeURIComponent(a)))}},
x=b.BufferedBlockAlgorithm=l.extend({reset:function(){this._data=new u.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=z.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(b){var d=this._data,c=d.words,e=d.sigBytes,l=this.blockSize,k=e/(4*l),k=b?a.ceil(k):a.max((k|0)-this._minBufferSize,0);b=k*l;e=a.min(4*b,e);if(b){for(var x=0;x<b;x+=l)this._doProcessBlock(c,x);x=c.splice(0,b);d.sigBytes-=e}return new u.init(x,e)},clone:function(){var a=l.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});b.Hasher=x.extend({cfg:l.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){x.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,c){return(new a.init(c)).finalize(b)}},_createHmacHelper:function(a){return function(b,c){return(new ja.HMAC.init(a,
c)).finalize(b)}}});var ja=c.algo={};return c}(Math);
(function(a){var j=CryptoJS,c=j.lib,b=c.Base,f=c.WordArray,j=j.x64={};j.Word=b.extend({init:function(a,b){this.high=a;this.low=b}});j.WordArray=b.extend({init:function(b,c){b=this.words=b||[];this.sigBytes=c!=a?c:8*b.length},toX32:function(){for(var a=this.words,b=a.length,c=[],m=0;m<b;m++){var y=a[m];c.push(y.high);c.push(y.low)}return f.create(c,this.sigBytes)},clone:function(){for(var a=b.clone.call(this),c=a.words=this.words.slice(0),k=c.length,f=0;f<k;f++)c[f]=c[f].clone();return a}})})();
(function(){function a(){return f.create.apply(f,arguments)}for(var j=CryptoJS,c=j.lib.Hasher,b=j.x64,f=b.Word,l=b.WordArray,b=j.algo,u=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),
a(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,
2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),
a(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,
3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],k=[],m=0;80>m;m++)k[m]=a();b=b.SHA512=c.extend({_doReset:function(){this._hash=new l.init([new f.init(1779033703,4089235720),new f.init(3144134277,2227873595),new f.init(1013904242,4271175723),new f.init(2773480762,1595750129),new f.init(1359893119,2917565137),new f.init(2600822924,725511199),new f.init(528734635,4215389547),new f.init(1541459225,327033209)])},_doProcessBlock:function(a,b){for(var c=this._hash.words,
f=c[0],j=c[1],d=c[2],l=c[3],e=c[4],m=c[5],N=c[6],c=c[7],aa=f.high,O=f.low,ba=j.high,P=j.low,ca=d.high,Q=d.low,da=l.high,R=l.low,ea=e.high,S=e.low,fa=m.high,T=m.low,ga=N.high,U=N.low,ha=c.high,V=c.low,r=aa,n=O,G=ba,E=P,H=ca,F=Q,Y=da,I=R,s=ea,p=S,W=fa,J=T,X=ga,K=U,Z=ha,L=V,t=0;80>t;t++){var A=k[t];if(16>t)var q=A.high=a[b+2*t]|0,g=A.low=a[b+2*t+1]|0;else{var q=k[t-15],g=q.high,v=q.low,q=(g>>>1|v<<31)^(g>>>8|v<<24)^g>>>7,v=(v>>>1|g<<31)^(v>>>8|g<<24)^(v>>>7|g<<25),C=k[t-2],g=C.high,h=C.low,C=(g>>>19|
h<<13)^(g<<3|h>>>29)^g>>>6,h=(h>>>19|g<<13)^(h<<3|g>>>29)^(h>>>6|g<<26),g=k[t-7],$=g.high,B=k[t-16],w=B.high,B=B.low,g=v+g.low,q=q+$+(g>>>0<v>>>0?1:0),g=g+h,q=q+C+(g>>>0<h>>>0?1:0),g=g+B,q=q+w+(g>>>0<B>>>0?1:0);A.high=q;A.low=g}var $=s&W^~s&X,B=p&J^~p&K,A=r&G^r&H^G&H,ka=n&E^n&F^E&F,v=(r>>>28|n<<4)^(r<<30|n>>>2)^(r<<25|n>>>7),C=(n>>>28|r<<4)^(n<<30|r>>>2)^(n<<25|r>>>7),h=u[t],la=h.high,ia=h.low,h=L+((p>>>14|s<<18)^(p>>>18|s<<14)^(p<<23|s>>>9)),w=Z+((s>>>14|p<<18)^(s>>>18|p<<14)^(s<<23|p>>>9))+(h>>>
0<L>>>0?1:0),h=h+B,w=w+$+(h>>>0<B>>>0?1:0),h=h+ia,w=w+la+(h>>>0<ia>>>0?1:0),h=h+g,w=w+q+(h>>>0<g>>>0?1:0),g=C+ka,A=v+A+(g>>>0<C>>>0?1:0),Z=X,L=K,X=W,K=J,W=s,J=p,p=I+h|0,s=Y+w+(p>>>0<I>>>0?1:0)|0,Y=H,I=F,H=G,F=E,G=r,E=n,n=h+g|0,r=w+A+(n>>>0<h>>>0?1:0)|0}O=f.low=O+n;f.high=aa+r+(O>>>0<n>>>0?1:0);P=j.low=P+E;j.high=ba+G+(P>>>0<E>>>0?1:0);Q=d.low=Q+F;d.high=ca+H+(Q>>>0<F>>>0?1:0);R=l.low=R+I;l.high=da+Y+(R>>>0<I>>>0?1:0);S=e.low=S+p;e.high=ea+s+(S>>>0<p>>>0?1:0);T=m.low=T+J;m.high=fa+W+(T>>>0<J>>>0?1:
0);U=N.low=U+K;N.high=ga+X+(U>>>0<K>>>0?1:0);V=c.low=V+L;c.high=ha+Z+(V>>>0<L>>>0?1:0)},_doFinalize:function(){var a=this._data,b=a.words,c=8*this._nDataBytes,f=8*a.sigBytes;b[f>>>5]|=128<<24-f%32;b[(f+128>>>10<<5)+30]=Math.floor(c/4294967296);b[(f+128>>>10<<5)+31]=c;a.sigBytes=4*b.length;this._process();return this._hash.toX32()},clone:function(){var a=c.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});j.SHA512=c._createHelper(b);j.HmacSHA512=c._createHmacHelper(b)})();
(function(){var a=CryptoJS,j=a.enc.Utf8;a.algo.HMAC=a.lib.Base.extend({init:function(a,b){a=this._hasher=new a.init;"string"==typeof b&&(b=j.parse(b));var f=a.blockSize,l=4*f;b.sigBytes>l&&(b=a.finalize(b));b.clamp();for(var u=this._oKey=b.clone(),k=this._iKey=b.clone(),m=u.words,y=k.words,z=0;z<f;z++)m[z]^=1549556828,y[z]^=909522486;u.sigBytes=k.sigBytes=l;this.reset()},reset:function(){var a=this._hasher;a.reset();a.update(this._iKey)},update:function(a){this._hasher.update(a);return this},finalize:function(a){var b=
this._hasher;a=b.finalize(a);b.reset();return b.finalize(this._oKey.clone().concat(a))}})})();
;
/*
CryptoJS 
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(h,s){var f={},t=f.lib={},g=function(){},j=t.Base={extend:function(a){g.prototype=this;var c=new g;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
q=t.WordArray=j.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||u).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=j.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new q.init(c,a)}}),v=f.enc={},u=v.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,
2),16)<<24-4*(b%8);return new q.init(d,c/2)}},k=v.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new q.init(d,c)}},l=v.Utf8={stringify:function(a){try{return decodeURIComponent(escape(k.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return k.parse(unescape(encodeURIComponent(a)))}},
x=t.BufferedBlockAlgorithm=j.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=l.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var m=0;m<a;m+=e)this._doProcessBlock(d,m);m=d.splice(0,a);c.sigBytes-=b}return new q.init(m,b)},clone:function(){var a=j.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});t.Hasher=x.extend({cfg:j.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){x.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new w.HMAC.init(a,
d)).finalize(c)}}});var w=f.algo={};return f}(Math);
(function(h){for(var s=CryptoJS,f=s.lib,t=f.WordArray,g=f.Hasher,f=s.algo,j=[],q=[],v=function(a){return 4294967296*(a-(a|0))|0},u=2,k=0;64>k;){var l;a:{l=u;for(var x=h.sqrt(l),w=2;w<=x;w++)if(!(l%w)){l=!1;break a}l=!0}l&&(8>k&&(j[k]=v(h.pow(u,0.5))),q[k]=v(h.pow(u,1/3)),k++);u++}var a=[],f=f.SHA256=g.extend({_doReset:function(){this._hash=new t.init(j.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],m=b[2],h=b[3],p=b[4],j=b[5],k=b[6],l=b[7],n=0;64>n;n++){if(16>n)a[n]=
c[d+n]|0;else{var r=a[n-15],g=a[n-2];a[n]=((r<<25|r>>>7)^(r<<14|r>>>18)^r>>>3)+a[n-7]+((g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10)+a[n-16]}r=l+((p<<26|p>>>6)^(p<<21|p>>>11)^(p<<7|p>>>25))+(p&j^~p&k)+q[n]+a[n];g=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&m^f&m);l=k;k=j;j=p;p=h+r|0;h=m;m=f;f=e;e=r+g|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+m|0;b[3]=b[3]+h|0;b[4]=b[4]+p|0;b[5]=b[5]+j|0;b[6]=b[6]+k|0;b[7]=b[7]+l|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;
d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=g.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=g._createHelper(f);s.HmacSHA256=g._createHmacHelper(f)})(Math);
;
//
// showdown.js -- A javascript port of Markdown.
//
// Copyright (c) 2007 John Fraser.
//
// Original Markdown Copyright (c) 2004-2005 John Gruber
//   <http://daringfireball.net/projects/markdown/>
//
// Redistributable under a BSD-style open source license.
// See license.txt for more information.
//
// The full source distribution is at:
//
//				A A L
//				T C A
//				T K B
//
//   <http://www.attacklab.net/>
//

//
// Wherever possible, Showdown is a straight, line-by-line port
// of the Perl version of Markdown.
//
// This is not a normal parser design; it's basically just a
// series of string substitutions.  It's hard to read and
// maintain this way,  but keeping Showdown close to the original
// design makes it easier to port new features.
//
// More importantly, Showdown behaves like markdown.pl in most
// edge cases.  So web applications can do client-side preview
// in Javascript, and then build identical HTML on the server.
//
// This port needs the new RegExp functionality of ECMA 262,
// 3rd Edition (i.e. Javascript 1.5).  Most modern web browsers
// should do fine.  Even with the new regular expression features,
// We do a lot of work to emulate Perl's regex functionality.
// The tricky changes in this file mostly have the "attacklab:"
// label.  Major or self-explanatory changes don't.
//
// Smart diff tools like Araxis Merge will be able to match up
// this file with markdown.pl in a useful way.  A little tweaking
// helps: in a copy of markdown.pl, replace "#" with "//" and
// replace "$text" with "text".  Be sure to ignore whitespace
// and line endings.
//


//
// Showdown usage:
//
//   var text = "Markdown *rocks*.";
//
//   var converter = new Showdown.converter();
//   var html = converter.makeHtml(text);
//
//   alert(html);
//
// Note: move the sample code to the bottom of this
// file before uncommenting it.
//


//
// Showdown namespace
//
var Showdown = { extensions: {} };

//
// forEach
//
var sdforEach = Showdown.forEach = function(obj, callback) {
	if (typeof obj.forEach === 'function') {
		obj.forEach(callback);
	} else {
		var i, len = obj.length;
		for (i = 0; i < len; i++) {
			callback(obj[i], i, obj);
		}
	}
};

//
// Standard extension naming
//
var stdExtName = function(s) {
	return s.replace(/[_-]||\s/g, '').toLowerCase();
};

//
// converter
//
// Wraps all "globals" so that the only thing
// exposed is makeHtml().
//
Showdown.converter = function(converter_options) {

//
// Globals:
//

// Global hashes, used by various utility routines
var g_urls;
var g_titles;
var g_html_blocks;

// Used to track when we're inside an ordered or unordered list
// (see _ProcessListItems() for details):
var g_list_level = 0;

// Global extensions
var g_lang_extensions = [];
var g_output_modifiers = [];


//
// Automatic Extension Loading (node only):
//

if (typeof module !== 'undefind' && typeof exports !== 'undefined' && typeof require !== 'undefind') {
	var fs = require('fs');

	if (fs) {
		// Search extensions folder
		var extensions = fs.readdirSync((__dirname || '.')+'/extensions').filter(function(file){
			return ~file.indexOf('.js');
		}).map(function(file){
			return file.replace(/\.js$/, '');
		});
		// Load extensions into Showdown namespace
		Showdown.forEach(extensions, function(ext){
			var name = stdExtName(ext);
			Showdown.extensions[name] = require('./extensions/' + ext);
		});
	}
}

this.makeHtml = function(text) {
//
// Main function. The order in which other subs are called here is
// essential. Link and image substitutions need to happen before
// _EscapeSpecialCharsWithinTagAttributes(), so that any *'s or _'s in the <a>
// and <img> tags get encoded.
//

	// Clear the global hashes. If we don't clear these, you get conflicts
	// from other articles when generating a page which contains more than
	// one article (e.g. an index page that shows the N most recent
	// articles):
	g_urls = {};
	g_titles = {};
	g_html_blocks = [];

	// attacklab: Replace ~ with ~T
	// This lets us use tilde as an escape char to avoid md5 hashes
	// The choice of character is arbitray; anything that isn't
	// magic in Markdown will work.
	text = text.replace(/~/g,"~T");

	// attacklab: Replace $ with ~D
	// RegExp interprets $ as a special character
	// when it's in a replacement string
	text = text.replace(/\$/g,"~D");

	// Standardize line endings
	text = text.replace(/\r\n/g,"\n"); // DOS to Unix
	text = text.replace(/\r/g,"\n"); // Mac to Unix

	// Make sure text begins and ends with a couple of newlines:
	text = "\n\n" + text + "\n\n";

	// Convert all tabs to spaces.
	text = _Detab(text);

	// Strip any lines consisting only of spaces and tabs.
	// This makes subsequent regexen easier to write, because we can
	// match consecutive blank lines with /\n+/ instead of something
	// contorted like /[ \t]*\n+/ .
	text = text.replace(/^[ \t]+$/mg,"");

	// Run language extensions
	Showdown.forEach(g_lang_extensions, function(x){
		text = _ExecuteExtension(x, text);
	});

	// Handle github codeblocks prior to running HashHTML so that
	// HTML contained within the codeblock gets escaped propertly
	text = _DoGithubCodeBlocks(text);

	// Turn block-level HTML blocks into hash entries
	text = _HashHTMLBlocks(text);

	// Strip link definitions, store in hashes.
	text = _StripLinkDefinitions(text);

	text = _RunBlockGamut(text);

	text = _UnescapeSpecialChars(text);

	// attacklab: Restore dollar signs
	text = text.replace(/~D/g,"$$");

	// attacklab: Restore tildes
	text = text.replace(/~T/g,"~");

	// Run output modifiers
	Showdown.forEach(g_output_modifiers, function(x){
		text = _ExecuteExtension(x, text);
	});

	return text;
};
//
// Options:
//

// Parse extensions options into separate arrays
if (converter_options && converter_options.extensions) {

  var self = this;

	// Iterate over each plugin
	Showdown.forEach(converter_options.extensions, function(plugin){

		// Assume it's a bundled plugin if a string is given
		if (typeof plugin === 'string') {
			plugin = Showdown.extensions[stdExtName(plugin)];
		}

		if (typeof plugin === 'function') {
			// Iterate over each extension within that plugin
			Showdown.forEach(plugin(self), function(ext){
				// Sort extensions by type
				if (ext.type) {
					if (ext.type === 'language' || ext.type === 'lang') {
						g_lang_extensions.push(ext);
					} else if (ext.type === 'output' || ext.type === 'html') {
						g_output_modifiers.push(ext);
					}
				} else {
					// Assume language extension
					g_output_modifiers.push(ext);
				}
			});
		} else {
			throw "Extension '" + plugin + "' could not be loaded.  It was either not found or is not a valid extension.";
		}
	});
}


var _ExecuteExtension = function(ext, text) {
	if (ext.regex) {
		var re = new RegExp(ext.regex, 'g');
		return text.replace(re, ext.replace);
	} else if (ext.filter) {
		return ext.filter(text);
	}
};

var _StripLinkDefinitions = function(text) {
//
// Strips link definitions from text, stores the URLs and titles in
// hash references.
//

	// Link defs are in the form: ^[id]: url "optional title"

	/*
		var text = text.replace(/
				^[ ]{0,3}\[(.+)\]:  // id = $1  attacklab: g_tab_width - 1
				  [ \t]*
				  \n?				// maybe *one* newline
				  [ \t]*
				<?(\S+?)>?			// url = $2
				  [ \t]*
				  \n?				// maybe one newline
				  [ \t]*
				(?:
				  (\n*)				// any lines skipped = $3 attacklab: lookbehind removed
				  ["(]
				  (.+?)				// title = $4
				  [")]
				  [ \t]*
				)?					// title is optional
				(?:\n+|$)
			  /gm,
			  function(){...});
	*/

	// attacklab: sentinel workarounds for lack of \A and \Z, safari\khtml bug
	text += "~0";

	text = text.replace(/^[ ]{0,3}\[(.+)\]:[ \t]*\n?[ \t]*<?(\S+?)>?[ \t]*\n?[ \t]*(?:(\n*)["(](.+?)[")][ \t]*)?(?:\n+|(?=~0))/gm,
		function (wholeMatch,m1,m2,m3,m4) {
			m1 = m1.toLowerCase();
			g_urls[m1] = _EncodeAmpsAndAngles(m2);  // Link IDs are case-insensitive
			if (m3) {
				// Oops, found blank lines, so it's not a title.
				// Put back the parenthetical statement we stole.
				return m3+m4;
			} else if (m4) {
				g_titles[m1] = m4.replace(/"/g,"&quot;");
			}

			// Completely remove the definition from the text
			return "";
		}
	);

	// attacklab: strip sentinel
	text = text.replace(/~0/,"");

	return text;
}


var _HashHTMLBlocks = function(text) {
	// attacklab: Double up blank lines to reduce lookaround
	text = text.replace(/\n/g,"\n\n");

	// Hashify HTML blocks:
	// We only want to do this for block-level HTML tags, such as headers,
	// lists, and tables. That's because we still want to wrap <p>s around
	// "paragraphs" that are wrapped in non-block-level tags, such as anchors,
	// phrase emphasis, and spans. The list of tags we're looking for is
	// hard-coded:
	var block_tags_a = "p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del|style|section|header|footer|nav|article|aside";
	var block_tags_b = "p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|style|section|header|footer|nav|article|aside";

	// First, look for nested blocks, e.g.:
	//   <div>
	//     <div>
	//     tags for inner block must be indented.
	//     </div>
	//   </div>
	//
	// The outermost tags must start at the left margin for this to match, and
	// the inner nested divs must be indented.
	// We need to do this before the next, more liberal match, because the next
	// match will start at the first `<div>` and stop at the first `</div>`.

	// attacklab: This regex can be expensive when it fails.
	/*
		var text = text.replace(/
		(						// save in $1
			^					// start of line  (with /m)
			<($block_tags_a)	// start tag = $2
			\b					// word break
								// attacklab: hack around khtml/pcre bug...
			[^\r]*?\n			// any number of lines, minimally matching
			</\2>				// the matching end tag
			[ \t]*				// trailing spaces/tabs
			(?=\n+)				// followed by a newline
		)						// attacklab: there are sentinel newlines at end of document
		/gm,function(){...}};
	*/
	text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\b[^\r]*?\n<\/\2>[ \t]*(?=\n+))/gm,hashElement);

	//
	// Now match more liberally, simply from `\n<tag>` to `</tag>\n`
	//

	/*
		var text = text.replace(/
		(						// save in $1
			^					// start of line  (with /m)
			<($block_tags_b)	// start tag = $2
			\b					// word break
								// attacklab: hack around khtml/pcre bug...
			[^\r]*?				// any number of lines, minimally matching
			</\2>				// the matching end tag
			[ \t]*				// trailing spaces/tabs
			(?=\n+)				// followed by a newline
		)						// attacklab: there are sentinel newlines at end of document
		/gm,function(){...}};
	*/
	text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|style|section|header|footer|nav|article|aside)\b[^\r]*?<\/\2>[ \t]*(?=\n+)\n)/gm,hashElement);

	// Special case just for <hr />. It was easier to make a special case than
	// to make the other regex more complicated.

	/*
		text = text.replace(/
		(						// save in $1
			\n\n				// Starting after a blank line
			[ ]{0,3}
			(<(hr)				// start tag = $2
			\b					// word break
			([^<>])*?			//
			\/?>)				// the matching end tag
			[ \t]*
			(?=\n{2,})			// followed by a blank line
		)
		/g,hashElement);
	*/
	text = text.replace(/(\n[ ]{0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,hashElement);

	// Special case for standalone HTML comments:

	/*
		text = text.replace(/
		(						// save in $1
			\n\n				// Starting after a blank line
			[ ]{0,3}			// attacklab: g_tab_width - 1
			<!
			(--[^\r]*?--\s*)+
			>
			[ \t]*
			(?=\n{2,})			// followed by a blank line
		)
		/g,hashElement);
	*/
	text = text.replace(/(\n\n[ ]{0,3}<!(--[^\r]*?--\s*)+>[ \t]*(?=\n{2,}))/g,hashElement);

	// PHP and ASP-style processor instructions (<?...?> and <%...%>)

	/*
		text = text.replace(/
		(?:
			\n\n				// Starting after a blank line
		)
		(						// save in $1
			[ ]{0,3}			// attacklab: g_tab_width - 1
			(?:
				<([?%])			// $2
				[^\r]*?
				\2>
			)
			[ \t]*
			(?=\n{2,})			// followed by a blank line
		)
		/g,hashElement);
	*/
	text = text.replace(/(?:\n\n)([ ]{0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,hashElement);

	// attacklab: Undo double lines (see comment at top of this function)
	text = text.replace(/\n\n/g,"\n");
	return text;
}

var hashElement = function(wholeMatch,m1) {
	var blockText = m1;

	// Undo double lines
	blockText = blockText.replace(/\n\n/g,"\n");
	blockText = blockText.replace(/^\n/,"");

	// strip trailing blank lines
	blockText = blockText.replace(/\n+$/g,"");

	// Replace the element text with a marker ("~KxK" where x is its key)
	blockText = "\n\n~K" + (g_html_blocks.push(blockText)-1) + "K\n\n";

	return blockText;
};

var _RunBlockGamut = function(text) {
//
// These are all the transformations that form block-level
// tags like paragraphs, headers, and list items.
//
	text = _DoHeaders(text);

	// Do Horizontal Rules:
	var key = hashBlock("<hr />");
	text = text.replace(/^[ ]{0,2}([ ]?\*[ ]?){3,}[ \t]*$/gm,key);
	text = text.replace(/^[ ]{0,2}([ ]?\-[ ]?){3,}[ \t]*$/gm,key);
	text = text.replace(/^[ ]{0,2}([ ]?\_[ ]?){3,}[ \t]*$/gm,key);

	text = _DoLists(text);
	text = _DoCodeBlocks(text);
	text = _DoBlockQuotes(text);

	// We already ran _HashHTMLBlocks() before, in Markdown(), but that
	// was to escape raw HTML in the original Markdown source. This time,
	// we're escaping the markup we've just created, so that we don't wrap
	// <p> tags around block-level tags.
	text = _HashHTMLBlocks(text);
	text = _FormParagraphs(text);

	return text;
};


var _RunSpanGamut = function(text) {
//
// These are all the transformations that occur *within* block-level
// tags like paragraphs, headers, and list items.
//

	text = _DoCodeSpans(text);
	text = _EscapeSpecialCharsWithinTagAttributes(text);
	text = _EncodeBackslashEscapes(text);

	// Process anchor and image tags. Images must come first,
	// because ![foo][f] looks like an anchor.
	text = _DoImages(text);
	text = _DoAnchors(text);

	// Make links out of things like `<http://example.com/>`
	// Must come after _DoAnchors(), because you can use < and >
	// delimiters in inline links like [this](<url>).
	text = _DoAutoLinks(text);
	text = _EncodeAmpsAndAngles(text);
	text = _DoItalicsAndBold(text);

	// Do hard breaks:
	text = text.replace(/  +\n/g," <br />\n");

	return text;
}

var _EscapeSpecialCharsWithinTagAttributes = function(text) {
//
// Within tags -- meaning between < and > -- encode [\ ` * _] so they
// don't conflict with their use in Markdown for code, italics and strong.
//

	// Build a regex to find HTML tags and comments.  See Friedl's
	// "Mastering Regular Expressions", 2nd Ed., pp. 200-201.
	var regex = /(<[a-z\/!$]("[^"]*"|'[^']*'|[^'">])*>|<!(--.*?--\s*)+>)/gi;

	text = text.replace(regex, function(wholeMatch) {
		var tag = wholeMatch.replace(/(.)<\/?code>(?=.)/g,"$1`");
		tag = escapeCharacters(tag,"\\`*_");
		return tag;
	});

	return text;
}

var _DoAnchors = function(text) {
//
// Turn Markdown link shortcuts into XHTML <a> tags.
//
	//
	// First, handle reference-style links: [link text] [id]
	//

	/*
		text = text.replace(/
		(							// wrap whole match in $1
			\[
			(
				(?:
					\[[^\]]*\]		// allow brackets nested one level
					|
					[^\[]			// or anything else
				)*
			)
			\]

			[ ]?					// one optional space
			(?:\n[ ]*)?				// one optional newline followed by spaces

			\[
			(.*?)					// id = $3
			\]
		)()()()()					// pad remaining backreferences
		/g,_DoAnchors_callback);
	*/
	text = text.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g,writeAnchorTag);

	//
	// Next, inline-style links: [link text](url "optional title")
	//

	/*
		text = text.replace(/
			(						// wrap whole match in $1
				\[
				(
					(?:
						\[[^\]]*\]	// allow brackets nested one level
					|
					[^\[\]]			// or anything else
				)
			)
			\]
			\(						// literal paren
			[ \t]*
			()						// no id, so leave $3 empty
			<?(.*?)>?				// href = $4
			[ \t]*
			(						// $5
				(['"])				// quote char = $6
				(.*?)				// Title = $7
				\6					// matching quote
				[ \t]*				// ignore any spaces/tabs between closing quote and )
			)?						// title is optional
			\)
		)
		/g,writeAnchorTag);
	*/
	text = text.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\]\([ \t]*()<?(.*?(?:\(.*?\).*?)?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g,writeAnchorTag);

	//
	// Last, handle reference-style shortcuts: [link text]
	// These must come last in case you've also got [link test][1]
	// or [link test](/foo)
	//

	/*
		text = text.replace(/
		(		 					// wrap whole match in $1
			\[
			([^\[\]]+)				// link text = $2; can't contain '[' or ']'
			\]
		)()()()()()					// pad rest of backreferences
		/g, writeAnchorTag);
	*/
	text = text.replace(/(\[([^\[\]]+)\])()()()()()/g, writeAnchorTag);

	return text;
}

var writeAnchorTag = function(wholeMatch,m1,m2,m3,m4,m5,m6,m7) {
	if (m7 == undefined) m7 = "";
	var whole_match = m1;
	var link_text   = m2;
	var link_id	 = m3.toLowerCase();
	var url		= m4;
	var title	= m7;

	if (url == "") {
		if (link_id == "") {
			// lower-case and turn embedded newlines into spaces
			link_id = link_text.toLowerCase().replace(/ ?\n/g," ");
		}
		url = "#"+link_id;

		if (g_urls[link_id] != undefined) {
			url = g_urls[link_id];
			if (g_titles[link_id] != undefined) {
				title = g_titles[link_id];
			}
		}
		else {
			if (whole_match.search(/\(\s*\)$/m)>-1) {
				// Special case for explicit empty url
				url = "";
			} else {
				return whole_match;
			}
		}
	}

	url = escapeCharacters(url,"*_");
	var result = "<a href=\"" + url + "\"";

	if (title != "") {
		title = title.replace(/"/g,"&quot;");
		title = escapeCharacters(title,"*_");
		result +=  " title=\"" + title + "\"";
	}

	result += ">" + link_text + "</a>";

	return result;
}


var _DoImages = function(text) {
//
// Turn Markdown image shortcuts into <img> tags.
//

	//
	// First, handle reference-style labeled images: ![alt text][id]
	//

	/*
		text = text.replace(/
		(						// wrap whole match in $1
			!\[
			(.*?)				// alt text = $2
			\]

			[ ]?				// one optional space
			(?:\n[ ]*)?			// one optional newline followed by spaces

			\[
			(.*?)				// id = $3
			\]
		)()()()()				// pad rest of backreferences
		/g,writeImageTag);
	*/
	text = text.replace(/(!\[(.*?)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g,writeImageTag);

	//
	// Next, handle inline images:  ![alt text](url "optional title")
	// Don't forget: encode * and _

	/*
		text = text.replace(/
		(						// wrap whole match in $1
			!\[
			(.*?)				// alt text = $2
			\]
			\s?					// One optional whitespace character
			\(					// literal paren
			[ \t]*
			()					// no id, so leave $3 empty
			<?(\S+?)>?			// src url = $4
			[ \t]*
			(					// $5
				(['"])			// quote char = $6
				(.*?)			// title = $7
				\6				// matching quote
				[ \t]*
			)?					// title is optional
		\)
		)
		/g,writeImageTag);
	*/
	text = text.replace(/(!\[(.*?)\]\s?\([ \t]*()<?(\S+?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g,writeImageTag);

	return text;
}

var writeImageTag = function(wholeMatch,m1,m2,m3,m4,m5,m6,m7) {
	var whole_match = m1;
	var alt_text   = m2;
	var link_id	 = m3.toLowerCase();
	var url		= m4;
	var title	= m7;

	if (!title) title = "";

	if (url == "") {
		if (link_id == "") {
			// lower-case and turn embedded newlines into spaces
			link_id = alt_text.toLowerCase().replace(/ ?\n/g," ");
		}
		url = "#"+link_id;

		if (g_urls[link_id] != undefined) {
			url = g_urls[link_id];
			if (g_titles[link_id] != undefined) {
				title = g_titles[link_id];
			}
		}
		else {
			return whole_match;
		}
	}

	alt_text = alt_text.replace(/"/g,"&quot;");
	url = escapeCharacters(url,"*_");
	var result = "<img src=\"" + url + "\" alt=\"" + alt_text + "\"";

	// attacklab: Markdown.pl adds empty title attributes to images.
	// Replicate this bug.

	//if (title != "") {
		title = title.replace(/"/g,"&quot;");
		title = escapeCharacters(title,"*_");
		result +=  " title=\"" + title + "\"";
	//}

	result += " />";

	return result;
}


var _DoHeaders = function(text) {

	// Setext-style headers:
	//	Header 1
	//	========
	//
	//	Header 2
	//	--------
	//
	text = text.replace(/^(.+)[ \t]*\n=+[ \t]*\n+/gm,
		function(wholeMatch,m1){return hashBlock('<h1 id="' + headerId(m1) + '">' + _RunSpanGamut(m1) + "</h1>");});

	text = text.replace(/^(.+)[ \t]*\n-+[ \t]*\n+/gm,
		function(matchFound,m1){return hashBlock('<h2 id="' + headerId(m1) + '">' + _RunSpanGamut(m1) + "</h2>");});

	// atx-style headers:
	//  # Header 1
	//  ## Header 2
	//  ## Header 2 with closing hashes ##
	//  ...
	//  ###### Header 6
	//

	/*
		text = text.replace(/
			^(\#{1,6})				// $1 = string of #'s
			[ \t]*
			(.+?)					// $2 = Header text
			[ \t]*
			\#*						// optional closing #'s (not counted)
			\n+
		/gm, function() {...});
	*/

	text = text.replace(/^(\#{1,6})[ \t]*(.+?)[ \t]*\#*\n+/gm,
		function(wholeMatch,m1,m2) {
			var h_level = m1.length;
			return hashBlock("<h" + h_level + ' id="' + headerId(m2) + '">' + _RunSpanGamut(m2) + "</h" + h_level + ">");
		});

	function headerId(m) {
		return m.replace(/[^\w]/g, '').toLowerCase();
	}
	return text;
}

// This declaration keeps Dojo compressor from outputting garbage:
var _ProcessListItems;

var _DoLists = function(text) {
//
// Form HTML ordered (numbered) and unordered (bulleted) lists.
//

	// attacklab: add sentinel to hack around khtml/safari bug:
	// http://bugs.webkit.org/show_bug.cgi?id=11231
	text += "~0";

	// Re-usable pattern to match any entirel ul or ol list:

	/*
		var whole_list = /
		(									// $1 = whole list
			(								// $2
				[ ]{0,3}					// attacklab: g_tab_width - 1
				([*+-]|\d+[.])				// $3 = first list item marker
				[ \t]+
			)
			[^\r]+?
			(								// $4
				~0							// sentinel for workaround; should be $
			|
				\n{2,}
				(?=\S)
				(?!							// Negative lookahead for another list item marker
					[ \t]*
					(?:[*+-]|\d+[.])[ \t]+
				)
			)
		)/g
	*/
	var whole_list = /^(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm;

	if (g_list_level) {
		text = text.replace(whole_list,function(wholeMatch,m1,m2) {
			var list = m1;
			var list_type = (m2.search(/[*+-]/g)>-1) ? "ul" : "ol";

			// Turn double returns into triple returns, so that we can make a
			// paragraph for the last item in a list, if necessary:
			list = list.replace(/\n{2,}/g,"\n\n\n");;
			var result = _ProcessListItems(list);

			// Trim any trailing whitespace, to put the closing `</$list_type>`
			// up on the preceding line, to get it past the current stupid
			// HTML block parser. This is a hack to work around the terrible
			// hack that is the HTML block parser.
			result = result.replace(/\s+$/,"");
			result = "<"+list_type+">" + result + "</"+list_type+">\n";
			return result;
		});
	} else {
		whole_list = /(\n\n|^\n?)(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/g;
		text = text.replace(whole_list,function(wholeMatch,m1,m2,m3) {
			var runup = m1;
			var list = m2;

			var list_type = (m3.search(/[*+-]/g)>-1) ? "ul" : "ol";
			// Turn double returns into triple returns, so that we can make a
			// paragraph for the last item in a list, if necessary:
			var list = list.replace(/\n{2,}/g,"\n\n\n");;
			var result = _ProcessListItems(list);
			result = runup + "<"+list_type+">\n" + result + "</"+list_type+">\n";
			return result;
		});
	}

	// attacklab: strip sentinel
	text = text.replace(/~0/,"");

	return text;
}

_ProcessListItems = function(list_str) {
//
//  Process the contents of a single ordered or unordered list, splitting it
//  into individual list items.
//
	// The $g_list_level global keeps track of when we're inside a list.
	// Each time we enter a list, we increment it; when we leave a list,
	// we decrement. If it's zero, we're not in a list anymore.
	//
	// We do this because when we're not inside a list, we want to treat
	// something like this:
	//
	//    I recommend upgrading to version
	//    8. Oops, now this line is treated
	//    as a sub-list.
	//
	// As a single paragraph, despite the fact that the second line starts
	// with a digit-period-space sequence.
	//
	// Whereas when we're inside a list (or sub-list), that line will be
	// treated as the start of a sub-list. What a kludge, huh? This is
	// an aspect of Markdown's syntax that's hard to parse perfectly
	// without resorting to mind-reading. Perhaps the solution is to
	// change the syntax rules such that sub-lists must start with a
	// starting cardinal number; e.g. "1." or "a.".

	g_list_level++;

	// trim trailing blank lines:
	list_str = list_str.replace(/\n{2,}$/,"\n");

	// attacklab: add sentinel to emulate \z
	list_str += "~0";

	/*
		list_str = list_str.replace(/
			(\n)?							// leading line = $1
			(^[ \t]*)						// leading whitespace = $2
			([*+-]|\d+[.]) [ \t]+			// list marker = $3
			([^\r]+?						// list item text   = $4
			(\n{1,2}))
			(?= \n* (~0 | \2 ([*+-]|\d+[.]) [ \t]+))
		/gm, function(){...});
	*/
	list_str = list_str.replace(/(\n)?(^[ \t]*)([*+-]|\d+[.])[ \t]+([^\r]+?(\n{1,2}))(?=\n*(~0|\2([*+-]|\d+[.])[ \t]+))/gm,
		function(wholeMatch,m1,m2,m3,m4){
			var item = m4;
			var leading_line = m1;
			var leading_space = m2;

			if (leading_line || (item.search(/\n{2,}/)>-1)) {
				item = _RunBlockGamut(_Outdent(item));
			}
			else {
				// Recursion for sub-lists:
				item = _DoLists(_Outdent(item));
				item = item.replace(/\n$/,""); // chomp(item)
				item = _RunSpanGamut(item);
			}

			return  "<li>" + item + "</li>\n";
		}
	);

	// attacklab: strip sentinel
	list_str = list_str.replace(/~0/g,"");

	g_list_level--;
	return list_str;
}


var _DoCodeBlocks = function(text) {
//
//  Process Markdown `<pre><code>` blocks.
//

	/*
		text = text.replace(text,
			/(?:\n\n|^)
			(								// $1 = the code block -- one or more lines, starting with a space/tab
				(?:
					(?:[ ]{4}|\t)			// Lines must start with a tab or a tab-width of spaces - attacklab: g_tab_width
					.*\n+
				)+
			)
			(\n*[ ]{0,3}[^ \t\n]|(?=~0))	// attacklab: g_tab_width
		/g,function(){...});
	*/

	// attacklab: sentinel workarounds for lack of \A and \Z, safari\khtml bug
	text += "~0";

	text = text.replace(/(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=~0))/g,
		function(wholeMatch,m1,m2) {
			var codeblock = m1;
			var nextChar = m2;

			codeblock = _EncodeCode( _Outdent(codeblock));
			codeblock = _Detab(codeblock);
			codeblock = codeblock.replace(/^\n+/g,""); // trim leading newlines
			codeblock = codeblock.replace(/\n+$/g,""); // trim trailing whitespace

			codeblock = "<pre><code>" + codeblock + "\n</code></pre>";

			return hashBlock(codeblock) + nextChar;
		}
	);

	// attacklab: strip sentinel
	text = text.replace(/~0/,"");

	return text;
};

var _DoGithubCodeBlocks = function(text) {
//
//  Process Github-style code blocks
//  Example:
//  ```ruby
//  def hello_world(x)
//    puts "Hello, #{x}"
//  end
//  ```
//


	// attacklab: sentinel workarounds for lack of \A and \Z, safari\khtml bug
	text += "~0";

	text = text.replace(/(?:^|\n)```(.*)\n([\s\S]*?)\n```/g,
		function(wholeMatch,m1,m2) {
			var language = m1;
			var codeblock = m2;

			codeblock = _EncodeCode(codeblock);
			codeblock = _Detab(codeblock);
			codeblock = codeblock.replace(/^\n+/g,""); // trim leading newlines
			codeblock = codeblock.replace(/\n+$/g,""); // trim trailing whitespace

			codeblock = "<pre><code" + (language ? " class=\"" + language + '"' : "") + ">" + codeblock + "\n</code></pre>";

			return hashBlock(codeblock);
		}
	);

	// attacklab: strip sentinel
	text = text.replace(/~0/,"");

	return text;
}

var hashBlock = function(text) {
	text = text.replace(/(^\n+|\n+$)/g,"");
	return "\n\n~K" + (g_html_blocks.push(text)-1) + "K\n\n";
}

var _DoCodeSpans = function(text) {
//
//   *  Backtick quotes are used for <code></code> spans.
//
//   *  You can use multiple backticks as the delimiters if you want to
//	 include literal backticks in the code span. So, this input:
//
//		 Just type ``foo `bar` baz`` at the prompt.
//
//	   Will translate to:
//
//		 <p>Just type <code>foo `bar` baz</code> at the prompt.</p>
//
//	There's no arbitrary limit to the number of backticks you
//	can use as delimters. If you need three consecutive backticks
//	in your code, use four for delimiters, etc.
//
//  *  You can use spaces to get literal backticks at the edges:
//
//		 ... type `` `bar` `` ...
//
//	   Turns to:
//
//		 ... type <code>`bar`</code> ...
//

	/*
		text = text.replace(/
			(^|[^\\])					// Character before opening ` can't be a backslash
			(`+)						// $2 = Opening run of `
			(							// $3 = The code block
				[^\r]*?
				[^`]					// attacklab: work around lack of lookbehind
			)
			\2							// Matching closer
			(?!`)
		/gm, function(){...});
	*/

	text = text.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
		function(wholeMatch,m1,m2,m3,m4) {
			var c = m3;
			c = c.replace(/^([ \t]*)/g,"");	// leading whitespace
			c = c.replace(/[ \t]*$/g,"");	// trailing whitespace
			c = _EncodeCode(c);
			return m1+"<code>"+c+"</code>";
		});

	return text;
}

var _EncodeCode = function(text) {
//
// Encode/escape certain characters inside Markdown code runs.
// The point is that in code, these characters are literals,
// and lose their special Markdown meanings.
//
	// Encode all ampersands; HTML entities are not
	// entities within a Markdown code span.
	text = text.replace(/&/g,"&amp;");

	// Do the angle bracket song and dance:
	text = text.replace(/</g,"&lt;");
	text = text.replace(/>/g,"&gt;");

	// Now, escape characters that are magic in Markdown:
	text = escapeCharacters(text,"\*_{}[]\\",false);

// jj the line above breaks this:
//---

//* Item

//   1. Subitem

//            special char: *
//---

	return text;
}


var _DoItalicsAndBold = function(text) {

	// <strong> must go first:
	text = text.replace(/(\*\*|__)(?=\S)([^\r]*?\S[*_]*)\1/g,
		"<strong>$2</strong>");

	text = text.replace(/(\*|_)(?=\S)([^\r]*?\S)\1/g,
		"<em>$2</em>");

	return text;
}


var _DoBlockQuotes = function(text) {

	/*
		text = text.replace(/
		(								// Wrap whole match in $1
			(
				^[ \t]*>[ \t]?			// '>' at the start of a line
				.+\n					// rest of the first line
				(.+\n)*					// subsequent consecutive lines
				\n*						// blanks
			)+
		)
		/gm, function(){...});
	*/

	text = text.replace(/((^[ \t]*>[ \t]?.+\n(.+\n)*\n*)+)/gm,
		function(wholeMatch,m1) {
			var bq = m1;

			// attacklab: hack around Konqueror 3.5.4 bug:
			// "----------bug".replace(/^-/g,"") == "bug"

			bq = bq.replace(/^[ \t]*>[ \t]?/gm,"~0");	// trim one level of quoting

			// attacklab: clean up hack
			bq = bq.replace(/~0/g,"");

			bq = bq.replace(/^[ \t]+$/gm,"");		// trim whitespace-only lines
			bq = _RunBlockGamut(bq);				// recurse

			bq = bq.replace(/(^|\n)/g,"$1  ");
			// These leading spaces screw with <pre> content, so we need to fix that:
			bq = bq.replace(
					/(\s*<pre>[^\r]+?<\/pre>)/gm,
				function(wholeMatch,m1) {
					var pre = m1;
					// attacklab: hack around Konqueror 3.5.4 bug:
					pre = pre.replace(/^  /mg,"~0");
					pre = pre.replace(/~0/g,"");
					return pre;
				});

			return hashBlock("<blockquote>\n" + bq + "\n</blockquote>");
		});
	return text;
}


var _FormParagraphs = function(text) {
//
//  Params:
//    $text - string to process with html <p> tags
//

	// Strip leading and trailing lines:
	text = text.replace(/^\n+/g,"");
	text = text.replace(/\n+$/g,"");

	var grafs = text.split(/\n{2,}/g);
	var grafsOut = [];

	//
	// Wrap <p> tags.
	//
	var end = grafs.length;
	for (var i=0; i<end; i++) {
		var str = grafs[i];

		// if this is an HTML marker, copy it
		if (str.search(/~K(\d+)K/g) >= 0) {
			grafsOut.push(str);
		}
		else if (str.search(/\S/) >= 0) {
			str = _RunSpanGamut(str);
			str = str.replace(/^([ \t]*)/g,"<p>");
			str += "</p>"
			grafsOut.push(str);
		}

	}

	//
	// Unhashify HTML blocks
	//
	end = grafsOut.length;
	for (var i=0; i<end; i++) {
		// if this is a marker for an html block...
		while (grafsOut[i].search(/~K(\d+)K/) >= 0) {
			var blockText = g_html_blocks[RegExp.$1];
			blockText = blockText.replace(/\$/g,"$$$$"); // Escape any dollar signs
			grafsOut[i] = grafsOut[i].replace(/~K\d+K/,blockText);
		}
	}

	return grafsOut.join("\n\n");
}


var _EncodeAmpsAndAngles = function(text) {
// Smart processing for ampersands and angle brackets that need to be encoded.

	// Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:
	//   http://bumppo.net/projects/amputator/
	text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g,"&amp;");

	// Encode naked <'s
	text = text.replace(/<(?![a-z\/?\$!])/gi,"&lt;");

	return text;
}


var _EncodeBackslashEscapes = function(text) {
//
//   Parameter:  String.
//   Returns:	The string, with after processing the following backslash
//			   escape sequences.
//

	// attacklab: The polite way to do this is with the new
	// escapeCharacters() function:
	//
	// 	text = escapeCharacters(text,"\\",true);
	// 	text = escapeCharacters(text,"`*_{}[]()>#+-.!",true);
	//
	// ...but we're sidestepping its use of the (slow) RegExp constructor
	// as an optimization for Firefox.  This function gets called a LOT.

	text = text.replace(/\\(\\)/g,escapeCharacters_callback);
	text = text.replace(/\\([`*_{}\[\]()>#+-.!])/g,escapeCharacters_callback);
	return text;
}


var _DoAutoLinks = function(text) {

	text = text.replace(/<((https?|ftp|dict):[^'">\s]+)>/gi,"<a href=\"$1\">$1</a>");

	// Email addresses: <address@domain.foo>

	/*
		text = text.replace(/
			<
			(?:mailto:)?
			(
				[-.\w]+
				\@
				[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+
			)
			>
		/gi, _DoAutoLinks_callback());
	*/
	text = text.replace(/<(?:mailto:)?([-.\w]+\@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,
		function(wholeMatch,m1) {
			return _EncodeEmailAddress( _UnescapeSpecialChars(m1) );
		}
	);

	return text;
}


var _EncodeEmailAddress = function(addr) {
//
//  Input: an email address, e.g. "foo@example.com"
//
//  Output: the email address as a mailto link, with each character
//	of the address encoded as either a decimal or hex entity, in
//	the hopes of foiling most address harvesting spam bots. E.g.:
//
//	<a href="&#x6D;&#97;&#105;&#108;&#x74;&#111;:&#102;&#111;&#111;&#64;&#101;
//	   x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;">&#102;&#111;&#111;
//	   &#64;&#101;x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;</a>
//
//  Based on a filter by Matthew Wickline, posted to the BBEdit-Talk
//  mailing list: <http://tinyurl.com/yu7ue>
//

	var encode = [
		function(ch){return "&#"+ch.charCodeAt(0)+";";},
		function(ch){return "&#x"+ch.charCodeAt(0).toString(16)+";";},
		function(ch){return ch;}
	];

	addr = "mailto:" + addr;

	addr = addr.replace(/./g, function(ch) {
		if (ch == "@") {
		   	// this *must* be encoded. I insist.
			ch = encode[Math.floor(Math.random()*2)](ch);
		} else if (ch !=":") {
			// leave ':' alone (to spot mailto: later)
			var r = Math.random();
			// roughly 10% raw, 45% hex, 45% dec
			ch =  (
					r > .9  ?	encode[2](ch)   :
					r > .45 ?	encode[1](ch)   :
								encode[0](ch)
				);
		}
		return ch;
	});

	addr = "<a href=\"" + addr + "\">" + addr + "</a>";
	addr = addr.replace(/">.+:/g,"\">"); // strip the mailto: from the visible part

	return addr;
}


var _UnescapeSpecialChars = function(text) {
//
// Swap back in all the special characters we've hidden.
//
	text = text.replace(/~E(\d+)E/g,
		function(wholeMatch,m1) {
			var charCodeToReplace = parseInt(m1);
			return String.fromCharCode(charCodeToReplace);
		}
	);
	return text;
}


var _Outdent = function(text) {
//
// Remove one level of line-leading tabs or spaces
//

	// attacklab: hack around Konqueror 3.5.4 bug:
	// "----------bug".replace(/^-/g,"") == "bug"

	text = text.replace(/^(\t|[ ]{1,4})/gm,"~0"); // attacklab: g_tab_width

	// attacklab: clean up hack
	text = text.replace(/~0/g,"")

	return text;
}

var _Detab = function(text) {
// attacklab: Detab's completely rewritten for speed.
// In perl we could fix it by anchoring the regexp with \G.
// In javascript we're less fortunate.

	// expand first n-1 tabs
	text = text.replace(/\t(?=\t)/g,"    "); // attacklab: g_tab_width

	// replace the nth with two sentinels
	text = text.replace(/\t/g,"~A~B");

	// use the sentinel to anchor our regex so it doesn't explode
	text = text.replace(/~B(.+?)~A/g,
		function(wholeMatch,m1,m2) {
			var leadingText = m1;
			var numSpaces = 4 - leadingText.length % 4;  // attacklab: g_tab_width

			// there *must* be a better way to do this:
			for (var i=0; i<numSpaces; i++) leadingText+=" ";

			return leadingText;
		}
	);

	// clean up sentinels
	text = text.replace(/~A/g,"    ");  // attacklab: g_tab_width
	text = text.replace(/~B/g,"");

	return text;
}


//
//  attacklab: Utility functions
//


var escapeCharacters = function(text, charsToEscape, afterBackslash) {
	// First we have to escape the escape characters so that
	// we can build a character class out of them
	var regexString = "([" + charsToEscape.replace(/([\[\]\\])/g,"\\$1") + "])";

	if (afterBackslash) {
		regexString = "\\\\" + regexString;
	}

	var regex = new RegExp(regexString,"g");
	text = text.replace(regex,escapeCharacters_callback);

	return text;
}


var escapeCharacters_callback = function(wholeMatch,m1) {
	var charCodeToEscape = m1.charCodeAt(0);
	return "~E"+charCodeToEscape+"E";
}

} // end of Showdown.converter


// export
if (typeof module !== 'undefined') module.exports = Showdown;

// stolen from AMD branch of underscore
// AMD define happens at the end for compatibility with AMD loaders
// that don't enforce next-turn semantics on modules.
if (typeof define === 'function' && define.amd) {
    define('showdown', function() {
        return Showdown;
    });
}
;
//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
!function(){var n="object"==typeof self&&self.self===self&&self||"object"==typeof global&&global.global===global&&global||this||{},r=n._,e=Array.prototype,o=Object.prototype,s="undefined"!=typeof Symbol?Symbol.prototype:null,u=e.push,c=e.slice,p=o.toString,i=o.hasOwnProperty,t=Array.isArray,a=Object.keys,l=Object.create,f=function(){},h=function(n){return n instanceof h?n:this instanceof h?void(this._wrapped=n):new h(n)};"undefined"==typeof exports||exports.nodeType?n._=h:("undefined"!=typeof module&&!module.nodeType&&module.exports&&(exports=module.exports=h),exports._=h),h.VERSION="1.9.1";var v,y=function(u,i,n){if(void 0===i)return u;switch(null==n?3:n){case 1:return function(n){return u.call(i,n)};case 3:return function(n,r,t){return u.call(i,n,r,t)};case 4:return function(n,r,t,e){return u.call(i,n,r,t,e)}}return function(){return u.apply(i,arguments)}},d=function(n,r,t){return h.iteratee!==v?h.iteratee(n,r):null==n?h.identity:h.isFunction(n)?y(n,r,t):h.isObject(n)&&!h.isArray(n)?h.matcher(n):h.property(n)};h.iteratee=v=function(n,r){return d(n,r,1/0)};var g=function(u,i){return i=null==i?u.length-1:+i,function(){for(var n=Math.max(arguments.length-i,0),r=Array(n),t=0;t<n;t++)r[t]=arguments[t+i];switch(i){case 0:return u.call(this,r);case 1:return u.call(this,arguments[0],r);case 2:return u.call(this,arguments[0],arguments[1],r)}var e=Array(i+1);for(t=0;t<i;t++)e[t]=arguments[t];return e[i]=r,u.apply(this,e)}},m=function(n){if(!h.isObject(n))return{};if(l)return l(n);f.prototype=n;var r=new f;return f.prototype=null,r},b=function(r){return function(n){return null==n?void 0:n[r]}},j=function(n,r){return null!=n&&i.call(n,r)},x=function(n,r){for(var t=r.length,e=0;e<t;e++){if(null==n)return;n=n[r[e]]}return t?n:void 0},_=Math.pow(2,53)-1,A=b("length"),w=function(n){var r=A(n);return"number"==typeof r&&0<=r&&r<=_};h.each=h.forEach=function(n,r,t){var e,u;if(r=y(r,t),w(n))for(e=0,u=n.length;e<u;e++)r(n[e],e,n);else{var i=h.keys(n);for(e=0,u=i.length;e<u;e++)r(n[i[e]],i[e],n)}return n},h.map=h.collect=function(n,r,t){r=d(r,t);for(var e=!w(n)&&h.keys(n),u=(e||n).length,i=Array(u),o=0;o<u;o++){var a=e?e[o]:o;i[o]=r(n[a],a,n)}return i};var O=function(c){return function(n,r,t,e){var u=3<=arguments.length;return function(n,r,t,e){var u=!w(n)&&h.keys(n),i=(u||n).length,o=0<c?0:i-1;for(e||(t=n[u?u[o]:o],o+=c);0<=o&&o<i;o+=c){var a=u?u[o]:o;t=r(t,n[a],a,n)}return t}(n,y(r,e,4),t,u)}};h.reduce=h.foldl=h.inject=O(1),h.reduceRight=h.foldr=O(-1),h.find=h.detect=function(n,r,t){var e=(w(n)?h.findIndex:h.findKey)(n,r,t);if(void 0!==e&&-1!==e)return n[e]},h.filter=h.select=function(n,e,r){var u=[];return e=d(e,r),h.each(n,function(n,r,t){e(n,r,t)&&u.push(n)}),u},h.reject=function(n,r,t){return h.filter(n,h.negate(d(r)),t)},h.every=h.all=function(n,r,t){r=d(r,t);for(var e=!w(n)&&h.keys(n),u=(e||n).length,i=0;i<u;i++){var o=e?e[i]:i;if(!r(n[o],o,n))return!1}return!0},h.some=h.any=function(n,r,t){r=d(r,t);for(var e=!w(n)&&h.keys(n),u=(e||n).length,i=0;i<u;i++){var o=e?e[i]:i;if(r(n[o],o,n))return!0}return!1},h.contains=h.includes=h.include=function(n,r,t,e){return w(n)||(n=h.values(n)),("number"!=typeof t||e)&&(t=0),0<=h.indexOf(n,r,t)},h.invoke=g(function(n,t,e){var u,i;return h.isFunction(t)?i=t:h.isArray(t)&&(u=t.slice(0,-1),t=t[t.length-1]),h.map(n,function(n){var r=i;if(!r){if(u&&u.length&&(n=x(n,u)),null==n)return;r=n[t]}return null==r?r:r.apply(n,e)})}),h.pluck=function(n,r){return h.map(n,h.property(r))},h.where=function(n,r){return h.filter(n,h.matcher(r))},h.findWhere=function(n,r){return h.find(n,h.matcher(r))},h.max=function(n,e,r){var t,u,i=-1/0,o=-1/0;if(null==e||"number"==typeof e&&"object"!=typeof n[0]&&null!=n)for(var a=0,c=(n=w(n)?n:h.values(n)).length;a<c;a++)null!=(t=n[a])&&i<t&&(i=t);else e=d(e,r),h.each(n,function(n,r,t){u=e(n,r,t),(o<u||u===-1/0&&i===-1/0)&&(i=n,o=u)});return i},h.min=function(n,e,r){var t,u,i=1/0,o=1/0;if(null==e||"number"==typeof e&&"object"!=typeof n[0]&&null!=n)for(var a=0,c=(n=w(n)?n:h.values(n)).length;a<c;a++)null!=(t=n[a])&&t<i&&(i=t);else e=d(e,r),h.each(n,function(n,r,t){((u=e(n,r,t))<o||u===1/0&&i===1/0)&&(i=n,o=u)});return i},h.shuffle=function(n){return h.sample(n,1/0)},h.sample=function(n,r,t){if(null==r||t)return w(n)||(n=h.values(n)),n[h.random(n.length-1)];var e=w(n)?h.clone(n):h.values(n),u=A(e);r=Math.max(Math.min(r,u),0);for(var i=u-1,o=0;o<r;o++){var a=h.random(o,i),c=e[o];e[o]=e[a],e[a]=c}return e.slice(0,r)},h.sortBy=function(n,e,r){var u=0;return e=d(e,r),h.pluck(h.map(n,function(n,r,t){return{value:n,index:u++,criteria:e(n,r,t)}}).sort(function(n,r){var t=n.criteria,e=r.criteria;if(t!==e){if(e<t||void 0===t)return 1;if(t<e||void 0===e)return-1}return n.index-r.index}),"value")};var k=function(o,r){return function(e,u,n){var i=r?[[],[]]:{};return u=d(u,n),h.each(e,function(n,r){var t=u(n,r,e);o(i,n,t)}),i}};h.groupBy=k(function(n,r,t){j(n,t)?n[t].push(r):n[t]=[r]}),h.indexBy=k(function(n,r,t){n[t]=r}),h.countBy=k(function(n,r,t){j(n,t)?n[t]++:n[t]=1});var S=/[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;h.toArray=function(n){return n?h.isArray(n)?c.call(n):h.isString(n)?n.match(S):w(n)?h.map(n,h.identity):h.values(n):[]},h.size=function(n){return null==n?0:w(n)?n.length:h.keys(n).length},h.partition=k(function(n,r,t){n[t?0:1].push(r)},!0),h.first=h.head=h.take=function(n,r,t){return null==n||n.length<1?null==r?void 0:[]:null==r||t?n[0]:h.initial(n,n.length-r)},h.initial=function(n,r,t){return c.call(n,0,Math.max(0,n.length-(null==r||t?1:r)))},h.last=function(n,r,t){return null==n||n.length<1?null==r?void 0:[]:null==r||t?n[n.length-1]:h.rest(n,Math.max(0,n.length-r))},h.rest=h.tail=h.drop=function(n,r,t){return c.call(n,null==r||t?1:r)},h.compact=function(n){return h.filter(n,Boolean)};var M=function(n,r,t,e){for(var u=(e=e||[]).length,i=0,o=A(n);i<o;i++){var a=n[i];if(w(a)&&(h.isArray(a)||h.isArguments(a)))if(r)for(var c=0,l=a.length;c<l;)e[u++]=a[c++];else M(a,r,t,e),u=e.length;else t||(e[u++]=a)}return e};h.flatten=function(n,r){return M(n,r,!1)},h.without=g(function(n,r){return h.difference(n,r)}),h.uniq=h.unique=function(n,r,t,e){h.isBoolean(r)||(e=t,t=r,r=!1),null!=t&&(t=d(t,e));for(var u=[],i=[],o=0,a=A(n);o<a;o++){var c=n[o],l=t?t(c,o,n):c;r&&!t?(o&&i===l||u.push(c),i=l):t?h.contains(i,l)||(i.push(l),u.push(c)):h.contains(u,c)||u.push(c)}return u},h.union=g(function(n){return h.uniq(M(n,!0,!0))}),h.intersection=function(n){for(var r=[],t=arguments.length,e=0,u=A(n);e<u;e++){var i=n[e];if(!h.contains(r,i)){var o;for(o=1;o<t&&h.contains(arguments[o],i);o++);o===t&&r.push(i)}}return r},h.difference=g(function(n,r){return r=M(r,!0,!0),h.filter(n,function(n){return!h.contains(r,n)})}),h.unzip=function(n){for(var r=n&&h.max(n,A).length||0,t=Array(r),e=0;e<r;e++)t[e]=h.pluck(n,e);return t},h.zip=g(h.unzip),h.object=function(n,r){for(var t={},e=0,u=A(n);e<u;e++)r?t[n[e]]=r[e]:t[n[e][0]]=n[e][1];return t};var F=function(i){return function(n,r,t){r=d(r,t);for(var e=A(n),u=0<i?0:e-1;0<=u&&u<e;u+=i)if(r(n[u],u,n))return u;return-1}};h.findIndex=F(1),h.findLastIndex=F(-1),h.sortedIndex=function(n,r,t,e){for(var u=(t=d(t,e,1))(r),i=0,o=A(n);i<o;){var a=Math.floor((i+o)/2);t(n[a])<u?i=a+1:o=a}return i};var E=function(i,o,a){return function(n,r,t){var e=0,u=A(n);if("number"==typeof t)0<i?e=0<=t?t:Math.max(t+u,e):u=0<=t?Math.min(t+1,u):t+u+1;else if(a&&t&&u)return n[t=a(n,r)]===r?t:-1;if(r!=r)return 0<=(t=o(c.call(n,e,u),h.isNaN))?t+e:-1;for(t=0<i?e:u-1;0<=t&&t<u;t+=i)if(n[t]===r)return t;return-1}};h.indexOf=E(1,h.findIndex,h.sortedIndex),h.lastIndexOf=E(-1,h.findLastIndex),h.range=function(n,r,t){null==r&&(r=n||0,n=0),t||(t=r<n?-1:1);for(var e=Math.max(Math.ceil((r-n)/t),0),u=Array(e),i=0;i<e;i++,n+=t)u[i]=n;return u},h.chunk=function(n,r){if(null==r||r<1)return[];for(var t=[],e=0,u=n.length;e<u;)t.push(c.call(n,e,e+=r));return t};var N=function(n,r,t,e,u){if(!(e instanceof r))return n.apply(t,u);var i=m(n.prototype),o=n.apply(i,u);return h.isObject(o)?o:i};h.bind=g(function(r,t,e){if(!h.isFunction(r))throw new TypeError("Bind must be called on a function");var u=g(function(n){return N(r,u,t,this,e.concat(n))});return u}),h.partial=g(function(u,i){var o=h.partial.placeholder,a=function(){for(var n=0,r=i.length,t=Array(r),e=0;e<r;e++)t[e]=i[e]===o?arguments[n++]:i[e];for(;n<arguments.length;)t.push(arguments[n++]);return N(u,a,this,this,t)};return a}),(h.partial.placeholder=h).bindAll=g(function(n,r){var t=(r=M(r,!1,!1)).length;if(t<1)throw new Error("bindAll must be passed function names");for(;t--;){var e=r[t];n[e]=h.bind(n[e],n)}}),h.memoize=function(e,u){var i=function(n){var r=i.cache,t=""+(u?u.apply(this,arguments):n);return j(r,t)||(r[t]=e.apply(this,arguments)),r[t]};return i.cache={},i},h.delay=g(function(n,r,t){return setTimeout(function(){return n.apply(null,t)},r)}),h.defer=h.partial(h.delay,h,1),h.throttle=function(t,e,u){var i,o,a,c,l=0;u||(u={});var f=function(){l=!1===u.leading?0:h.now(),i=null,c=t.apply(o,a),i||(o=a=null)},n=function(){var n=h.now();l||!1!==u.leading||(l=n);var r=e-(n-l);return o=this,a=arguments,r<=0||e<r?(i&&(clearTimeout(i),i=null),l=n,c=t.apply(o,a),i||(o=a=null)):i||!1===u.trailing||(i=setTimeout(f,r)),c};return n.cancel=function(){clearTimeout(i),l=0,i=o=a=null},n},h.debounce=function(t,e,u){var i,o,a=function(n,r){i=null,r&&(o=t.apply(n,r))},n=g(function(n){if(i&&clearTimeout(i),u){var r=!i;i=setTimeout(a,e),r&&(o=t.apply(this,n))}else i=h.delay(a,e,this,n);return o});return n.cancel=function(){clearTimeout(i),i=null},n},h.wrap=function(n,r){return h.partial(r,n)},h.negate=function(n){return function(){return!n.apply(this,arguments)}},h.compose=function(){var t=arguments,e=t.length-1;return function(){for(var n=e,r=t[e].apply(this,arguments);n--;)r=t[n].call(this,r);return r}},h.after=function(n,r){return function(){if(--n<1)return r.apply(this,arguments)}},h.before=function(n,r){var t;return function(){return 0<--n&&(t=r.apply(this,arguments)),n<=1&&(r=null),t}},h.once=h.partial(h.before,2),h.restArguments=g;var I=!{toString:null}.propertyIsEnumerable("toString"),T=["valueOf","isPrototypeOf","toString","propertyIsEnumerable","hasOwnProperty","toLocaleString"],B=function(n,r){var t=T.length,e=n.constructor,u=h.isFunction(e)&&e.prototype||o,i="constructor";for(j(n,i)&&!h.contains(r,i)&&r.push(i);t--;)(i=T[t])in n&&n[i]!==u[i]&&!h.contains(r,i)&&r.push(i)};h.keys=function(n){if(!h.isObject(n))return[];if(a)return a(n);var r=[];for(var t in n)j(n,t)&&r.push(t);return I&&B(n,r),r},h.allKeys=function(n){if(!h.isObject(n))return[];var r=[];for(var t in n)r.push(t);return I&&B(n,r),r},h.values=function(n){for(var r=h.keys(n),t=r.length,e=Array(t),u=0;u<t;u++)e[u]=n[r[u]];return e},h.mapObject=function(n,r,t){r=d(r,t);for(var e=h.keys(n),u=e.length,i={},o=0;o<u;o++){var a=e[o];i[a]=r(n[a],a,n)}return i},h.pairs=function(n){for(var r=h.keys(n),t=r.length,e=Array(t),u=0;u<t;u++)e[u]=[r[u],n[r[u]]];return e},h.invert=function(n){for(var r={},t=h.keys(n),e=0,u=t.length;e<u;e++)r[n[t[e]]]=t[e];return r},h.functions=h.methods=function(n){var r=[];for(var t in n)h.isFunction(n[t])&&r.push(t);return r.sort()};var R=function(c,l){return function(n){var r=arguments.length;if(l&&(n=Object(n)),r<2||null==n)return n;for(var t=1;t<r;t++)for(var e=arguments[t],u=c(e),i=u.length,o=0;o<i;o++){var a=u[o];l&&void 0!==n[a]||(n[a]=e[a])}return n}};h.extend=R(h.allKeys),h.extendOwn=h.assign=R(h.keys),h.findKey=function(n,r,t){r=d(r,t);for(var e,u=h.keys(n),i=0,o=u.length;i<o;i++)if(r(n[e=u[i]],e,n))return e};var q,K,z=function(n,r,t){return r in t};h.pick=g(function(n,r){var t={},e=r[0];if(null==n)return t;h.isFunction(e)?(1<r.length&&(e=y(e,r[1])),r=h.allKeys(n)):(e=z,r=M(r,!1,!1),n=Object(n));for(var u=0,i=r.length;u<i;u++){var o=r[u],a=n[o];e(a,o,n)&&(t[o]=a)}return t}),h.omit=g(function(n,t){var r,e=t[0];return h.isFunction(e)?(e=h.negate(e),1<t.length&&(r=t[1])):(t=h.map(M(t,!1,!1),String),e=function(n,r){return!h.contains(t,r)}),h.pick(n,e,r)}),h.defaults=R(h.allKeys,!0),h.create=function(n,r){var t=m(n);return r&&h.extendOwn(t,r),t},h.clone=function(n){return h.isObject(n)?h.isArray(n)?n.slice():h.extend({},n):n},h.tap=function(n,r){return r(n),n},h.isMatch=function(n,r){var t=h.keys(r),e=t.length;if(null==n)return!e;for(var u=Object(n),i=0;i<e;i++){var o=t[i];if(r[o]!==u[o]||!(o in u))return!1}return!0},q=function(n,r,t,e){if(n===r)return 0!==n||1/n==1/r;if(null==n||null==r)return!1;if(n!=n)return r!=r;var u=typeof n;return("function"===u||"object"===u||"object"==typeof r)&&K(n,r,t,e)},K=function(n,r,t,e){n instanceof h&&(n=n._wrapped),r instanceof h&&(r=r._wrapped);var u=p.call(n);if(u!==p.call(r))return!1;switch(u){case"[object RegExp]":case"[object String]":return""+n==""+r;case"[object Number]":return+n!=+n?+r!=+r:0==+n?1/+n==1/r:+n==+r;case"[object Date]":case"[object Boolean]":return+n==+r;case"[object Symbol]":return s.valueOf.call(n)===s.valueOf.call(r)}var i="[object Array]"===u;if(!i){if("object"!=typeof n||"object"!=typeof r)return!1;var o=n.constructor,a=r.constructor;if(o!==a&&!(h.isFunction(o)&&o instanceof o&&h.isFunction(a)&&a instanceof a)&&"constructor"in n&&"constructor"in r)return!1}e=e||[];for(var c=(t=t||[]).length;c--;)if(t[c]===n)return e[c]===r;if(t.push(n),e.push(r),i){if((c=n.length)!==r.length)return!1;for(;c--;)if(!q(n[c],r[c],t,e))return!1}else{var l,f=h.keys(n);if(c=f.length,h.keys(r).length!==c)return!1;for(;c--;)if(l=f[c],!j(r,l)||!q(n[l],r[l],t,e))return!1}return t.pop(),e.pop(),!0},h.isEqual=function(n,r){return q(n,r)},h.isEmpty=function(n){return null==n||(w(n)&&(h.isArray(n)||h.isString(n)||h.isArguments(n))?0===n.length:0===h.keys(n).length)},h.isElement=function(n){return!(!n||1!==n.nodeType)},h.isArray=t||function(n){return"[object Array]"===p.call(n)},h.isObject=function(n){var r=typeof n;return"function"===r||"object"===r&&!!n},h.each(["Arguments","Function","String","Number","Date","RegExp","Error","Symbol","Map","WeakMap","Set","WeakSet"],function(r){h["is"+r]=function(n){return p.call(n)==="[object "+r+"]"}}),h.isArguments(arguments)||(h.isArguments=function(n){return j(n,"callee")});var D=n.document&&n.document.childNodes;"function"!=typeof/./&&"object"!=typeof Int8Array&&"function"!=typeof D&&(h.isFunction=function(n){return"function"==typeof n||!1}),h.isFinite=function(n){return!h.isSymbol(n)&&isFinite(n)&&!isNaN(parseFloat(n))},h.isNaN=function(n){return h.isNumber(n)&&isNaN(n)},h.isBoolean=function(n){return!0===n||!1===n||"[object Boolean]"===p.call(n)},h.isNull=function(n){return null===n},h.isUndefined=function(n){return void 0===n},h.has=function(n,r){if(!h.isArray(r))return j(n,r);for(var t=r.length,e=0;e<t;e++){var u=r[e];if(null==n||!i.call(n,u))return!1;n=n[u]}return!!t},h.noConflict=function(){return n._=r,this},h.identity=function(n){return n},h.constant=function(n){return function(){return n}},h.noop=function(){},h.property=function(r){return h.isArray(r)?function(n){return x(n,r)}:b(r)},h.propertyOf=function(r){return null==r?function(){}:function(n){return h.isArray(n)?x(r,n):r[n]}},h.matcher=h.matches=function(r){return r=h.extendOwn({},r),function(n){return h.isMatch(n,r)}},h.times=function(n,r,t){var e=Array(Math.max(0,n));r=y(r,t,1);for(var u=0;u<n;u++)e[u]=r(u);return e},h.random=function(n,r){return null==r&&(r=n,n=0),n+Math.floor(Math.random()*(r-n+1))},h.now=Date.now||function(){return(new Date).getTime()};var L={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},P=h.invert(L),W=function(r){var t=function(n){return r[n]},n="(?:"+h.keys(r).join("|")+")",e=RegExp(n),u=RegExp(n,"g");return function(n){return n=null==n?"":""+n,e.test(n)?n.replace(u,t):n}};h.escape=W(L),h.unescape=W(P),h.result=function(n,r,t){h.isArray(r)||(r=[r]);var e=r.length;if(!e)return h.isFunction(t)?t.call(n):t;for(var u=0;u<e;u++){var i=null==n?void 0:n[r[u]];void 0===i&&(i=t,u=e),n=h.isFunction(i)?i.call(n):i}return n};var C=0;h.uniqueId=function(n){var r=++C+"";return n?n+r:r},h.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var J=/(.)^/,U={"'":"'","\\":"\\","\r":"r","\n":"n","\u2028":"u2028","\u2029":"u2029"},V=/\\|'|\r|\n|\u2028|\u2029/g,$=function(n){return"\\"+U[n]};h.template=function(i,n,r){!n&&r&&(n=r),n=h.defaults({},n,h.templateSettings);var t,e=RegExp([(n.escape||J).source,(n.interpolate||J).source,(n.evaluate||J).source].join("|")+"|$","g"),o=0,a="__p+='";i.replace(e,function(n,r,t,e,u){return a+=i.slice(o,u).replace(V,$),o=u+n.length,r?a+="'+\n((__t=("+r+"))==null?'':_.escape(__t))+\n'":t?a+="'+\n((__t=("+t+"))==null?'':__t)+\n'":e&&(a+="';\n"+e+"\n__p+='"),n}),a+="';\n",n.variable||(a="with(obj||{}){\n"+a+"}\n"),a="var __t,__p='',__j=Array.prototype.join,"+"print=function(){__p+=__j.call(arguments,'');};\n"+a+"return __p;\n";try{t=new Function(n.variable||"obj","_",a)}catch(n){throw n.source=a,n}var u=function(n){return t.call(this,n,h)},c=n.variable||"obj";return u.source="function("+c+"){\n"+a+"}",u},h.chain=function(n){var r=h(n);return r._chain=!0,r};var G=function(n,r){return n._chain?h(r).chain():r};h.mixin=function(t){return h.each(h.functions(t),function(n){var r=h[n]=t[n];h.prototype[n]=function(){var n=[this._wrapped];return u.apply(n,arguments),G(this,r.apply(h,n))}}),h},h.mixin(h),h.each(["pop","push","reverse","shift","sort","splice","unshift"],function(r){var t=e[r];h.prototype[r]=function(){var n=this._wrapped;return t.apply(n,arguments),"shift"!==r&&"splice"!==r||0!==n.length||delete n[0],G(this,n)}}),h.each(["concat","join","slice"],function(n){var r=e[n];h.prototype[n]=function(){return G(this,r.apply(this._wrapped,arguments))}}),h.prototype.value=function(){return this._wrapped},h.prototype.valueOf=h.prototype.toJSON=h.prototype.value,h.prototype.toString=function(){return String(this._wrapped)},"function"==typeof define&&define.amd&&define("underscore",[],function(){return h})}();;
'use strict';
if (typeof Object.assign != 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, "assign", {
        value: function assign(target, varArgs) { // .length of function is 2
            'use strict';
            if (target == null) { // TypeError if undefined or null
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var to = Object(target);

            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];

                if (nextSource != null) { // Skip over if undefined or null
                    for (var nextKey in nextSource) {
                        // Avoid bugs when hasOwnProperty is shadowed
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        },
        writable: true,
        configurable: true
    });
}
!function (value, t) {
    if ("object" == typeof exports && "undefined" != typeof module) {
        module.exports = t();
    } else {
        if ("function" == typeof define && define.amd) {
            define(t);
        } else {
            value.CodeFlask = t();
        }
    }
}(this, function () {
    /**
     * @param {string} key
     * @param {string} initial
     * @param {!Object} target
     * @return {?}
     */
    function add(key, initial, target) {
        var value = initial || "codeflask-style";
        var container = target || document.head;
        if (!key) {
            return false;
        }
        if (document.getElementById(value)) {
            return true;
        }
        /** @type {!Element} */
        var r = document.createElement("style");
        return r.innerHTML = key, r.id = value, container.appendChild(r), true;
    }
    /**
     * @param {string} s
     * @return {?}
     */
    function trim(s) {
        return String(s).replace(/[&<>"'`=\/]/g, function (s) {
            return entityMap[s];
        });
    }
    /** @type {string} */
    var e = '"SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace';
    /** @type {string} */
    var selectionMethod = "\n  .codeflask {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n  }\n\n  .codeflask, .codeflask * {\n    box-sizing: border-box;\n  }\n\n  .codeflask__pre {\n    pointer-events: none;\n    z-index: 3;\n    overflow: hidden;\n  }\n\n  .codeflask__textarea {\n    background: none;\n    border: none;\n    color: #fff;\n    z-index: 1;\n    resize: none;\n    font-family: " + e +
        ";\n    -webkit-appearance: pre;\n    caret-color: #111;\n    z-index: 2;\n    width: 100%;\n    height: 100%;\n  }\n\n  .codeflask--has-line-numbers .codeflask__textarea {\n    width: calc(100% - 40px);\n  }\n\n  .codeflask__code {\n    display: block;\n    font-family: " + e + ";\n    overflow: hidden;\n  }\n\n  .codeflask__flatten {\n    padding: 10px;\n    font-size: 13px;\n    line-height: 20px;\n    white-space: pre;\n    position: absolute;\n    top: 0;\n    left: 0;\n    overflow: auto;\n    margin: 0 !important;\n    outline: none;\n    text-align: left;\n  }\n\n  .codeflask--has-line-numbers .codeflask__flatten {\n    width: calc(100% - 40px);\n    left: 40px;\n  }\n\n  .codeflask__line-highlight {\n    position: absolute;\n    top: 10px;\n    left: 0;\n    width: 100%;\n    height: 20px;\n    background: rgba(0,0,0,0.1);\n    z-index: 1;\n  }\n\n  .codeflask__lines {\n    padding: 10px 4px;\n    font-size: 12px;\n    line-height: 20px;\n    font-family: 'Cousine', monospace;\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 40px;\n    height: 100%;\n    text-align: right;\n    color: #999;\n    z-index: 2;\n  }\n\n  .codeflask__lines__line {\n    display: block;\n  }\n\n  .codeflask.codeflask--has-line-numbers {\n    padding-left: 40px;\n  }\n\n  .codeflask.codeflask--has-line-numbers:before {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 40px;\n    height: 100%;\n    background: #eee;\n    z-index: 1;\n  }\n";
    var entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
    };
    var module;
    var exports;
    var _self;
    var data;
    var $window = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    var _ = (exports = module = {
        exports: {}
    }, _self = "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {}, data = function () {
        /** @type {!RegExp} */
        var lang = /\blang(?:uage)?-([\w-]+)\b/i;
        /** @type {number} */
        var nextid = 0;
        var _ = _self.Prism = {
            manual: _self.Prism && _self.Prism.manual,
            disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
            util: {
                encode: function (tokens) {
                    return tokens instanceof Token ? new Token(tokens.type, _.util.encode(tokens.content), tokens.alias) : "Array" === _.util.type(tokens) ? tokens.map(_.util.encode) : tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
                },
                type: function (o) {
                    return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
                },
                objId: function (obj) {
                    return obj.__id || Object.defineProperty(obj, "__id", {
                        value: ++nextid
                    }), obj.__id;
                },
                clone: function (obj, type) {
                    var symbol = _.util.type(obj);
                    switch (type = type || {}, symbol) {
                        case "Object":
                            if (type[_.util.objId(obj)]) {
                                return type[_.util.objId(obj)];
                            }
                            var memo = {};
                            var key;
                            for (key in type[_.util.objId(obj)] = memo, obj) {
                                if (obj.hasOwnProperty(key)) {
                                    memo[key] = _.util.clone(obj[key], type);
                                }
                            }
                            return memo;
                        case "Array":
                            return type[_.util.objId(obj)] ? type[_.util.objId(obj)] : (memo = [], type[_.util.objId(obj)] = memo, obj.forEach(function (value, key) {
                                memo[key] = _.util.clone(value, type);
                            }), memo);
                    }
                    return obj;
                }
            },
            languages: {
                extend: function (id, data) {
                    var out = _.util.clone(_.languages[id]);
                    var i;
                    for (i in data) {
                        out[i] = data[i];
                    }
                    return out;
                },
                insertBefore: function (name, value, props, root) {
                    var target = (root = root || _.languages)[name];
                    if (2 == arguments.length) {
                        var prop;
                        for (prop in props = arguments[1]) {
                            if (props.hasOwnProperty(prop)) {
                                target[prop] = props[prop];
                            }
                        }
                        return target;
                    }
                    var result = {};
                    var propertyName;
                    for (propertyName in target) {
                        if (target.hasOwnProperty(propertyName)) {
                            if (propertyName == value) {
                                for (prop in props) {
                                    if (props.hasOwnProperty(prop)) {
                                        result[prop] = props[prop];
                                    }
                                }
                            }
                            result[propertyName] = target[propertyName];
                        }
                    }
                    return _.languages.DFS(_.languages, function (key, value) {
                        if (value === root[name] && key != name) {
                            this[key] = result;
                        }
                    }), root[name] = result;
                },
                DFS: function (o, callback, type, visited) {
                    var i;
                    for (i in visited = visited || {}, o) {
                        if (o.hasOwnProperty(i)) {
                            callback.call(o, i, o[i], type || i);
                            if ("Object" !== _.util.type(o[i]) || visited[_.util.objId(o[i])]) {
                                if (!("Array" !== _.util.type(o[i]) || visited[_.util.objId(o[i])])) {
                                    /** @type {boolean} */
                                    visited[_.util.objId(o[i])] = true;
                                    _.languages.DFS(o[i], callback, i, visited);
                                }
                            } else {
                                /** @type {boolean} */
                                visited[_.util.objId(o[i])] = true;
                                _.languages.DFS(o[i], callback, null, visited);
                            }
                        }
                    }
                }
            },
            plugins: {},
            highlightAll: function (callback, options) {
                _.highlightAllUnder(document, callback, options);
            },
            highlightAllUnder: function (context, callback, usePostMessage) {
                var env = {
                    callback: usePostMessage,
                    selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
                };
                _.hooks.run("before-highlightall", env);
                var code;
                var callbackVals = env.elements || context.querySelectorAll(env.selector);
                /** @type {number} */
                var callbackCount = 0;
                for (; code = callbackVals[callbackCount++];) {
                    _.highlightElement(code, true === callback, env.callback);
                }
            },
            highlightElement: function (element, async, callback) {
                var language;
                var grammar;
                /** @type {!Element} */
                var parent = element;
                for (; parent && !lang.test(parent.className);) {
                    parent = parent.parentNode;
                }
                if (parent) {
                    language = (parent.className.match(lang) || [, ""])[1].toLowerCase();
                    grammar = _.languages[language];
                }
                element.className = element.className.replace(lang, "").replace(/\s+/g, " ") + " language-" + language;
                if (element.parentNode) {
                    parent = element.parentNode;
                    if (/pre/i.test(parent.nodeName)) {
                        /** @type {string} */
                        parent.className = parent.className.replace(lang, "").replace(/\s+/g, " ") + " language-" + language;
                    }
                }
                var env = {
                    element: element,
                    language: language,
                    grammar: grammar,
                    code: element.textContent
                };
                if (_.hooks.run("before-sanity-check", env), !env.code || !env.grammar) {
                    return env.code && (_.hooks.run("before-highlight", env), env.element.textContent = env.code, _.hooks.run("after-highlight", env)), void _.hooks.run("complete", env);
                }
                if (_.hooks.run("before-highlight", env), async && _self.Worker) {
                    /** @type {!Worker} */
                    var layoutWorker = new Worker(_.filename);
                    /**
                     * @param {!Object} evt
                     * @return {undefined}
                     */
                    layoutWorker.onmessage = function (evt) {
                        env.highlightedCode = evt.data;
                        _.hooks.run("before-insert", env);
                        env.element.innerHTML = env.highlightedCode;
                        if (callback) {
                            callback.call(env.element);
                        }
                        _.hooks.run("after-highlight", env);
                        _.hooks.run("complete", env);
                    };
                    layoutWorker.postMessage(JSON.stringify({
                        language: env.language,
                        code: env.code,
                        immediateClose: true
                    }));
                } else {
                    env.highlightedCode = _.highlight(env.code, env.grammar, env.language);
                    _.hooks.run("before-insert", env);
                    env.element.innerHTML = env.highlightedCode;
                    if (callback) {
                        callback.call(element);
                    }
                    _.hooks.run("after-highlight", env);
                    _.hooks.run("complete", env);
                }
            },
            highlight: function (c, g, name) {
                var options = {
                    code: c,
                    grammar: g,
                    language: name
                };
                return _.hooks.run("before-tokenize", options), options.tokens = _.tokenize(options.code, options.grammar), _.hooks.run("after-tokenize", options), Token.stringify(_.util.encode(options.tokens), options.language);
            },
            matchGrammar: function (text, strarr, grammar, index, startPos, oneshot, target) {
                /** @type {function(string, string, string, string, ?): undefined} */
                var Token = _.Token;
                var token;
                for (token in grammar) {
                    if (grammar.hasOwnProperty(token) && grammar[token]) {
                        if (token == target) {
                            return;
                        }
                        var patterns = grammar[token];
                        patterns = "Array" === _.util.type(patterns) ? patterns : [patterns];
                        /** @type {number} */
                        var i = 0;
                        for (; i < patterns.length; ++i) {
                            var pattern = patterns[i];
                            var inside = pattern.inside;
                            /** @type {boolean} */
                            var lookbehind = !!pattern.lookbehind;
                            /** @type {boolean} */
                            var greedy = !!pattern.greedy;
                            /** @type {number} */
                            var lookbehindLength = 0;
                            var alias = pattern.alias;
                            if (greedy && !pattern.pattern.global) {
                                var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
                                /** @type {!RegExp} */
                                pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
                            }
                            pattern = pattern.pattern || pattern;
                            /** @type {number} */
                            var x = index;
                            /** @type {number} */
                            var pos = startPos;
                            for (; x < strarr.length; pos = pos + strarr[x].length, ++x) {
                                var str = strarr[x];
                                if (strarr.length > text.length) {
                                    return;
                                }
                                if (!(str instanceof Token)) {
                                    if (greedy && x != strarr.length - 1) {
                                        if (pattern.lastIndex = pos, !(match = pattern.exec(text))) {
                                            break;
                                        }
                                        var from = match.index + (lookbehind ? match[1].length : 0);
                                        var first = match.index + match[0].length;
                                        var i = x;
                                        var start = pos;
                                        var len = strarr.length;
                                        for (; i < len && (start < first || !strarr[i].type && !strarr[i - 1].greedy); ++i) {
                                            if (from >= (start = start + strarr[i].length)) {
                                                ++x;
                                                pos = start;
                                            }
                                        }
                                        if (strarr[x] instanceof Token) {
                                            continue;
                                        }
                                        /** @type {number} */
                                        count = i - x;
                                        str = text.slice(pos, start);
                                        match.index -= pos;
                                    } else {
                                        /** @type {number} */
                                        pattern.lastIndex = 0;
                                        var match = pattern.exec(str);
                                        /** @type {number} */
                                        var count = 1;
                                    }
                                    if (match) {
                                        if (lookbehind) {
                                            lookbehindLength = match[1] ? match[1].length : 0;
                                        }
                                        first = (from = match.index + lookbehindLength) + (match = match[0].slice(lookbehindLength)).length;
                                        var m = str.slice(0, from);
                                        var i = str.slice(first);
                                        /** @type {!Array} */
                                        var args = [x, count];
                                        if (m) {
                                            ++x;
                                            pos = pos + m.length;
                                            args.push(m);
                                        }
                                        var wrapped = new Token(token, inside ? _.tokenize(match, inside) : match, alias, match, greedy);
                                        if (args.push(wrapped), i && args.push(i), Array.prototype.splice.apply(strarr, args), 1 != count && _.matchGrammar(text, strarr, grammar, x, pos, true, token), oneshot) {
                                            break;
                                        }
                                    } else {
                                        if (oneshot) {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },
            tokenize: function (text, grammar, options) {
                /** @type {!Array} */
                var strarr = [text];
                var rest = grammar.rest;
                if (rest) {
                    var token;
                    for (token in rest) {
                        grammar[token] = rest[token];
                    }
                    delete grammar.rest;
                }
                return _.matchGrammar(text, strarr, grammar, 0, 0, false), strarr;
            },
            hooks: {
                all: {},
                add: function (event, t) {
                    var cache = _.hooks.all;
                    cache[event] = cache[event] || [];
                    cache[event].push(t);
                },
                run: function (name, from) {
                    var ret = _.hooks.all[name];
                    if (ret && ret.length) {
                        var val;
                        /** @type {number} */
                        var r = 0;
                        for (; val = ret[r++];) {
                            val(from);
                        }
                    }
                }
            }
        };
        /** @type {function(string, string, string, string, ?): undefined} */
        var Token = _.Token = function (value, type, name, string, sentenceId) {
            /** @type {string} */
            this.type = value;
            /** @type {string} */
            this.content = type;
            /** @type {string} */
            this.alias = name;
            /** @type {number} */
            this.length = 0 | (string || "").length;
            /** @type {boolean} */
            this.greedy = !!sentenceId;
        };
        if (Token.stringify = function (o, language, parent) {
            if ("string" == typeof o) {
                return o;
            }
            if ("Array" === _.util.type(o)) {
                return o.map(function (tokens) {
                    return Token.stringify(tokens, language, o);
                }).join("");
            }
            var env = {
                type: o.type,
                content: Token.stringify(o.content, language, parent),
                tag: "span",
                classes: ["token", o.type],
                attributes: {},
                language: language,
                parent: parent
            };
            if (o.alias) {
                var searchPipeline = "Array" === _.util.type(o.alias) ? o.alias : [o.alias];
                Array.prototype.push.apply(env.classes, searchPipeline);
            }
            _.hooks.run("wrap", env);
            /** @type {string} */
            var mixElem = Object.keys(env.attributes).map(function (name) {
                return name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
            }).join(" ");
            return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + (mixElem ? " " + mixElem : "") + ">" + env.content + "</" + env.tag + ">";
        }, !_self.document) {
            return _self.addEventListener ? (_.disableWorkerMessageHandler || _self.addEventListener("message", function (textFile) {
                /** @type {*} */
                var message = JSON.parse(textFile.data);
                var lang = message.language;
                var code = message.code;
                var immediateClose = message.immediateClose;
                _self.postMessage(_.highlight(code, _.languages[lang], lang));
                if (immediateClose) {
                    _self.close();
                }
            }, false), _self.Prism) : _self.Prism;
        }
        var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();
        return script && (_.filename = script.src, _.manual || script.hasAttribute("data-manual") || ("loading" !== document.readyState ? window.requestAnimationFrame ? window.requestAnimationFrame(_.highlightAll) : window.setTimeout(_.highlightAll, 16) : document.addEventListener("DOMContentLoaded", _.highlightAll))), _self.Prism;
    }(), exports.exports && (exports.exports = data), void 0 !== $window && ($window.Prism = data),
        data.languages.ncalc = {
            expression: {
                pattern: /[\\{]{2}(?:(?![\}]{2})|.|\r|\n)*?[\\}]{2}/,
                greedy: true,
                inside: {
                    comment: [{
                        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                        lookbehind: true
                    }, {
                        pattern: /(^|[^\\:])\/\/.*/,
                        lookbehind: true,
                        greedy: true
                    }],
                    string: {
                        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
                        greedy: true
                    },
                    keyword: /\b(?:if|in|is|ifnull|isnull|ifnullorwhitespace|isnullorwhitespace)\b/,
                    boolean: /\b(?:true|false)\b/,
                    'function-ncalc': /[a-z0-9_]+(?=\()/i,
                    number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
                    operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|#|\^|%/,
                    'ncalc-region': /(?:{{)|(?:}})/,
                    punctuation: /[{}[\];(),.:]/,
                }
            }
        },
        data.languages.ncalc_no_brackets = {
            expression: {
                pattern: /(?:.|\r|\n)*/,
                greedy: true,
                inside: {
                    comment: [{
                        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                        lookbehind: true
                    }, {
                        pattern: /(^|[^\\:])\/\/.*/,
                        lookbehind: true,
                        greedy: true
                    }],
                    string: {
                        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
                        greedy: true
                    },
                    keyword: /\b(?:if|in|is|ifnull|isnull|ifnullorwhitespace|isnullorwhitespace)\b/,
                    boolean: /\b(?:true|false)\b/,
                    'function-ncalc': /[a-z0-9_]+(?=\()/i,
                    number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
                    operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|#|\^|%/,
                    'ncalc-region': /(?:{{)|(?:}})/,
                    punctuation: /[{}[\];(),.:]/,
                }
            }
        },
        data.languages.html = {
            'comment': /<!--[\s\S]*?-->/,
            'prolog': /<\?[\s\S]+?\?>/,
            'doctype': /<!DOCTYPE[\s\S]+?>/i,
            'cdata': /<!\[CDATA\[[\s\S]*?]]>/i,
            'tag': {
                pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i,
                greedy: true,
                inside: {
                    'tag': {
                        pattern: /^<\/?[^\s>\/]+/i,
                        inside: {
                            'punctuation': /^<\/?/,
                            'namespace': /^[^\s>\/:]+:/
                        }
                    },
                    'attr-value': {
                        pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i,
                        inside: {
                            'punctuation': [
                                /^=/,
                                {
                                    pattern: /(^|[^\\])["']/,
                                    lookbehind: true
                                }
                            ]
                        }
                    },
                    'punctuation': /\/?>/,
                    'attr-name': {
                        pattern: /[^\s>\/]+/,
                        inside: {
                            'namespace': /^[^\s>\/:]+:/
                        }
                    }

                }
            },
            'entity': /&#?[\da-z]{1,8};/i
        },
        data.languages.clike = {
            comment: [{
                pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                lookbehind: true
            }, {
                pattern: /(^|[^\\:])\/\/.*/,
                lookbehind: true,
                greedy: true
            }],
            string: {
                pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
                greedy: true
            },
            "class-name": {
                pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
                lookbehind: true,
                inside: {
                    punctuation: /[.\\]/
                }
            },
            keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
            boolean: /\b(?:true|false)\b/,
            function: /[a-z0-9_]+(?=\()/i,
            number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
            operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
            punctuation: /[{}[\];(),.:]/
        },
        data.languages.javascript = data.languages.extend("clike", {
            keyword: /\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
            number: /\b(?:0[xX][\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+|NaN|Infinity)\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,
            function: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*\()/i,
            operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
        }),
        data.languages.insertBefore("javascript", "keyword", {
            regex: {
                pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[[^\]\r\n]+]|\\.|[^/\\\[\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
                lookbehind: true,
                greedy: true
            },
            "function-variable": {
                pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=\s*(?:function\b|(?:\([^()]*\)|[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/i,
                alias: "function"
            },
            constant: /\b[A-Z][A-Z\d_]*\b/
        }),
        data.languages.insertBefore("javascript", "string", {
            "template-string": {
                pattern: /`(?:\\[\s\S]|[^\\`])*`/,
                greedy: true,
                inside: {
                    interpolation: {
                        pattern: /\$\{[^}]+\}/,
                        inside: {
                            "interpolation-punctuation": {
                                pattern: /^\$\{|\}$/,
                                alias: "punctuation"
                            },
                            rest: data.languages.javascript
                        }
                    },
                    string: /[\s\S]+/
                }
            }
        }),
        data.languages.css = {
            comment: /\/\*[\s\S]*?\*\//,
            atrule: {
                pattern: /@[\w-]+?.*?(?:;|(?=\s*\{))/i,
                inside: {
                    rule: /@[\w-]+/
                }
            },
            url: /url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
            selector: /[^{}\s][^{};]*?(?=\s*\{)/,
            string: {
                pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
                greedy: true
            },
            property: /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,
            important: /\B!important\b/i,
            function: /[-a-z0-9]+(?=\()/i,
            punctuation: /[(){};:]/
        },
        data.languages.css.atrule.inside.rest = data.languages.css,
        data.languages.css = {
            comment: /\/\*[\s\S]*?\*\//,
            atrule: {
                pattern: /@[\w-]+?.*?(?:;|(?=\s*\{))/i,
                inside: {
                    rule: /@[\w-]+/
                }
            },
            url: /url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
            selector: /[^{}\s][^{};]*?(?=\s*\{)/,
            string: {
                pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
                greedy: true
            },
            property: /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,
            important: /\B!important\b/i,
            function: /[-a-z0-9]+(?=\()/i,
            punctuation: /[(){};:]/
        },
        data.languages.css_with_ncalc = Object.assign({
            expression: data.languages.ncalc.expression
        }, data.languages.css),
        data.languages.javascript_with_ncalc = Object.assign({
            expression: data.languages.ncalc.expression
        }, data.languages.javascript),
        data.languages.html_with_ncalc = Object.assign({
            expression: data.languages.ncalc.expression
    }, data.languages.html),
        data.languages.csharp = data.languages.extend('clike', {
            'keyword': /\b(?:abstract|add|alias|as|ascending|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|descending|do|double|dynamic|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|from|get|global|goto|group|if|implicit|in|int|interface|internal|into|is|join|let|lock|long|namespace|new|null|object|operator|orderby|out|override|params|partial|private|protected|public|readonly|ref|remove|return|sbyte|sealed|select|set|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|value|var|virtual|void|volatile|where|while|yield)\b/,
	        'string': [
		        {
			        pattern: /@("|')(?:\1\1|\\[\s\S]|(?!\1)[^\\])*\1/,
			        greedy: true
		        },
		        {
			        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*?\1/,
			        greedy: true
		        }
	        ],
	        'class-name': [
		        {
			        // (Foo bar, Bar baz)
			        pattern: /\b[A-Z]\w*(?:\.\w+)*\b(?=\s+\w+)/,
			        inside: {
				        punctuation: /\./
			        }
		        },
		        {
			        // [Foo]
			        pattern: /(\[)[A-Z]\w*(?:\.\w+)*\b/,
			        lookbehind: true,
			        inside: {
				        punctuation: /\./
			        }
		        },
		        {
			        // class Foo : Bar
			        pattern: /(\b(?:class|interface)\s+[A-Z]\w*(?:\.\w+)*\s*:\s*)[A-Z]\w*(?:\.\w+)*\b/,
			        lookbehind: true,
			        inside: {
				        punctuation: /\./
			        }
		        },
		        {
			        // class Foo
			        pattern: /((?:\b(?:class|interface|new)\s+)|(?:catch\s+\())[A-Z]\w*(?:\.\w+)*\b/,
			        lookbehind: true,
			        inside: {
				        punctuation: /\./
			        }
		        }
	        ],
	        'number': /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)f?/i
        }),
        data.languages.insertBefore('csharp', 'class-name', {
            'generic-method': {
                pattern: /\w+\s*<[^>\r\n]+?>\s*(?=\()/,
                inside: {
                    function: /^\w+/,
                    'class-name': {
                        pattern: /\b[A-Z]\w*(?:\.\w+)*\b/,
                        inside: {
                            punctuation: /\./
                        }
                    },
                    keyword: data.languages.csharp.keyword,
                    punctuation: /[<>(),.:]/
                }
            },
            'preprocessor': {
                pattern: /(^\s*)#.*/m,
                lookbehind: true,
                alias: 'property',
                inside: {
                    // highlight preprocessor directives as keywords
                    'directive': {
                        pattern: /(\s*#)\b(?:define|elif|else|endif|endregion|error|if|line|pragma|region|undef|warning)\b/,
                        lookbehind: true,
                        alias: 'keyword'
                    }
                }
            }
        }),
        "undefined" != typeof self && self.Prism && self.document && document.querySelector && (self.Prism.fileHighlight = function () {
        var formatHints = {
            nc: "ncalc",
            nc_bo_brackets: "ncalc_bo_brackets",
            js: "javascript",
            css: "css",
            css_with_ncalc: "css_with_ncalc",
            js_with_ncalc: "javascript_with_ncalc"
        };
        Array.prototype.slice.call(document.querySelectorAll("pre[data-src]")).forEach(function (pre) {
            var language;
            var url = pre.getAttribute("data-src");
            /** @type {!Node} */
            var parent = pre;
            /** @type {!RegExp} */
            var lang = /\blang(?:uage)?-(?!\*)([\w-]+)\b/i;
            for (; parent && !lang.test(parent.className);) {
                parent = parent.parentNode;
            }
            if (parent && (language = (pre.className.match(lang) || [, ""])[1]), !language) {
                var extension = (url.match(/\.(\w+)$/) || [, ""])[1];
                language = formatHints[extension] || extension;
            }
            /** @type {!Element} */
            var code = document.createElement("code");
            /** @type {string} */
            code.className = "language-" + language;
            /** @type {string} */
            pre.textContent = "";
            /** @type {string} */
            code.textContent = "Loading\u2026";
            pre.appendChild(code);
            /** @type {!XMLHttpRequest} */
            var xhr = new XMLHttpRequest;
            xhr.open("GET", url, true);
            /**
             * @return {undefined}
             */
            xhr.onreadystatechange = function () {
                if (4 == xhr.readyState) {
                    if (xhr.status < 400 && xhr.responseText) {
                        /** @type {string} */
                        code.textContent = xhr.responseText;
                        data.highlightElement(code);
                    } else {
                        if (xhr.status >= 400) {
                            /** @type {string} */
                            code.textContent = "\u2716 Error " + xhr.status + " while fetching file: " + xhr.statusText;
                        } else {
                            /** @type {string} */
                            code.textContent = "\u2716 Error: File does not exist or is empty";
                        }
                    }
                }
            };
            if (pre.hasAttribute("data-download-link") && data.plugins.toolbar) {
                data.plugins.toolbar.registerButton("download-file", function () {
                    /** @type {!Element} */
                    var download = document.createElement("a");
                    return download.textContent = pre.getAttribute("data-download-link-label") || "Download", download.setAttribute("download", ""), download.href = url, download;
                });
            }
            xhr.send(null);
        });
    }, document.addEventListener("DOMContentLoaded", self.Prism.fileHighlight)), module.exports);
    /**
     * @param {(Array|Element)} selector
     * @param {!Object} e
     * @return {undefined}
     */
    var $ = function (selector, e) {
        if (!selector) {
            throw Error("CodeFlask expects a parameter which is Element or a String selector");
        }
        if (!e) {
            throw Error("CodeFlask expects an object containing options as second parameter");
        }
        if (selector.nodeType) {
            /** @type {(Array|Element)} */
            this.editorRoot = selector;
        } else {
            /** @type {(Element|null)} */
            var radioElements = document.querySelector(selector);
            if (radioElements) {
                /** @type {!Element} */
                this.editorRoot = radioElements;
            }
        }
        /** @type {!Object} */
        this.opts = e;
        this.startEditor();
    };
    return $.prototype.startEditor = function () {
        if (!add(selectionMethod, null, this.opts.styleParent)) {
            throw Error("Failed to inject CodeFlask CSS.");
        }
        this.createWrapper();
        this.createTextarea();
        this.createPre();
        this.createCode();
        this.runOptions();
        this.listenTextarea();
        this.populateDefault();
        this.updateCode(this.code);
    }, $.prototype.createWrapper = function () {
        this.code = this.editorRoot.innerHTML;
        /** @type {string} */
        this.editorRoot.innerHTML = "";
        this.elWrapper = this.createElement("div", this.editorRoot);
        this.elWrapper.classList.add("codeflask");
    }, $.prototype.createTextarea = function () {
        this.elTextarea = this.createElement("textarea", this.elWrapper);
        this.elTextarea.classList.add("codeflask__textarea");
        this.elTextarea.classList.add("codeflask__flatten");
    }, $.prototype.createPre = function () {
        this.elPre = this.createElement("pre", this.elWrapper);
        this.elPre.classList.add("codeflask__pre");
        this.elPre.classList.add("codeflask__flatten");
    }, $.prototype.createCode = function () {
        this.elCode = this.createElement("code", this.elPre);
        this.elCode.classList.add("codeflask__code");
        this.elCode.classList.add("language-" + (this.opts.language || "html"));
    }, $.prototype.createLineNumbers = function () {
        this.elLineNumbers = this.createElement("div", this.elWrapper);
        this.elLineNumbers.classList.add("codeflask__lines");
        this.setLineNumber();
    }, $.prototype.createElement = function (el, t) {
        /** @type {!Element} */
        var n = document.createElement(el);
        return t.appendChild(n), n;
    }, $.prototype.runOptions = function () {
        this.opts.rtl = this.opts.rtl || false;
        this.opts.tabSize = this.opts.tabSize || 2;
        this.opts.enableAutocorrect = this.opts.enableAutocorrect || false;
        this.opts.lineNumbers = this.opts.lineNumbers || false;
        /** @type {boolean} */
        this.opts.defaultTheme = false !== this.opts.defaultTheme;
        if (true === this.opts.rtl) {
            this.elTextarea.setAttribute("dir", "rtl");
            this.elPre.setAttribute("dir", "rtl");
        }
        if (false === this.opts.enableAutocorrect) {
            this.elTextarea.setAttribute("spellcheck", "false");
            this.elTextarea.setAttribute("autocapitalize", "off");
            this.elTextarea.setAttribute("autocomplete", "off");
            this.elTextarea.setAttribute("autocorrect", "off");
        }
        if (this.opts.lineNumbers) {
            this.elWrapper.classList.add("codeflask--has-line-numbers");
            this.createLineNumbers();
        }
        if (this.opts.defaultTheme) {
            add(".codeflask {   background: #fff;   color: #5c6773; } .codeflask .token.ncalc-region { color: #9e9e9e; } .codeflask .token.punctuation {   color: #444444; } .codeflask .token.keyword {   color: #F29718; } .codeflask .token.operator {   color: #5c6773; } .codeflask .token.string {   color: #86B300; } .codeflask .token.comment {   color: #ABB0B6; } .codeflask .token.function-ncalc {   color: #41a6d9; }  .codeflask .token.function {   color: #5c6773; } .codeflask .token.boolean {   color: #A37ACC; } .codeflask .token.number {   color: #A37ACC; } .codeflask .token.selector {   color: #F29718; } .codeflask .token.property {   color: #41A6D9; } .codeflask .token.tag {   color: #41A6D9; } .codeflask .token.attr-value {   color: #A37ACC; }",
                "theme-default", this.opts.styleParent);
        }
    }, $.prototype.updateLineNumbersCount = function () {
        /** @type {string} */
        var element = "";
        /** @type {number} */
        var disabledClassName = 1;
        for (; disabledClassName <= this.lineNumber; disabledClassName++) {
            /** @type {string} */
            element = element + '<span class="codeflask__lines__line">' + disabledClassName + "</span>";
        }
        /** @type {string} */
        this.elLineNumbers.innerHTML = element;
    }, $.prototype.listenTextarea = function () {
        var node = this;
        this.elTextarea.addEventListener("input", function (t) {
            node.code = t.target.value;
            node.elCode.innerHTML = trim(t.target.value);
            node.highlight();
            setTimeout(function () {
                node.runUpdate();
                node.setLineNumber();
            }, 1);
        });
        this.elTextarea.addEventListener("keydown", function (n) {
            node.handleTabs(n);
            node.handleSelfClosingCharacters(n);
            node.handleNewLineIndentation(n);
        });
        this.elTextarea.addEventListener("scroll", function (stub) {
            /** @type {string} */
            node.elPre.style.transform = "translate3d(-" + stub.target.scrollLeft + "px, -" + stub.target.scrollTop + "px, 0)";
            if (node.elLineNumbers) {
                /** @type {string} */
                node.elLineNumbers.style.transform = "translate3d(0, -" + stub.target.scrollTop + "px, 0)";
            }
        });
    }, $.prototype.handleTabs = function (e) {
        if (9 === e.keyCode) {
            e.preventDefault();
            e.keyCode;
            var idx = this.elTextarea.selectionStart;
            var end = this.elTextarea.selectionEnd;
            var executableCode = "" + this.code.substring(0, idx) + " ".repeat(this.opts.tabSize) + this.code.substring(end);
            this.updateCode(executableCode);
            this.elTextarea.selectionEnd = end + this.opts.tabSize;
        }
    }, $.prototype.handleSelfClosingCharacters = function (team) {
        if (this.opts.autoCloseBrackets === false) {
            return;
        }
        var type = team.key;
        if (["(", "[", "{", "<"].includes(type)) {
            switch (type) {
                case "(":
                    this.closeCharacter(")");
                    break;
                case "[":
                    this.closeCharacter("]");
                    break;
                case "{":
                    this.closeCharacter("}");
                    break;
                case "<":
                    this.closeCharacter(">");
            }
        }
    }, $.prototype.setLineNumber = function () {
        this.lineNumber = this.code.split("\n").length;
        if (this.opts.lineNumbers) {
            this.updateLineNumbersCount();
        }
    }, $.prototype.handleNewLineIndentation = function (s) {
        s.keyCode;
    }, $.prototype.closeCharacter = function (result) {
        var idx = this.elTextarea.selectionStart;
        var end = this.elTextarea.selectionEnd;
        var executableCode = "" + this.code.substring(0, idx) + result + this.code.substring(end);
        this.updateCode(executableCode);
        this.elTextarea.selectionEnd = end;
    }, $.prototype.updateCode = function (code) {
        /** @type {string} */
        this.code = code;
        /** @type {string} */
        this.elTextarea.value = code;
        this.elCode.innerHTML = trim(code);
        this.highlight();
        (function (flask) {
            setTimeout(function ()
            {
                flask.runUpdate()
            }, 1);
        })(this);
    }, $.prototype.updateLanguage = function (type) {
        var id = this.opts.language;
        this.elCode.classList.remove("language-" + id);
        this.elCode.classList.add("language-" + type);
        /** @type {string} */
        this.opts.language = type;
        this.highlight();
    }, $.prototype.addLanguage = function (language, wording) {
        _.languages[language] = wording;
    }, $.prototype.populateDefault = function () {
        this.updateCode(this.code);
    }, $.prototype.highlight = function () {
        _.highlightElement(this.elCode, false);
    }, $.prototype.onUpdate = function (obj) {
        if (obj && "[object Function]" !== {}.toString.call(obj)) {
            throw Error("CodeFlask expects callback of type Function");
        }
        /** @type {boolean} */
        this.updateCallBack = obj;
    }, $.prototype.getCode = function () {
        return this.code;
        }, $.prototype.runUpdate = function () {
        if (this.updateCallBack) {
            this.updateCallBack(this.code);
        }
    }, $;
});
;
